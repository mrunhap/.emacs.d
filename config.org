#+STARTUP: fold
#+PROPERTY: header-args :tangle init.el :mkdirp yes

* Early init
#+begin_src elisp :tangle early-init.el
(setq
 ;; Resizing the Emacs frame can be a terribly expensive part of changing the
 ;; font. By inhibiting this, we easily halve startup times with fonts that are
 ;; larger than the system default.
 frame-inhibit-implied-resize t
 ;; After startup `gcmh' will reset this.
 gc-cons-threshold most-positive-fixnum
 gc-cons-percentage 0.6
 ;; Faster to disable these here (before they've been initialized)
 default-frame-alist '((scroll-bar-mode . 0)
                       (vertical-scroll-bars . nil)
                       (menu-bar-lines . 0)
                       (tool-bar-lines . 0)))
#+end_src

* Basic
** Load custom file
#+begin_src elisp
;;; -*- lexical-binding: t -*-
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (and (file-exists-p custom-file) (file-readable-p custom-file))
  (load custom-file :no-error :no-message))
#+end_src
** Package
#+begin_src emacs-lisp
(setq package-archives '(("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
			             ("nongnu" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/")
                         ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"))
      package-quickstart t)

(unless (package-installed-p 'setup)
  (package-refresh-contents)
  (package-install 'setup))
(eval-when-compile
  (require 'setup))

(setup-define :needs
  (lambda (executable)
    `(unless (executable-find ,executable)
   ,(setup-quit)))
  :documentation "If EXECUTABLE is not in the path, stop here."
  :repeatable 1)

(setup-define :autoload
  (lambda (func)
    (let ((fn (if (memq (car-safe func) '(quote function))
		          (cadr func)
		        func)))
      `(unless (fboundp (quote ,fn))
	     (autoload (function ,fn) ,(symbol-name (setup-get 'feature)) nil t))))
  :documentation "Autoload COMMAND if not already bound."
  :repeatable t
  :signature '(FUNC ...))

(setup (:package elpa-mirror)
  (:option elpamr-default-output-directory "~/.myelpa"))
#+end_src
** Variables
#+begin_src elisp
(defvar eat/user-full-name "Liu Bo")

(defvar eat/user-mail-address "liubolovelife@gmail.com")

(defconst eat/macp (eq system-type 'darwin)
  "Are we running on a Mac system?")

(defconst eat/linuxp (eq system-type 'gnu/linux)
  "Are we running on a GNU/Linux system?")

(defconst eat/winp (eq system-type 'windows-nt)
  "Are we running on a Windows system?")
#+end_src
** Module
#+begin_src emacs-lisp
(defvar eat/module-list
  `(
    ;; +icon
    ;; +blog
    ;; +telega
    ;; +mail
    ;; +benchmark
    ;; +kubernetes
    ;; +note-taking
    ))

(defvar eat/module--hash-table
  ((lambda ()
     (setq hash--table (make-hash-table))
     (dolist (m eat/module-list)
       (puthash m t hash--table))
     hash--table)))

(defun eat/modulep (module)
  (gethash module eat/module--hash-table))
#+end_src
** Optimization
#+begin_src elisp
;; bind `describe-keymap', added in emacs 28
(global-set-key (kbd "C-h C-k") #'describe-keymap)
;; this will stuck emacs
(global-unset-key (kbd "C-h h"))

(defun eat/show-startup-time ()
  "Print startup time."
  (message
   "Emacs loaded in %s with %d garbage collections."
   (format
    "%.2f seconds"
    (float-time
     (time-subtract after-init-time before-init-time)))
   gcs-done))
(add-hook 'emacs-startup-hook #'eat/show-startup-time)

;; GC automatically while unfocusing the frame
(add-function :after after-focus-change-function
              (lambda ()
                (unless (frame-focus-state)
                  (garbage-collect))))

;; Speed up startup
(setq auto-mode-case-fold nil)

;; Optimization
(setq idle-update-delay 1.0)

;; Don't ping things that look like domain names.
(setq ffap-machine-p-known 'reject)

;; The nano style for truncated long lines.
(setq auto-hscroll-mode 'current-line)

  ;; for mouse scroll
(setq dired-mouse-drag-files t
      mouse-drag-and-drop-region t
      mouse-drag-and-drop-region-cross-program t)
(if (fboundp 'pixel-scroll-precision-mode)
    (add-hook 'after-init-hook (lambda () (pixel-scroll-precision-mode))))

;; scroll nand hscroll
(setq-default
 scroll-step 2
 scroll-margin 2
 hscroll-step 2                                     ; Horizontal Scroll
 hscroll-margin 2
 scroll-conservatively 101
 scroll-up-aggressively 0.01
 scroll-down-aggressively 0.01
 scroll-preserve-screen-position 'always
 auto-window-vscroll nil
 fast-but-imprecise-scrolling nil
 mouse-wheel-scroll-amount '(1 ((shift) . hscroll)) ; use shift + mouse wheel to scrll horizontally
 mouse-wheel-progressive-speed nil)

;; Contrary to what many Emacs users have in their configs, you don't need
;; more than this to make UTF-8 the default coding system:
(set-language-environment "UTF-8")

;; Disable cursor blink
(add-hook 'after-init-hook (lambda () (blink-cursor-mode -1)))

;; Do not show cursor in nonselected windows
(setq-default cursor-in-non-selected-windows nil)

;; Suppress GUI features and more
(setq use-file-dialog nil
      use-dialog-box nil
      inhibit-splash-screen t
      inhibit-x-resources t
      inhibit-default-init t
      inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-buffer-menu t)

(setq fast-but-imprecise-scrolling t)
(setq redisplay-skip-fontification-on-input t)

;; Pixelwise resize
(setq ;; window-resize-pixelwise nil ;; NOTE this cause lsp-bridge-ref buffer didn't show
 frame-resize-pixelwise t)

;; Shut up!
(defun display-startup-echo-area-message()
  (message nil))

;; indent with whitespace by default
(setq-default
 tab-width 4
 indent-tabs-mode nil)

;; Disable default auto backup and save file
(setq-default
 create-lockfiles nil                               ; Don't create lockfiles
 make-backup-files nil                              ; Disable auto save and backup
 auto-save-default nil
 auto-save-list-file-prefix nil)

(setq
 initial-scratch-message (concat ";; Happy hacking, " user-login-name " - Emacs ♥ you!\n\n")
 initial-major-mode 'fundamental-mode               ; Don't use prog-mode an stratup
 ring-bell-function 'ignore
 read-process-output-max (* 4 1024 1024)
 suggest-key-bindings nil                           ; Disable "You can run the command balabala..."
 word-wrap-by-category t                            ; Emacs 之光！
 use-short-answers t                                ; yse-or-no -> y-or-n
 suggest-key-bindings nil
 enable-recursive-minibuffers t
 )

(setq-default
 inhibit-compacting-font-caches t                   ; Don’t compact font caches during GC.
 require-final-newline t                            ; add final newline
 visible-cursor t
 bidi-inhibit-bpa t                                 ; Improve long line display performance
 bidi-paragraph-direction 'left-to-right
 echo-keystrokes 0.01                               ; don't wait for keystrokes display
 warning-suppress-log-types '((comp))               ; Don't display compile warnings
 truncate-partial-width-windows 65                  ; Don't truncate lines in a window narrower than 65 chars.
 vc-follow-symlinks t                               ; always follow link
 server-client-instructions nil                     ; no client startup messages
 split-height-threshold nil                         ; prefer horizental split
 split-width-threshold 120
 )
#+end_src
*** GCMH
#+begin_src elisp
(setup (:package gcmh)
  (:with-hook after-init-hook
    (:hook gcmh-mode))
  (:option gcmh-idle-delay 5
           gcmh-high-cons-threshold #x6400000))
#+end_src

** PATH
#+begin_src elisp
;;; Setup PATH
;; https://emacs-china.org/t/emacs-mac-port-profile/2895/29?u=rua
;; NOTE: When PATH is changed, run the following command
;; $ sh -c 'printf "%s" "$PATH"' > ~/.path
(defun eat/getenv-path()
  (interactive)
  (condition-case err
      (let ((path (with-temp-buffer
                    (insert-file-contents-literally "~/.path")
                    (buffer-string))))
        (setenv "PATH" path)
        (setq exec-path (append (parse-colon-path path) (list exec-directory))))
    (error (warn "%s" (error-message-string err)))))
#+end_src

** MacOS
#+begin_src elisp
(when eat/macp
  (setq mac-option-modifier 'meta
        mac-command-modifier 'super
        ;; Render thinner fonts
        ns-use-thin-smoothing t
        ;; Don't open a file in a new frame
        ns-pop-up-frames nil)

  (add-hook 'after-init-hook #'eat/getenv-path)

  (global-set-key [(super a)] #'mark-whole-buffer)
  (global-set-key [(super v)] #'yank)
  (global-set-key [(super c)] #'kill-ring-save)
  (global-set-key [(super s)] #'save-buffer)
  (global-set-key [(super l)] #'goto-line)
  (global-set-key [(super w)] #'delete-frame)
  (global-set-key [(super z)] #'undo)
  ;; `save-buffers-kill-emacs' will shutdown emacs daemon
  (global-set-key [(super q)] #'save-buffers-kill-terminal))
#+end_src

** Linux
#+begin_src elisp
(when eat/linuxp
  (setq x-underline-at-descent-line t)
  (setq-default
   ;; Don't use Fcitx5 in Emacs in PGTK build
   pgtk-use-im-context-on-new-connection nil
   x-gtk-resize-child-frames nil)

  ;; Don't use GTK+ tooltip
  (when (boundp 'x-gtk-use-system-tooltips)
    (setq x-gtk-use-system-tooltips nil)))
#+end_src

** Dvorak
#+begin_src elisp
;; Make “C-t” act like “C-x”, so it's easier to type on Dvorak layout
(keyboard-translate ?\C-t ?\C-x)
(keyboard-translate ?\C-x ?\C-t)
#+end_src

** Built-in packages
*** recentf
#+begin_src emacs-lisp
(setup recentf
  (:with-hook after-init-hook
    (:hook recentf-mode))
  (:option
   recentf-max-saved-items 1000
   recentf-exclude `(,tramp-file-name-regexp
                     "COMMIT_EDITMSG"))
  (:global "C-x C-r" recentf-open-files))
#+end_src

*** webjump
#+begin_src emacs-lisp
(setup webjump
  (global-set-key (kbd "C-x C-/") #'webjump)
  (setq webjump-sites
        '(("Emacs Wiki" . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" #1=""])
          ("Emacs China" . "emacs-china.org")
          ("Emacs Reddit" . "www.reddit.com/r/emacs/")
          ("Emacs News" . "sachachua.com/blog/category/emacs-news/")
          ("Github" . [simple-query "github.com" "github.com/search?q=" #1#])
          ("Google" . [simple-query "google.com" "google.com/search?q=" #1#])
          ("Youtube" . [simple-query "youtube.com" "youtube.com/results?search_query=" #1#])
          ("Google Groups" . [simple-query "groups.google.com" "groups.google.com/groups?q=" #1#])
          ("stackoverflow" . [simple-query "stackoverflow.com" "stackoverflow.com/search?q=" #1#])
          ("Wikipedia" . [simple-query "wikipedia.org" "wikipedia.org/wiki/" #1#]))))
#+end_src

*** repeat
#+begin_src emacs-lisp
(setup repeat
  (setq repeat-mode t
        repeat-keep-prefix t
        repeat-exit-timeout 3
        repeat-exit-key (kbd "RET")))
#+end_src

*** context-menu
#+begin_src emacs-lisp
(setup mouse
  (:with-hook after-init-hook
    (:hook context-menu-mode)))
#+end_src

*** project.el
#+begin_src elisp
(setup project
  (defun eat/project-name ()
    (file-name-nondirectory
     (directory-file-name
      (project-root
       (project-current)))))

  ;; do not remember tramp project
  (defun eat/project-remember-advice (fn pr &optional no-write)
    (let* ((remote? (file-remote-p (project-root pr)))
           (no-write (if remote? t no-write)))
      (funcall fn pr no-write)))
  (advice-add 'project-remember-project :around
              'eat/project-remember-advice)
  (with-eval-after-load 'project
    (defun eat/project-files-in-directory (dir)
      "Use `fd' to list files in DIR."
      (let* ((default-directory dir)
             (localdir (file-local-name (expand-file-name dir)))
             (command (format "fd -c never -H -t f -0 . %s" localdir)))
        (project--remote-file-names
         (sort (split-string (shell-command-to-string command) "\0" t)
               #'string<))))

    ;; use fd in `project-find-file'
    (when (executable-find "fd")
      (cl-defmethod project-files ((project (head local)) &optional dirs)
        "Override `project-files' to use `fd' in local projects."
        (mapcan #'eat/project-files-in-directory
                (or dirs (list (project-root project))))))

    (defun eat/project-try-local (dir)
      "Determine if DIR is a non-Git project."
      (catch 'ret
        (let ((pr-flags '((".project")
                          ("go.mod" "Cargo.toml" "project.clj" "pom.xml" "package.json") ;; higher priority
                          ("Makefile" "README.org" "README.md"))))
          (dolist (current-level pr-flags)
            (dolist (f current-level)
              (when-let ((root (locate-dominating-file dir f)))
                (throw 'ret (cons 'local root))))))))
    (cl-defmethod project-root ((project (head local)))
      (cdr project))
    (add-to-list 'project-find-functions #'eat/project-try-local t)))
#+end_src

*** tab-bar
#+begin_src elisp
(setup tab-bar
  (setq tab-bar-border nil
        tab-bar-close-button nil
        tab-bar-back-button nil
        tab-bar-new-button nil
        tab-bar-show nil
        tab-bar-format '(tab-bar-format-tabs)
        tab-bar-tab-name-format-function 'eat/tab-bar-tab-format-function
        tab-bar-separator ""
        tab-bar-new-tab-choice "*scratch*"
        tab-bar-tab-name-truncated-max 10)

  (defun eat/tab-bar-switch-project ()
    "Switch to project in a new tab, project name will be used as tab name.

No tab will created if the command is cancelled."
    (interactive)
    (let (succ)
      (unwind-protect
          (progn
            (tab-bar-new-tab)
            (call-interactively #'project-switch-project)
            (when-let ((proj (project-root (project-current))))
              (tab-bar-rename-tab (format "%s" (file-name-nondirectory (directory-file-name proj))))
              (setq succ t)))
        (unless succ
          (tab-bar-close-tab)))))

  (defun eat/tab-bar-tab-format-function (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (propertize (concat
                   " "
                   (alist-get 'name tab)
                   " ")
                  'face
                  (funcall tab-bar-tab-face-function tab))))
  (with-eval-after-load 'tab-bar)
  (define-key tab-prefix-map (kbd ".") #'tab-bar-switch-to-recent-tab)
  (define-key tab-prefix-map (kbd ",") #'tab-bar-rename-tab)
  (define-key tab-prefix-map (kbd "l") #'eat/tab-bar-switch-project))
#+end_src

*** TODO xref
Must set before consult.
Use control-left-click to jump to defintions.
Need ripgrep installed(check external program).

#+begin_src elisp
(setup xref
  (:with-hook (xref-after-return-hook xref-after-jump-hook)
    (:hook recenter))
  (global-unset-key (kbd "C-<down-mouse-1>"))
  (global-set-key (kbd "C-<mouse-1>") #'xref-find-definitions-at-mouse)
  (:option xref-prompt-for-identifier nil
        xref-search-program 'ripgrep
        xref-show-xrefs-function #'xref-show-definitions-completing-read
        xref-show-definitions-function #'xref-show-definitions-completing-read))
#+end_src

* Lib
#+begin_src elisp
(setup (:package async fullframe hide-mode-line))
(setup (:package pinyinlib)
  (:autoload pinyinlib-build-regexp-string))
#+end_src

* Frame
#+begin_src elisp
(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))

(defvar eat/after-make-console-frame-hooks '()
  "Hooks to run after creating a new TTY frame")
(defvar eat/after-make-window-system-frame-hooks '()
  "Hooks to run after creating a new window-system frame")

(defun eat/run-after-make-frame-hooks (frame)
  "Run configured hooks in response to the newly-created FRAME.
Selectively runs either `eat/after-make-console-frame-hooks' or
`eat/after-make-window-system-frame-hooks'"
  (with-selected-frame frame
    (run-hooks (if window-system
                   'eat/after-make-window-system-frame-hooks
                 'eat/after-make-console-frame-hooks))))

(add-hook 'after-make-frame-functions 'eat/run-after-make-frame-hooks)

(defconst eat/initial-frame (selected-frame)
  "The frame (if any) active during Emacs initialization.")

(add-hook 'after-init-hook
          (lambda () (when eat/initial-frame
                       (eat/run-after-make-frame-hooks eat/initial-frame))))
#+end_src

* Window
** Winner
#+begin_src elisp
(setup winner
  (:with-hook (after-init-hook)
    :hook winner-mode)
  (setq winner-dont-bind-my-keys t))
#+end_src
** Change Default Behavior of Split Window
#+begin_src elisp
;; When splitting window, show (other-buffer) in the new window
(defun split-window-func-with-other-buffer (split-function)
  (lambda (&optional arg)
    "Split this window and switch to the new window unless ARG is provided."
    (interactive "P")
    (funcall split-function)
    (let ((target-window (next-window)))
      (set-window-buffer target-window (other-buffer))
      (unless arg
        (select-window target-window)))))

;; FIXME
;; (global-set-key (kbd "C-x 2") (split-window-func-with-other-buffer 'split-window-vertically))
;; (global-set-key (kbd "C-x 3") (split-window-func-with-other-buffer 'split-window-horizontally))

(defun sanityinc/toggle-delete-other-windows ()
  "Delete other windows in frame if any, or restore previous window config."
  (interactive)
  (if (and winner-mode
           (equal (selected-window) (next-window)))
      (winner-undo)
    (delete-other-windows)))

(global-set-key (kbd "C-x 1") 'sanityinc/toggle-delete-other-windows)
#+end_src
** Rearrange Split Winows
#+begin_src elisp
(defun split-window-horizontally-instead ()
  "Kill any other windows and re-split such that the current window is on the top half of the frame."
  (interactive)
  (let ((other-buffer (and (next-window) (window-buffer (next-window)))))
    (delete-other-windows)
    (split-window-horizontally)
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun split-window-vertically-instead ()
  "Kill any other windows and re-split such that the current window is on the left half of the frame."
  (interactive)
  (let ((other-buffer (and (next-window) (window-buffer (next-window)))))
    (delete-other-windows)
    (split-window-vertically)
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(global-set-key (kbd "C-x |") 'split-window-horizontally-instead)
(global-set-key (kbd "C-x _") 'split-window-vertically-instead)
#+end_src
** Ace-window
#+begin_src elisp
(setup (:package ace-window)
  (global-set-key (kbd "M-o") 'ace-window)
  (setq aw-keys '(?a ?o ?e ?u ?i)
        aw-scope 'frame
        aw-dispatch-alist
        '((?d aw-delete-window "Ace - Delete Window")
          (?s aw-swap-window "Ace - Swap Window")
          (?p aw-flip-window)
          (?v aw-split-window-vert "Ace - Split Vert Window")
          (?h aw-split-window-horz "Ace - Split Horz Window")
          (?m delete-other-windows "Ace - Maximize Window")
          (?g delete-other-windows)
          (?b balance-windows)
          (?u (lambda ()
                (progn
                  (winner-undo)
                  (setq this-command 'winner-undo))))
          (?r winner-redo)))
  (dolist (cmd '(ace-window
                 aw--select-window))
    (advice-add cmd :after #'eat/pulse-momentary-line)))
#+end_src
** Popper
#+begin_src elisp
(setup (:package popper)
  (:with-hook after-init-hook
    (:hook (lambda ()
             (popper-mode +1))))
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "\\*Compile-Log\\*"
          "\\*Completions\\*"
          "\\*Warnings\\*"

          "^\\*eshell.*\\*$" eshell-mode ;eshell as a popup
          "^\\*shell.*\\*$"  shell-mode  ;shell as a popup
          "^\\*term.*\\*$"   term-mode   ;term as a popup
          "^\\*vterm.*\\*$"  vterm-mode  ;vterm as a popup

          ;; help & message
          help-mode
          ghelp-page-mode
          compilation-mode))
  (with-eval-after-load 'project
    (setq popper-group-function 'popper-group-by-project))
  (with-eval-after-load 'popper
    (global-set-key (kbd "C-M-`") #'popper-toggle-type)
    (defun my-popper-fit-window-height (win)
      "Determine the height of popup window WIN by fitting it to the buffer's content."
      (fit-window-to-buffer
       win
       (floor (frame-height) 3)
       (floor (frame-height) 3)))
    (setq popper-window-height #'my-popper-fit-window-height)))
#+end_src
* Buffer
** Functions
#+begin_src emacs-lisp
(defun eat/delete-to-the-begining ()
  (interactive)
  (delete-region (point-min) (point)))

(defun eat/delete-to-the-end ()
  (interactive)
  (delete-region (point) (point-max)))

(defun eat/delete-whole-buffer ()
  (interactive)
  (delete-region (point-min) (point-max)))

(defun eat/delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))

(defun eat/rename-this-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (progn
      (when (file-exists-p filename)
        (rename-file filename new-name 1))
      (set-visited-file-name new-name)
      (rename-buffer new-name))))

(defun get-string-from-file (filePath)
  "Return file content as string."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))
#+end_src
** Ibuffer
#+begin_src elisp
(setup ibuffer
  (:package ibuffer-vc)
  (fset 'list-buffers 'ibuffer)
  (setq-default ibuffer-show-empty-filter-groups nil)
  (global-set-key (kbd "C-x B") 'ibuffer)
  ;; Modify the default ibuffer-formats (toggle with `)
  (setq ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 22 22 :left :elide)
                " "
                (size-h 9 -1 :right)
                " "
                (mode 12 12 :left :elide)
                " "
                vc-relative-file)
          (mark modified read-only vc-status-mini " "
                (name 22 22 :left :elide)
                " "
                (size-h 9 -1 :right)
                " "
                (mode 14 14 :left :elide)
                " "
                (vc-status 12 12 :left)
                " "
                vc-relative-file)))
  (with-eval-after-load 'ibuffer
    (setq ibuffer-filter-group-name-face 'font-lock-doc-face)
    (with-eval-after-load 'fullframe
      (fullframe ibuffer ibuffer-quit))
    ;; Use human readable Size column instead of original one
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (file-size-human-readable (buffer-size))))
  ;; Ibuffer-vc
  (:with-hook ibuffer-hook
    (:hook ibuffer-set-up-preferred-filters))
  (defun ibuffer-set-up-preferred-filters ()
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'filename/process)
      (ibuffer-do-sort-by-filename/process))))
#+end_src
** Auto-save
#+begin_src elisp
(add-hook 'after-init-hook #'auto-save-visited-mode)
#+end_src
** Isearch
#+begin_src elisp
(setup isearch
  (:package isearch-mb)
  (:option
   ;; Match count next to the minibuffer prompt
   isearch-lazy-count t
   ;; Don't be stingy with history; default is to keep just 16 entries
   search-ring-max 200
   regexp-search-ring-max 200
   ;; htighlighted all matching
   isearch-lazy-highlight t
   lazy-highlight-buffer t
   ;; show search count, TODO not work in isearch-mb-mode
   lazy-count-prefix-format nil
   lazy-count-suffix-format " [%s/%s]"
   ;; Record isearch in minibuffer history, so C-x ESC ESC can repeat it.
   isearch-resume-in-command-history t
   ;; M-< and M-> move to the first/last occurrence of the current search string.
   isearch-allow-motion t
   isearch-motion-changes-direction t
   ;; space matches any sequence of characters in a line.
   isearch-regexp-lax-whitespace t
   search-whitespace-regexp ".*?")
  (:global
   "C-s" isearch-forward-regexp
   "C-r" isearch-backward-regexp)
  (:bind
   "C-c C-o" isearch-occur
   [escape] isearch-cancel
   ;; Edit the search string instead of jumping back
   [remap isearch-delete-chac] isearch-del-chac)
  (with-eval-after-load 'isearch
    (define-advice isearch-occur (:after (_regexp &optional _nlines))
      (isearch-exit)))
  ;; Isearch-mb
  (:with-hook after-init-hook
    (:hook isearch-mb-mode))
  (with-eval-after-load 'isearch-mb
    (define-advice isearch-mb--update-prompt (:around (fn &rest _) show-case-fold-info)
      "Show case fold info in the prompt."
      (cl-letf* ((isearch--describe-regexp-mode-orig
                  (symbol-function 'isearch--describe-regexp-mode))
                 ((symbol-function 'isearch--describe-regexp-mode)
                  (lambda (regexp-function &optional space-before)
                    (concat (if isearch-case-fold-search "[Case Fold] " "")
                            (funcall isearch--describe-regexp-mode-orig
                                     regexp-function space-before)))))
        (funcall fn _)))))
#+end_src

** Misc
#+begin_src elisp
(setq display-line-numbers-width 3)

(setup whitespace
  (:with-hook (prog-mode-hook conf-mode-hook)
    (:hook whitespace-mode))
  (:option whitespace-style '(face trailing)))

(setup global-goto-address
  (:with-hook after-init-hook
    (:hook global-goto-address-mode)))

(setup savehist
  (:with-hook after-init-hook
    (:hook savehist-mode))
  ;; Restore histories and registers after saving
  (setq history-length 1000))

(setup autorevert
  (:with-hook after-init-hook
    (:hook global-auto-revert-mode)))
(setup saveplace
  (:with-hook after-init-hook
    :hook save-place-mode))
(setup so-long
  (:with-hook after-init-hook
    (:hook global-so-long-mode)))
#+end_src

* Minibuffer
#+begin_src elisp
(setup minibuffer
  (setq
   completion-styles '(basic partial-completion)
   completion-category-overrides '((file (styles basic partial-completion)))
   completion-cycle-threshold t
   minibuffer-depth-indicate-mode t
   minibuffer-eldef-shorten-default t
   minibuffer-electric-default-mode t)
  ;; Quit that fucking minibuffer!
  (define-key minibuffer-local-map (kbd "C-g") #'keyboard-quit))
#+end_src
** Vertico
#+begin_src elisp
(setup (:package vertico marginalia consult orderless embark)
  ;; Vertico
  (:with-hook after-init-hook
    (:hook vertico-mode))
  (:with-hook rfn-eshadow-update-overlay-hook
    (:hook vertico-directory-tidy))
  (:bind-into vertico-map
    "DEL"   vertico-directory-delete-char
    "M-DEL" vertico-directory-delete-word
    "RET"   vertico-directory-enter)
  (:option vertico-resize nil
           vertico-count 17)
  ;; Marginalia
  (:with-hook after-init-hook
    (:hook marginalia-mode))
  ;; Consult
  (advice-add #'multi-occur :override #'consult-multi-occur)
  (:global [remap apropos]                       consult-apropos
           [remap bookmark-jump]                 consult-bookmark
           [remap goto-line]                     consult-goto-line
           [remap imenu]                         consult-imenu
           [remap locate]                        consult-locate
           [remap man]                           consult-man
           [remap recentf-open-files]            consult-recent-file
           [remap switch-to-buffer]              consult-buffer
           [remap switch-to-buffer-other-window] consult-buffer-other-window
           [remap switch-to-buffer-other-frame]  consult-buffer-other-frame
           [remap yank-pop]                      consult-yank-pop
           [remap project-find-regexp]           consult-ripgrep)
  (:option consult-project-root-function  (lambda ()
                                            (when-let (project (project-current))
                                              (car (project-roots project))))
           consult-narrow-key             "<"
           consult-line-numbers-widen     t
           consult-async-min-input        2
           consult-async-refresh-delay    0.15
           consult-async-input-throttle   0.2
           consult-async-input-debounce   0.1
           xref-show-xrefs-function       #'consult-xref
           xref-show-definitions-function #'consult-xref)
  ;; Use minibuffer completion as the UI for `completion-at-point'.
  (setq-default completion-in-region-function
                (lambda (&rest args)
                  (apply (if vertico-mode
                             #'consult-completion-in-region
                           #'completion--in-region)
                         args)))
  (with-eval-after-load 'consult
    (consult-customize consult-ripgrep consult-git-grep consult-grep
                       consult-bookmark consult-recent-file consult-xref
                       :preview-key (kbd "C-SPC"))
    (consult-customize consult-theme
                       :preview-key (list (kbd "C-SPC") :debounce 0.5 'any)))
  ;; Orderless
  (defun sanityinc/use-orderless-in-minibuffer ()
    (setq-local completion-styles '(substring orderless)))
  (:with-hook minibuffer-setup-hook
    (:hook sanityinc/use-orderless-in-minibuffer))
  (with-eval-after-load 'orderless
    (defun completion--regex-pinyin (str)
      (orderless-regexp (pinyinlib-build-regexp-string str)))
    (add-to-list 'orderless-matching-styles 'completion--regex-pinyin))
  ;; Embark
  (:bind-into vertico-map
    "C-c C-o" embark-export
    "C-c C-c" embark-act)
  (with-eval-after-load 'embark
    (:bind-into embark-meta-map
      "<escape>" keyboard-escape-quit))
  (with-eval-after-load 'embark
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))
    (with-eval-after-load 'consult
      (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode))))

(setup (:package consult-yasnippet consult-dir consult-eglot)
  (:global [remap list-directory] #'consult-dir)
  (:bind-into vertico-map
    "C-x C-d" consult-dir
    "C-x C-j" consult-dir-jump-file))
#+end_src

* UI
** Font
#+begin_src elisp
(defun font-installed-p (font-list)
  (let ((font-installed nil))
    (catch 'foo
      (dolist (font font-list)
        (when (find-font (font-spec :name font))
          (setq font-installed font)
          (throw 'foo t))))
    font-installed))

(defvar eat/fonts-default        '("IBM Plex Mono" "Cascadia Code" "Jetbrains Mono"
                                   "Menlo" "Monaco" "DejaVu Sans Mono" "Latin Modern Mono"
                                   "Source Code Pro"))
(defvar eat/fonts-variable-pitch '("Bookerly" "Cardo" "Times New Roman" "DejaVu Sans"))
(defvar eat/fonts-cjk            '("LXGW WenKai" "WenQuanYi Micro Hei" "Microsoft Yahei"))
(defvar eat/fonts-emoji          '("Noto Color Emoji" "Segoe UI Symbol" "Apple Color Emoji"))

(defvar eat/font-size-default   13)
(defvar eat/font-default        (font-installed-p eat/fonts-default))
(defvar eat/font-variable-pitch (font-installed-p eat/fonts-variable-pitch))
(defvar eat/font-cjk            (font-installed-p eat/fonts-cjk))
(defvar eat/font-emoji          (font-installed-p eat/fonts-emoji))

(defvar eat/font-rescale-alist
  `((,eat/font-variable-pitch . 1.3)
    (,eat/font-cjk            . 0.95)
    (,eat/font-emoji          . 0.85))
  "A list of font names that should be rescaled.")

(defun eat/rescale-font ()
  (interactive)
  (dolist (setting eat/font-rescale-alist)
    (when (car setting)
      (setf (alist-get (car setting)
                       face-font-rescale-alist nil nil #'equal)
		    (cdr setting)))))

(defun eat/fixed-pitch-setup ()
  (interactive)
  (setq buffer-face-mode-face '(:family "等距更纱黑体 SC"))
  (buffer-face-mode +1))

(defun eat/setup-modeline-font ()
  (set-face-attribute 'mode-line nil :family eat/font-default)
  (set-face-attribute 'mode-line-inactive nil :family eat/font-default))

(defun eat/setup-font ()
  (interactive)
  (set-face-attribute 'default     nil :height (* 10 eat/font-size-default))
  (when eat/font-default
    (set-face-attribute 'default     nil :family eat/font-default)
    (set-face-attribute 'fixed-pitch nil :font eat/font-default)
    (eat/setup-modeline-font))
  ;; variable-pitch
  (when eat/font-variable-pitch (set-face-font 'variable-pitch eat/font-variable-pitch))
  ;;  emoji
  (when eat/font-emoji
    (set-fontset-font t 'unicode eat/font-emoji)
    (set-fontset-font t 'emoji   eat/font-emoji))
  ;; Chinese font, NOTE must set after unicode
  (when eat/font-cjk
    (set-fontset-font t 'kana     eat/font-cjk)
    (set-fontset-font t 'han      eat/font-cjk)
    (set-fontset-font t 'cjk-misc eat/font-cjk)))

(add-hook 'eat/after-make-window-system-frame-hooks #'eat/setup-font)
(add-hook 'eat/after-make-window-system-frame-hooks #'eat/rescale-font)
(add-hook 'load-theme-hook                          #'eat/setup-modeline-font)
#+end_src
** Theme
*** Customize
#+begin_src elisp
(setq modus-themes-fringes nil)

(defvar eat/theme 'modus-operandi
  "Default theme.")

(defvar eat/theme-tui 'modus-operandi
  "Default TUI theme.")

(defvar eat/theme-system-light 'modus-operandi
  "Default light theme after system appearance changed.")

(defvar eat/theme-system-dark 'modus-vivendi
  "Default dark theme after system appearance changed.")

(defvar load-theme-hook nil
  "Hooks that run after `load-theme'.")

;; TODO use `enable-theme' instead
(defun gh/load-theme-advice (f theme-id &optional no-confirm no-enable &rest args)
  (dolist (theme custom-enabled-themes)
    (disable-theme theme))
  (apply f theme-id t no-enable args)
  (run-hooks 'load-theme-hook))

(advice-add 'load-theme
            :around
            #'gh/load-theme-advice)

(defun eat/tui-load-theme ()
  (when (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
  (load-theme eat/theme-tui))

(defun eat/gui-load-theme ()
  (load-theme eat/theme)
  ;; For MacOS, load theme after system appearance changed.
  (when (boundp 'ns-system-appearance)
    (add-to-list 'ns-system-appearance-change-functions
                 (lambda (l?d)
                   (if (eq l?d 'light)
                       (load-theme eat/theme-system-light)
                     (load-theme eat/theme-system-dark))))))

(add-hook 'eat/after-make-console-frame-hooks       #'eat/tui-load-theme)
(add-hook 'eat/after-make-window-system-frame-hooks #'eat/gui-load-theme)
#+end_src

*** Misc
#+begin_src emacs-lisp
(setup (:package tao-theme timu-spacegrey-theme kaolin-themes spacemacs-theme eziam-themes adwaita-dark-theme)
  (:option  kaolin-themes-underline-wave nil
            kaolin-themes-modeline-border nil
            kaolin-themes-modeline-padded 4
            spacemacs-theme-comment-italic t
            spacemacs-theme-keyword-italic t
            spacemacs-theme-org-agenda-height t
            spacemacs-theme-org-bold t
            spacemacs-theme-org-height t
            spacemacs-theme-org-highlight t
            spacemacs-theme-org-priority-bold t
            spacemacs-theme-underline-parens t))
#+end_src
** Mode line
#+begin_src elisp
(setup (:package minions))

(defun eat/setup-modeline ()
  (interactive)
  (minions-mode))

(add-hook 'after-init-hook #'eat/setup-modeline)
#+end_src

** Adjust opacity
#+begin_src emacs-lisp
(defun eat/adjust-opacity (frame incr)
  "Adjust the background opacity of FRAME by increment INCR."
  (unless (display-graphic-p frame)
    (error "Cannot adjust opacity of this frame"))
  (let* ((oldalpha (or (frame-parameter frame 'alpha-background) 100))
         (oldalpha (if (listp oldalpha) (car oldalpha) oldalpha))
         (newalpha (+ incr oldalpha)))
    (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
      (modify-frame-parameters frame (list (cons 'alpha-background newalpha))))))
(global-set-key (kbd "M-C-8") (lambda () (interactive) (eat/adjust-opacity nil -2)))
(global-set-key (kbd "M-C-9") (lambda () (interactive) (eat/adjust-opacity nil 2)))
(global-set-key (kbd "M-C-7") (lambda () (interactive) (modify-frame-parameters nil `((alpha-background . 100)))))
#+end_src
** Text Scale
#+begin_src elisp
(setup (:package default-text-scale)
  (:global
   "C-x C-=" default-text-scale-increase
   "C-x C--" default-text-scale-decrease))
#+end_src

* Editing
** Functions
#+begin_src emacs-lisp
;; http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))
(global-set-key [remap move-beginning-of-line] #'smarter-move-beginning-of-line)
#+end_src
** Built In Tools
*** Ediff
#+begin_src elisp
(setup ediff
  (defvar local-ediff-saved-window-conf nil)

  (defun eat/ediff-save-window-conf ()
    (setq local-ediff-saved-window-conf (current-window-configuration)))

  (defun eat/ediff-restore-window-conf ()
    (when (window-configuration-p local-ediff-saved-window-conf)
      (set-window-configuration local-ediff-saved-window-conf)))

  (setq ediff-window-setup-function #'ediff-setup-windows-plain
        ediff-highlight-all-diffs t
        ediff-split-window-function 'split-window-horizontally
        ediff-merge-split-window-function 'split-window-horizontally)
  (with-eval-after-load 'ediff
    ;; Restore window config after quitting ediff
    (add-hook 'ediff-before-setup-hook #'eat/ediff-save-window-conf)
    (add-hook 'ediff-quit-hook #'eat/ediff-restore-window-conf)))
#+end_src
*** Tramp
#+begin_src elisp
(setup tramp
  (setq
   remote-file-name-inhibit-locks t
   tramp-verbose 1 ;; only show error message
   tramp-completion-reread-directory-timeout nil ;;  speed up complete
   tramp-auto-save-directory temporary-file-directory
   ;; Always use file cache when using tramp
   remote-file-name-inhibit-cache nil
   ;; C-x C-f /ssh:
   tramp-default-method "ssh"
   vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                vc-ignore-dir-regexp
                                tramp-file-name-regexp))

  (defun eat/reopen-file-with-sudo ()
    (interactive)
    (find-alternate-file (format "/sudo::%s" (buffer-file-name))))
  (global-set-key (kbd "C-x C-z") #'eat/reopen-file-with-sudo)

  ;; https://www.reddit.com/r/emacs/comments/y92y4b/tramp_users_slowness_got_you_down_check/
  (defun my-vc-off-if-remote ()
    (if (file-remote-p (buffer-file-name))
        (setq-local vc-handled-backends '(Git))))
  (add-hook 'find-file-hook 'my-vc-off-if-remote)
  (with-eval-after-load 'tramp
    ;; use `magit' with yadm, (magit-status "/yadm::")
    (add-to-list 'tramp-methods
                 '("yadm"
                   (tramp-login-program "yadm")
                   (tramp-login-args (("enter")))
                   (tramp-login-env (("SHELL") ("/bin/sh")))
                   (tramp-remote-shell "/bin/sh")
                   (tramp-remote-shell-args ("-c"))))
    ;; ‘Private Directories’ are the settings of the $PATH environment,
    ;; as given in your ‘~/.profile’.  This entry is represented in
    ;; the list by the special value ‘tramp-own-remote-path’.
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path)))
#+end_src
*** Spell check
#+begin_src elisp
(setup ispell
  (when eat/macp
    (setenv "DICTIONARY" "en_US"))
  ;; no spell checking for org special blocks
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_example" . "#\\+end_example"))
  (setq ispell-dictionary "en_US"
        ispell-following-word t))

(setup flyspell
  (:needs "aspell")
  ;; `flyspell' -- only enable in magit commit
  (setq flyspell-issue-welcome-flag nil
        flyspell-issue-message-flag nil)
  (with-eval-after-load 'flyspell
    (setq flyspell-mode-map nil)))
#+end_src
*** Hl Line
#+begin_src emacs-lisp
(setup hl-line
  (:option
   hl-line-sticky-flag nil)
  ;; (when (display-graphic-p)
  ;;   (add-hook 'prog-mode-hook #'hl-line-mode)
  ;;   (add-hook 'conf-mode-hook #'hl-line-mode))
  (with-eval-after-load 'hl-line
    (:with-hook post-command-hook
      (:hook (lambda ()
               "When `hl-line-mode' is enable, unhighlight if region is active."
               (when (and (bound-and-true-p hl-line-mode)
                          (region-active-p))
                 (hl-line-unhighlight)))))))
#+end_src

*** Pulse
#+begin_src elisp
(setup pulse
  (:with-hook (imenu-after-jump-hook isearch-update-post-hook)
    (:hook eat/recenter-and-pulse))
  (:with-hook (bookmark-after-jump  next-error)
    (:hook eat/recenter-and-pulse-line))

  (custom-set-faces
   '(pulse-highlight-start-face ((t (:inherit region))))
   '(pulse-highlight-face ((t (:inherit region)))))

  (defun eat/pulse-momentary-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (defun eat/pulse-momentary (&rest _)
    "Pulse the region or the current line."
    (if (fboundp 'xref-pulse-momentarily)
        (xref-pulse-momentarily)
      (eat/pulse-momentary-line)))

  (defun eat/recenter-and-pulse(&rest _)
    "Recenter and pulse the region or the current line."
    (recenter)
    (eat/pulse-momentary))

  (defun eat/recenter-and-pulse-line (&rest _)
    "Recenter and pulse the current line."
    (recenter)
    (eat/pulse-momentary-line))

  (dolist (cmd '(recenter-top-bottom
                 other-window windmove-do-window-select
                 pager-page-down pager-page-up))
    (advice-add cmd :after #'eat/pulse-momentary-line))

  (dolist (cmd '(pop-to-mark-command
                 pop-global-mark
                 compile-goto-error
                 goto-last-change))
    (advice-add cmd :after #'eat/recenter-and-pulse)))
#+end_src

*** Outline
#+begin_src emacs-lisp
(setup outline
  (:option outline-minor-mode-cycle t
        outline-minor-mode-highlight t))
#+end_src

*** Simple
#+begin_src emacs-lisp
(setup simple
  (:with-hook before-save-hook
    (:hook delete-trailing-whitespace))
  (setq visual-line-fringe-indicators '(nil nil)
        ;; List only applicable commands.
        read-extended-command-predicate #'command-completion-default-include-p
        fill-column 72))
#+end_src

*** Subword
#+begin_src elisp
(setup subword
  (:hook-into prog-mode))
#+end_src
** Meow
*** Setup
#+begin_src elisp
(defun meow-setup-dvorak ()
  (interactive)
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-dvorak)

  (meow-motion-overwrite-define-key
   '("<escape>" . mode-line-other-buffer)
   '("'" . repeat)
   '(")" . tab-bar-switch-to-prev-tab)
   '("}" . tab-bar-switch-to-next-tab)
   )

  ;; NOTE key defined in leader same as bind to C-c
  ;; so make sure it didn't conflict with keybindings
  ;; defined in other files or bulitin that start with C-c
  ;; or use this to make it start with C-c m
  (defalias 'meow-leader-command-prefix (make-sparse-keymap))
  (defvar meow-leader-map (symbol-function 'meow-leader-command-prefix)
    "Keymap for characters following C-c m.")
  (define-key global-map "\C-c\ m" 'meow-leader-command-prefix)
  (add-to-list 'meow-keymap-alist (cons 'leader 'meow-leader-command-prefix))

  (meow-leader-define-key
   '("a" . execute-extended-command)
   '("e" . "C-x C-e")
   '(";" . comment-dwim)
   '("-" . negative-argument)

   ;; file
   '("f" . find-file)
   '("F" . find-file-other-window)

   ;; buffer
   '("b" . switch-to-buffer)
   '("B" . switch-to-buffer-other-window)
   '("k" . kill-this-buffer)

   ;; window
   '("w" . ace-window)
   '("W" . ace-swap-window)
   '("o" . "C-x 1")
   '("O" . ace-delete-window)
   '("q" . delete-window)
   '("-" . "C-x 2")
   '("s" . "C-x 3")

   ;; xref
   '("." . "M-.")
   '("," . "M-,")
   '("?" . "M-?")

   ;; project, bind to keymap
   (cons "p" project-prefix-map)
   ;; smerge
   ;; (cons "=" smerge-basic-map)

   ;; tab-bar
   (cons "t" tab-prefix-map)

   ;; app
   '("d" . dired)
   '("v" . magit)
   '("r" . rg-project)
   '("C" . xeft)

   ;; toggles
   '("$" . load-theme)
   '("L" . display-line-numbers-mode)
   '("A" . org-agenda-list)
   '("T" . telega)
   )

  (meow-normal-define-key
   '("?" . meow-cheatsheet)
   '("<escape>" . mode-line-other-buffer)
   '(";" . meow-reverse)
   '("g" . meow-cancel-selection)
   '("q" . meow-quit)

   ;; expand by numbers
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)

   ;; movement, like hjkl
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("t" . meow-right)
   '("T" . meow-right-expand)
   '("n" . meow-next)
   '("N" . meow-next-expand)
   '("p" . meow-prev)
   '("P" . meow-prev-expand)

   ;; insert above/below
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("A" . meow-open-below)
   '("a" . meow-append)

   ;; move/mark by word/symbol
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("w" . meow-next-word)
   '("W" . meow-next-symbol)
   '("m" . meow-mark-word)
   '("M" . meow-mark-symbol)

   ;; kill/delete/change/replace
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("k" . meow-kill)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("c" . meow-change)

   ;; line operation
   '("j" . meow-join)
   '("e" . meow-line) ;; NOTE F3 or insert/append/change in grab to enable "every n line" grab
   '("E" . meow-goto-line)
   '("o" . meow-block)
   '("O" . meow-to-block)

   ;; yank/pop
   '("x" . meow-save)
   '("X" . meow-sync-grab)
   '("y" . meow-yank)

   ;; grab
   '("G" . meow-grab)
   '("z" . meow-pop-selection)

   ;; query replace
   '("&" . meow-query-replace)
   '("%" . meow-query-replace-regexp)

   ;; thing
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("<" . meow-beginning-of-thing)
   '(">" . meow-end-of-thing)

   ;; find/till/visit, most used in beacon mode
   '("/" . meow-search)
   '("F" . meow-find)
   '("L" . meow-till)
   '("l" . meow-visit)

   ;; undo
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)


   ;;
   '(":" . execute-extended-command)

   ;; scroll
   '("v" . scroll-up-command)
   '("V" . scroll-down-command)

   ;; buffer
   '("S" . save-buffer)

   ;; window
   '("s" . ace-window)

   ;; wrap && unwrap
   '("\"" . insert-pair)
   '("[" . insert-pair)
   '("{" . insert-pair)
   '("(" . insert-pair)
   '("]" . delete-pair) ;; NOTE maybe custom `delete-pair-blink-delay'

   ;; flymake
   '("Q" . flymake-goto-prev-error)
   '("J" . flymake-goto-next-error)

   ;; tab-bar
   '(")" . tab-bar-switch-to-prev-tab)
   '("}" . tab-bar-switch-to-next-tab)

   ;; misc
   '("'" . repeat)
   '("-" . avy-goto-char-timer)
   '("f" . project-find-file)
   '("K" . kill-this-buffer)
   ))
#+end_src
*** Config
#+begin_src elisp
(setup (:package meow)
  (require 'meow)
  (:option
   meow-visit-sanitize-completion nil
   meow-esc-delay 0.001
   meow-keypad-describe-delay 1.0
   meow-replace-state-name-list
   '((normal . "N")
     (motion . "M")
     (keypad . "K")
     (insert . "I")
     (beacon . "B")))
  ;; specific font so that line won't break TODO chang to variable
  ;; (advice-add 'meow-cheatsheet :after (lambda ()
  ;;                                       (interactive)
  ;;                                       (setq buffer-face-mode-face '(:family "Menlo"))
  ;;                                       (buffer-face-mode +1)))
  ;; normal mode list
  (dolist (mode '(go-dot-mod-mode
                  diff-mode))
    (add-to-list 'meow-mode-state-list `(,mode . normal)))
  ;; motion mode list
  (dolist (mode '(lsp-bridge-ref-mode
                  Info-mode
                  ghelp-page-mode
                  notmuch-hello-mode
                  notmuch-search-mode
                  notmuch-tree-mode))
    (add-to-list 'meow-mode-state-list `(,mode . motion)))
  (dolist (mode '(xeft-mode
                  gud-mode))
    (add-to-list 'meow-mode-state-list `(,mode . insert)))

  (meow-setup-dvorak)
  (meow-setup-indicator)
  (meow-global-mode 1))
#+end_src
** Anzu
#+begin_src elisp
(setup (:package anzu)
  (:global
   [remap query-replace] anzu-query-replace
   [remap query-replace-regexp] anzu-query-replace-regexp))
#+end_src
** Separedit
#+begin_src emacs-lisp
(setup (:package separedit)
  ;; use C-u C-c ' to select major mode
  (:global "C-c '" separedit))
#+end_src
** Iscroll
Better scroll on picture in GUI
#+begin_src emacs-lisp
(setup (:package iscroll))
#+end_src

** Undo
*** vundo
#+begin_src emacs-lisp
(setup (:package vundo)
  (:autoload vundo))
#+end_src

*** undo-hl
#+begin_src emacs-lisp
(unless (package-installed-p 'undo-hl)
  (package-vc-install "https://github.com/casouri/undo-hl.git"))
(setup undo-hl
  (:with-hook (prog-mode-hook conf-mode-hook)
    (:hook undo-hl-mode)))
#+end_src

** TODO Chinese Input                                                 :deps:
Need rime module.

- Enable rime will increase awesome-tray modeline width
- Emacs can’t exis with =C-x C-c=
#+begin_src elisp
;; curl -L -O https://github.com/rime/librime/releases/download/1.7.2/rime-1.7.2-osx.zip
;; unzip rime-1.7.2-osx.zip -d ~/.config/emacs/librime
;; rm -rf rime-1.7.2-osx.zip
(setup (:package rime)
  (when eat/macp
    (setq rime-librime-root (expand-file-name "librime/dist" user-emacs-directory)))
  (:option
   rime-disable-predicates '(meow-normal-mode-p
                             ;; meow-motion-mode-p
                             meow-keypad-mode-p
                             meow-beacon-mode-p)
   rime-inline-predicates '(rime-predicate-space-after-cc-p
                            rime-predicate-current-uppercase-letter-p)
   rime-translate-keybindings '("C-f" "C-b" "C-n" "C-p" "C-g" "C-v" "M-v")
   rime-inline-ascii-holder ?a
   default-input-method "rime"
   rime-cursor "|"
   rime-show-candidate 'minibuffer)
  (with-eval-after-load 'rime
    (setq-default
     rime-posframe-properties (list :internal-border-width 1))
    (set-face-attribute 'rime-indicator-face nil :height 0.9)
    (set-face-attribute 'rime-indicator-dim-face nil :height 0.9)
    (define-key rime-active-mode-map [tab] 'rime-inline-ascii)
    (define-key rime-mode-map (kbd "M-j") 'rime-force-enable)))
#+end_src
** TODO Symbol Overlay

#+begin_src emacs-lisp
(setup (:package symbol-overlay))
 #+end_src
** Hl Todo
#+begin_src emacs-lisp
(setup (:package hl-todo)
  (:with-hook (dired-mode-hook prog-mode-hook conf-mode-hook)
    (:hook hl-todo-mode)))
#+end_src
** Ligature
#+begin_src emacs-lisp
(setup (:package ligature)
  (:autoload global-ligature-mode)
  (:with-hook prog-mode-hook
    (:hook (lambda () (ligature-mode t))))
  (with-eval-after-load 'ligature
    ;; https://htmlpreview.github.io/?https://github.com/kiliman/operator-mono-lig/blob/master/images/preview/normal/index.html
    (ligature-set-ligatures 'prog-mode
                            '("&&" "||" "|>" ":=" "==" "===" "==>" "=>"
                              "=<<" "!=" "!==" ">=" ">=>" ">>=" "->" "--"
                              "-->" "<|" "<=" "<==" "<=>" "<=<" "<!--" "<-"
                              "<->" "<--" "</" "+=" "++" "??" "/>" "__" "WWW"))))
#+end_src
** Avy
#+begin_src elisp
(setup (:package avy)
  (with-eval-after-load 'avy
    (:option
     avy-background t
     avy-style 'pre)))
#+end_src

* Completion
** Corfu
#+begin_src elisp
(setup corfu
  (:package corfu popon corfu-terminal)
  (:with-hook after-init-hook
    (:hook (lambda () (global-corfu-mode 1))))
  (:option corfu-preview-current nil
           corfu-auto-delay 0.2
           corfu-auto-prefix 2
           corfu-quit-no-match t
           corfu-quit-at-boundary t
           corfu-auto t)
  (with-eval-after-load 'corfu
    ;; tab in corfu-map
    (defun eat/corfu-complete ()
      (interactive)
      (or (yas-expand)
          ;; NOTE `corfu-complete' sometimes didn't quit corfu after complete
          (corfu-insert)))
    (:bind-into corfu-map
      ;; quit corfu completion and back to meow normal mode
      "<escape>" (lambda ()
                   (interactive)
                   (corfu-quit)
                   (when (meow-insert-mode-p)
                     (meow-insert-exit)))
      "<tab>" eat/corfu-complete
      "TAB" eat/corfu-complete
      "RET" nil)

    ;; tab in yas-keymap
    (defun eat/corfu-insert-or-maybe-expand ()
      "Try complete current cond or `yas-next-field-or-maybe-expand'.

Sometime lsp client return a snippet and complete didn't work(TAB will jump to next field),
so try complete filst, if there nothing to complete then try to jump to next field or expand."
      (interactive)
      (or (corfu-insert)
          (yas-next-field-or-maybe-expand)))
    (with-eval-after-load 'yasnippet
      (:bind-into yas-keymap
        "<tab>" eat/corfu-insert-or-maybe-expand
        "TAB" eat/corfu-insert-or-maybe-expand)))
  ;; corfu-terminal
  (:with-hook corfu-mode-hook
    (:hook (lambda ()
             (unless (display-graphic-p)
               (corfu-terminal-mode +1))))))
#+end_src
** Yasnippet
#+begin_src elisp
(setup (:package yasnippet yasnippet-snippets)
  (:with-hook (prog-mode-hook conf-mode-hook)
    (:hook yas-minor-mode))
  (with-eval-after-load 'yasnippet
    (let ((inhibit-message t))
      (yas-reload-all))))
#+end_src
* Programming
** Tools
*** Pair
**** elec-pair
#+begin_src elisp
(setup elec-pair
  (:with-hook prog-mode-hook
    (:hook electric-pair-local-mode))
  (:option electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit))
#+end_src
**** paren
#+begin_src elisp
(setup paren
  (:option show-paren-when-point-in-periphery t
           show-paren-context-when-offscreen 'overlay
           show-paren-when-point-inside-paren t
           show-paren-context-when-offscreen t))
#+end_src
*** Smerge
#+begin_src elisp
(setup smerge-mode
  (:with-hook find-file-hook
    (:hook (lambda ()
             (save-excursion
               (goto-char (point-min))
               (when (re-search-forward "^<<<<<<< " nil t)
                 (smerge-mode 1))))))
  (with-eval-after-load 'smerge-mode
    (:bind
     "C-c r" smerge-refine
     "C-c c" smerge-keep-current
     "C-c a" smerge-keep-all
     "C-c n" smerge-next
     "C-c p" smerge-prev
     "C-c l" smerge-keep-lower
     "C-c u" smerge-keep-upper)))
#+end_src
*** Eldoc
#+begin_src elisp
(setup eldoc
  (:option eldoc-idle-delay 1))
#+end_src
*** Newcomment
#+begin_src elisp
(setup newcomment
  (:option comment-auto-fill-only-comments t))
#+end_src
*** TODO Hideshow
- Seems have error message.
- And to context-menu-mode.
#+begin_src elisp
(setup hideshow
  (:with-hook prog-mode-hook
    (:hook hs-minor-mode))
  ;; FIXME
  (defconst hideshow-folded-face '((t (:inherit 'font-lock-comment-face :box t))))

  (defface hideshow-border-face
    '((((background light))
       :background "rosy brown" :extend t)
      (t
       :background "sandy brown" :extend t))
    "Face used for hideshow fringe."
    :group 'hideshow)

  (define-fringe-bitmap 'hideshow-folded-fringe
    (vector #b00000000
            #b00000000
            #b00000000
            #b11000011
            #b11100111
            #b01111110
            #b00111100
            #b00011000))

  (defun hideshow-folded-overlay-fn (ov)
    "Display a folded region indicator with the number of folded lines."
    (when (eq 'code (overlay-get ov 'hs))
      (let* ((nlines (count-lines (overlay-start ov) (overlay-end ov)))
             (info (format " (%d)..." nlines)))
        ;; fringe indicator
        (overlay-put ov 'before-string (propertize " "
                                                   'display '(left-fringe hideshow-folded-fringe
                                                                          hideshow-border-face)))
        ;; folding indicator
        (overlay-put ov 'display (propertize info 'face hideshow-folded-face)))))

  (setq hs-set-up-overlay #'hideshow-folded-overlay-fn))
#+end_src
*** Devdocs
#+begin_src elisp
(setup (:package devdocs))
#+end_src

*** Imenu List
#+begin_src emacs-lisp
(setup (:package imenu-list)
  (defun +imenu-scale-font-size ()
    (face-remap-add-relative 'default :height 0.8))
  (:option imenu-list-auto-resize t
           imenu-list-mode-line-format nil)
  (:with-hook imenu-list-major-mode-hook
    (:hook (lambda ()
             (setq-local header-line-format nil)))
    (:hook +imenu-scale-font-size)))
#+end_src
*** Puni
#+begin_src emacs-lisp
(setup (:package puni)
  ;; (:with-hook (emacs-lisp-mode-hook scheme-mode-hook clojure-mode-hook)
  ;;   (:hook puni-mode))
  ;; (:bind
  ;;  "M-r" 'puni-splice
  ;;  "C-(" 'puni-slurp-backward
  ;;  "C-)" 'puni-slurp-forward
  ;;  "C-{" 'puni-barf-backward
  ;;  "C-}" 'puni-barf-forward)
  )
#+end_src
*** Dumb Jump
#+begin_src elisp
(setup (:package dumb-jump)
  (:option dumb-jump-force-searcher'rg
           dumb-jump-quiet t
           dumb-jump-aggressive t
           dumb-jump-selector 'completing-read)
  ;; NOTE use `dumb-jump' as default xref backend
  ;; you can run `eglot' or `eat/citre-enable' to reset this
  (:with-hook xref-backend-functions
    (:hook dumb-jump-xref-activate)))
#+end_src
*** Apheleia
#+begin_src elisp
(setup (:package apheleia)
  (:hook-into go-mode)
  (:option apheleia-remote-algorithm 'local)
  (with-eval-after-load 'apheleia
    (setf (alist-get 'gofmt apheleia-formatters)
          '("goimports"))))
#+end_src
*** Clue
#+begin_src emacs-lisp
(unless (package-installed-p 'clue)
  (package-vc-install "https://github.com/AmaiKinono/clue"))

#+end_src
*** Flymake
#+begin_src elisp
(setup flymake
  (:hook-into prog-mode)
  (:option flymake-diagnostic-functions nil
           flymake-no-changes-timeout 0.2)

  (defvar sekiro-flymake-mode-line-format `(:eval (sekiro-flymake-mode-line-format)))
  (put 'sekiro-flymake-mode-line-format 'risky-local-variable t)
  (defun sekiro-flymake-mode-line-format ()
    (let* ((counter (string-to-number
                     (nth 1
                          (cadr
                           (flymake--mode-line-counter :error t)))))
           (sekiro-flymake (when (> counter 0)
                             'compilation-error)))
      (propertize
       "危"
       'face
       sekiro-flymake)))

  (with-eval-after-load 'flymake
    (add-to-list 'mode-line-misc-info
                 `(flymake-mode (" [" sekiro-flymake-mode-line-format "] ")))))
#+end_src
** Lsp
*** eglot
#+begin_src elisp
(setup (:package eglot eldoc-box)
  (:option eglot-events-buffer-size 0
           eglot-sync-connect nil       ;; don't block of LSP connection attempts
           eglot-extend-to-xref t       ;; make eglot manage file out of project by `xref-find-definitions'
           eglot-ignored-server-capabilites '(:documentHighlightProvider :documentFormattingProvider :documentRangeFormattingProvider))
  (setq-default eglot-workspace-configuration
                '((gopls
                   (usePlaceholders . t))))
  (:bind "M-RET" eglot-code-actions
         "C-c r" eglot-rename
         "M-'" eglot-find-implementation)
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(python-mode . ("pyright-langserver" "--stdio")))
    (add-to-list 'eglot-server-programs
			     '(rust-mode "rust-analyzer"))
    ;; NOTE deno
    (defclass eglot-deno (eglot-lsp-server) ()
      :documentation "A custom class for deno lsp.")
    (cl-defmethod eglot-initialization-options ((server eglot-deno))
      "Passes through required deno initialization options"
      (list :enable t
            :lint t))
    (add-to-list 'eglot-server-programs '((js-mode typescript-mode) . (eglot-deno "deno" "lsp")))
    ;; TODO code actions
    (add-to-list 'eglot-server-programs
                 '(sql-mode . ("sqls" "-config" "~/.config/sqls/config.yaml"))))
  (:with-hook eglot-managed-mode-hook
    (:hook eldoc-box-hover-mode)))
#+end_src
*** lsp-bridge                                                       :deps:
Need a lot...

#+begin_src elisp
(defun add-subdirs-to-load-path (search-dir)
  (interactive)
  (let* ((dir (file-name-as-directory search-dir)))
    (dolist (subdir
             ;; 过滤出不必要的目录，提升 Emacs 启动速度
             (cl-remove-if
              #'(lambda (subdir)
                  (or
                   ;; 不是目录的文件都移除
                   (not (file-directory-p (concat dir subdir)))
                   ;; 父目录、 语言相关和版本控制目录都移除
                   (member subdir '("." ".."
                                    "dist" "node_modules" "__pycache__"
                                    "RCS" "CVS" "rcs" "cvs" ".git" ".github"))))
              (directory-files dir)))
      (let ((subdir-path (concat dir (file-name-as-directory subdir))))
        ;; 目录下有 .el .so .dll 文件的路径才添加到 `load-path' 中，提升 Emacs 启动速度
        (when (cl-some #'(lambda (subdir-file)
                           (and (file-regular-p (concat subdir-path subdir-file))
                                ;; .so .dll 文件指非 Elisp 语言编写的 Emacs 动态库
                                (member (file-name-extension subdir-file) '("el" "so" "dll"))))
                       (directory-files subdir-path))

          ;; 注意：`add-to-list' 函数的第三个参数必须为 t ，表示加到列表末尾
          ;; 这样 Emacs 会从父目录到子目录的顺序搜索 Elisp 插件，顺序反过来会导致 Emacs 无法正常启动
          (add-to-list 'load-path subdir-path t))

        ;; 继续递归搜索子目录
        (add-subdirs-to-load-path subdir-path)))))

;; this need pip install epc, orjson
(unless (package-installed-p 'lsp-bridge)
  (package-vc-install "https://github.com/manateelazycat/lsp-bridge"))
(setup lsp-bridge
  (:autoload lsp-bridge-mode global-lsp-bridge-mode)
  (:option acm-enable-doc nil
           acm-enable-search-words nil
           lsp-bridge-enable-search-words nil)
  (defun eat/lsp-bridge-mode-setup ()
    "My setup for lsp-bridge.
Disable `corfu-mode'.
When expand snippet, try complete if there's acm cond, or run `yas-next-field-or-maybe-expand'."
    (interactive)
    (ignore-errors
      (corfu-mode -1))
    (with-eval-after-load 'yasnippet
      ;; FIXME
      (define-key yas-keymap (kbd "<tab>") 'acm-complete-or-expand-yas-snippet)
      (define-key yas-keymap (kbd "TAB") 'acm-complete-or-expand-yas-snippet)))
  (with-eval-after-load 'lsp-bridge
    (add-subdirs-to-load-path (expand-file-name "elpa/lsp-bridge" user-emacs-directory))
    (:hook eat/lsp-bridge-mode-setup)
    ;; keybindings
    (:with-map lsp-bridge-mode-map
      (:bind "M-." lsp-bridge-find-def
             "C-x 4 ." lsp-bridge-find-def-other-window
             "M-," lsp-bridge-return-from-def
             "M-?" lsp-bridge-find-references
             "M-'" lsp-bridge-find-impl
             "C-c r" lsp-bridge-rename
             "C-c <" lsp-bridge-diagnostic-jump-prev
             "C-c >" lsp-bridge-diagnostic-jump-next))
    (:with-map lsp-bridge-ref-mode-map
      ;; FIXME p will say search failed " ", it should act like n, reach last file
      (:bind "j" nil
             "k" nil
             "h" nil
             "l" nil
             "p" lsp-bridge-ref-jump-prev-file
             "h" lsp-bridge-ref-jump-prev-keyword
             "t" lsp-bridge-ref-jump-next-keyword
             "n" lsp-bridge-ref-jump-next-file))))
#+end_src
*** Restart lsp client
#+begin_src elisp
(defun eat/lsp-reconnect ()
  (interactive)
  (if (bound-and-true-p lsp-bridge-mode)
      (lsp-bridge-restart-process)
    (eglot-reconnect)))
(global-set-key [f10] #'eat/lsp-reconnect)
#+end_src
** Citre
#+begin_src elisp
(setup citre
  (:needs "ctags")
  (:package citre)
  (:option citre-default-create-tags-file-location 'global-cache
           citre-use-project-root-when-creating-tags t
           citre-prompt-language-for-ctags-command t
           citre-auto-enable-citre-mode-modes '(prog-mode))
  (:global "C-x c j" citre-jump
           "C-x c J" citre-jump-back
           "C-x c u" citre-update-this-tags-file
           "C-x c p" citre-peek
           ;; NOTE
           ;; Notice that GTAGSOBJDIRPREFIX must exist for gtags to use it. So you need to run:
           ;; $ mkdir -p ~/.cache/gtags/
           "C-x c U" citre-global-update-database
           "C-x c r" citre-jump-to-reference
           "C-x c P" citre-ace-peek-references
           )
  (with-eval-after-load 'citre
    (with-eval-after-load 'cc-mode (require 'citre-lang-c))
    (with-eval-after-load 'dired (require 'citre-lang-fileref))
    (with-eval-after-load 'verilog-mode (require 'citre-lang-verilog)))
  (with-eval-after-load 'citre-global
    (setenv "GTAGSOBJDIRPREFIX" (concat (getenv "HOME") "/.cache/gtags"))
    (setenv "GTAGSCONF" (concat (getenv "HOME") "/.globalrc"))
    (setenv "GTAGSLABEL" "native-pygments"))
  (with-eval-after-load 'citre-peek
    (define-key citre-peek-keymap (kbd "M-l r")
      'citre-peek-through-references))

  (defun eat/citre-enable ()
    (interactive)
    (citre-mode 1)
    (add-hook 'find-file-hook #'citre-auto-enable-citre-mode))
  (defun eat/citre-disable ()
    (interactive)
    (citre-mode 0)
    (remove-hook 'find-file-hook #'citre-auto-enable-citre-mode)))
#+end_src
** Lang
*** Lisp
#+begin_src elisp
(setup (:package aggressive-indent paredit)
  (:with-hook (emacs-lisp-mode-hook
               lisp-interaction-mode-hook
               scheme-mode-hook
               lisp-mode-hook)
    (:hook aggressive-indent-mode)
    (:hook paredit-mode)))
#+end_src
*** Go
#+begin_src emacs-lisp
(setup go-mode
  (:needs "go")
  (:package go-mode flymake-go-staticcheck go-gen-test gotest go-tag go-dlv go-fill-struct go-impl)
  ;; Go-mode
  ;; Install or update tools
  (defvar go--tools '("golang.org/x/tools/gopls"
                      "golang.org/x/tools/cmd/goimports"
                      "honnef.co/go/tools/cmd/staticcheck"
                      "github.com/go-delve/delve/cmd/dlv"
                      "github.com/zmb3/gogetdoc"
                      "github.com/josharian/impl"
                      "github.com/cweill/gotests/..."
                      "github.com/fatih/gomodifytags"
                      "github.com/davidrjenni/reftools/cmd/fillstruct"
                      "github.com/rogpeppe/godef")
    "All necessary go tools.")

  (defun go-update-tools ()
    "Install or update go tools."
    (interactive)
    (unless (executable-find "go")
      (user-error "Unable to find `go' in `exec-path'!"))

    (message "Installing go tools...")
    (dolist (pkg go--tools)
      (set-process-sentinel
       (start-process "go-tools" "*Go Tools*" "go" "install" "-v" "-x" (concat pkg "@latest"))
       (lambda (proc _)
         (let ((status (process-exit-status proc)))
           (if (= 0 status)
               (message "Installed %s" pkg)
             (message "Failed to install %s: %d" pkg status)))))))
  (:option gofmt-command "goimports"
           gofmt-show-errors nil)
  (:with-hook go-test-mode-hook
    (:hook visual-line-mode))
  ;; Flymake-go-staticcheck
  (defun eat/flymake-go-staticcheck-enable ()
    "Enable flymake-go-staticcheck for all go buffer.
Call `flymake-go-staticcheck-enable' interactive will only
enable this in current buffer, add to `go-mode-hook' to make
it enable on all go buffer."
    (interactive)
    (flymake-go-staticcheck-enable)
    (add-hook 'go-mode-hook #'flymake-go-staticcheck-enable))
  (defun eat/flymake-go-staticcheck-disable ()
    (interactive)
    (flymake-go-staticcheck-disable)
    (add-hook 'go-mode-hook #'flymake-go-staticcheck-disable))
  ;; Go-test
  (:option go-test-verbose t
           ;; Do not cache test result.
           go-test-args "-count=1")
  ;; Go-tag
  (:option go-tag-args (list "-transform" "camelcase"))
  ;; Bind
  (:with-map go-mode-map
    (:bind
     "C-c t g" go-gen-test-dwim
     "C-c t t" go-test-current-test
     "C-c t a" go-tag-add
     "C-c t r" go-tag-remove)))
#+end_src
*** Nix
#+begin_src emacs-lisp
(setup nix-mode
  (:needs "nix")
  (:package nix-mode))
#+end_src

*** Clojure
#+begin_src elisp
(setup clojure-mode
  (:needs "clojure")
  (:package clojure-mode cider))
#+end_src
*** Lua
#+begin_src elisp
(setup lua-mode
  (:needs "lua")
  (:package lua-mode))
#+end_src
*** Rust
#+begin_src elisp
(setup rust-mode
  (:needs "rustc")
  (:package rust-mode))
#+end_src
*** Typescript
#+begin_src elisp
(setup typescript-mode
  (:needs "tsc")
  (:package typescript-mode)
  (:option typescript-indent-level 2))
#+end_src
*** C
#+begin_src elisp
(setq c-default-style "linux"
      c-basic-offset 4)
#+end_src
*** Python
#+begin_src elisp
(setq python-indent-offset 4
      python-shell-completion-native-enable nil
      python-shell-interpreter "ipython"
      python-indent-guess-indent-offset nil)
#+end_src
*** Sql
#+begin_src elisp
(setq sql-mysql-login-params '(user password server database port))
#+end_src
* Tools
** Visual Fill Column
Center current window.
#+begin_src emacs-lisp
(setup (:package visual-fill-column)
  (:with-hook visual-fill-column-mode-hook
    (:hook visual-line-mode))
  (:option visual-fill-column-center-text t))
#+end_src
** Rg
#+begin_src elisp
(setup (:needs "rg")
  (:package rg))
#+end_src
** Translate
#+begin_src elisp
(setup (:package go-translate)
  (:option
   gts-translate-list '(("en" "zh")))
  (:global
   "C-c y" gts-do-translate)
  (with-eval-after-load 'go-translate
    (:option
     gts-default-translator (gts-translator
                             :picker (gts-noprompt-picker)
                             :engines (list (gts-bing-engine) (gts-google-rpc-engine))
                             :render (gts-buffer-render)))))
#+end_src
** Ghelp
#+begin_src elisp
(unless (package-installed-p 'ghelp)
  (package-vc-install "https://github.com/casouri/ghelp.git"))
(setup ghelp
  (:autoload
   ghelp-describe
   ghelp-describe-function
   ghelp-describe-variable
   ghelp-describe-key
   ghelp-describe-elisp)
  (global-set-key (kbd "C-h C-h") #'ghelp-describe)
  (global-set-key (kbd "C-h f") #'ghelp-describe-function)
  (global-set-key (kbd "C-h v") #'ghelp-describe-variable)
  (global-set-key (kbd "C-h k") #'ghelp-describe-key)
  (global-set-key (kbd "C-h o") #'ghelp-describe-elisp)
  (with-eval-after-load 'ghelp
    (global-set-key (kbd "C-h r") #'ghelp-resume)))
#+end_src

** Restclient
#+begin_src emacs-lisp
(setup restclient
  (:needs "curl")
  (:package restclient)
  (defun eat/restclient ()
    "Work with `rest' in the *restclient* buffer."
    (interactive)
    (with-current-buffer (get-buffer-create "*restclient*")
      (restclient-mode)
      (pop-to-buffer (current-buffer)))))
#+end_src
* Org
** config
#+begin_src elisp
(defun eat/org-hook ()
  "Configuration for Org Mode."
  (org-indent-mode)
  (electric-pair-local-mode -1)
  (electric-quote-local-mode)
  (electric-indent-local-mode -1))

(defun eat/insert-zero-width-space ()
  (interactive)
  (insert-char ?\u200B)) ;; code for ZERO WIDTH SPACE
(global-set-key (kbd "C-x 8 0") #'eat/insert-zero-width-space)

(setup org
  (:hook eat/org-hook)
  (setq org-directory (expand-file-name "~/Dropbox/org"))
  (defvar load-language-list '((emacs-lisp . t)
                               (python . t)
                               (js . t)
                               (C . t)
                               (shell . t)))
  (with-eval-after-load 'org
    (setq org-edit-src-content-indentation 0
          org-special-ctrl-a/e t
          org-special-ctrl-k t
          ;; comment after emacs merge noverly branch
          ;; org-src-fontify-natively nil ;; see it in `org-edit-special'
          org-src-window-setup 'current-window
          org-return-follows-link t
          org-confirm-babel-evaluate nil
          org-image-actual-width '(300)
          org-ellipsis " ▾ "
          ;; Faster loading
          org-modules nil
          org-log-done t)
    (require 'org-tempo) ;; see `org-structure-template-alist'
    (require 'ob)
    (require 'ob-dot)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (org-babel-do-load-languages 'org-babel-load-languages load-language-list)))
#+end_src
** ox
*** gfm
#+begin_src elisp
(setup (:package ox-gfm)
  (with-eval-after-load 'ox-gfm
    (add-to-list 'org-export-backends 'md)))
#+end_src

** ob
*** restclient
#+begin_src elisp
(setup ob-restclient
  (:needs "curl")
  (:package ob-restclient)
  (cl-pushnew '(restclient . t) load-language-list)
  (with-eval-after-load 'ob-restclient
    (add-to-list 'org-structure-template-alist '("rc" . "src restclient"))))
#+end_src

*** go
#+begin_src elisp
(setup ob-go
  (:needs "go")
  (:package ob-go)
  (cl-pushnew '(go .t) load-language-list)
  (with-eval-after-load 'ob-go
    (add-to-list 'org-structure-template-alist '("go" . "src go"))))
#+end_src

** copture
#+begin_src elisp
(setup org-capture
  (global-set-key (kbd "C-c c") 'org-capture)

  (defun eat/org-capture-inbox ()
    (interactive)
    (org-capture nil "i"))
  (global-set-key (kbd "C-c i") #'eat/org-capture-inbox)

  (setq
   org-default-notes-file (concat org-directory "/default-notes.org")
   org-capture-templates
   `(("i" "Inbox" entry (file "~/Dropbox/org/inbox.org")
      "* TODO %?\n:PROPERITIES:\n:Created: %T\n:END:")
     ("w" "Work" entry (file+olp+datetree "~/Dropbox/org/Work.org")
      "* %^{Title}\n:PROPERITIES:\n:Created: %T\n:END:" :tree-type week)
     ("n" "Note" entry (file "~/Dropbox/org/Notes.org")
      "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t))))
#+end_src

** agenda
#+begin_src elisp
(setup org-agenda
  (setq org-agenda-files (list org-directory)
        org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t% s")
                                   (todo   . " ")
                                   (tags   . " %i %-12:c")
                                   (search . " %i %-12:c"))
        ;; hide any tag
        org-agenda-hide-tags-regexp ".")
  (global-set-key (kbd "C-c a") 'org-agenda)
  (setq org-agenda-current-time-string
        "⭠ now ─────────────────────────────────────────────────"))
#+end_src

** org-appear
#+begin_src elisp
(setup (:package org-appear)
  (:hook-into org-mode)
  (setq org-hide-emphasis-markers t))
#+end_src

** valign
#+begin_src elisp
(setup (:package valign)
  (setq valign-fancy-bar t)
  (when (display-graphic-p)
    (add-hook 'org-mode-hook #'valign-mode)))
#+end_src
** toc
#+begin_src elisp
(setup (:package toc-org))
#+end_src
** Export to html
*** TODO Inline image
For now use ~pandoc --embed-resources --standalone~.

#+begin_src emacs-lisp
(defun eat/org-export-to-html ()
  "Convert current org buffer to html with image embed.
Need pandoc installed."
  (interactive)
  (let* ((from (buffer-file-name))
         (to (concat (file-name-sans-extension from) ".html")))
    (shell-command (format "pandoc --embed-resources --standalone %s -o %s" from to))
    (find-file to)))
#+end_src
*** Syntax highlighting
#+begin_src emacs-lisp
(setup (:package htmlize))
#+end_src

** org-variable-pitch
#+begin_src emacs-lisp
(setup (:package org-variable-pitch))
#+end_src
** prose-mode for writting
#+begin_src elisp
(defvar eat/prose-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-a") #'beginning-of-visual-line)
    (define-key map (kbd "C-e") #'end-of-visual-line)
    map)
  "Mode map for ‘eat/prose-mode’.")

(define-minor-mode eat/prose-mode
  "A mode that optimizes for prose editing."
  :lighter " PROSE"
  :keymap eat/prose-mode-map
  (if eat/prose-mode
      (progn
        (org-variable-pitch-minor-mode 1)
        (visual-fill-column-mode 1)
        (setq-local cursor-type 'bar)
        (setq-local line-spacing 0.15)
        (corfu-mode -1)
        (setq-local whitespace-style '(tab-mark))
        (whitespace-mode))
    (org-variable-pitch-minor-mode -1)
    (visual-fill-column-mode -1)
    (whitespace-mode -1)
    (variable-pitch-mode -1)
    (kill-local-variable 'line-spacing)
    (kill-local-variable 'cursor-type)))
#+end_src
** org-download                                                       :deps:
#+begin_src emacs-lisp
(setup (:package org-download)
  ;; :commands
  ;; org-download-dnd
  ;; org-download-yank
  ;; org-download-screenshot
  ;; org-download-clipboard
  ;; org-download-dnd-base64
  :init
  ;; NOTE from doomemacs
  (defmacro pushnew! (place &rest values)
    "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
    (let ((var (make-symbol "result")))
      `(dolist (,var (list ,@values) (with-no-warnings ,place))
         (cl-pushnew ,var ,place :test #'equal))))

  ;; HACK We add these manually so that org-download is truly lazy-loaded
  (pushnew! dnd-protocol-alist
            '("^\\(?:https?\\|ftp\\|file\\|nfs\\):" . org-download-dnd)
            '("^data:" . org-download-dnd-base64))
  (advice-add #'org-download-enable :override #'ignore)

  (setq org-download-image-dir "img"
        org-download-image-org-width 800))
#+end_src
** org-present
#+begin_src emacs-lisp
(setup (:package org-present)
  (:with-hook org-present-mode-hook
    (:hook (lambda ()
             (eat/prose-mode -1)
             ;; full frame
             (toggle-frame-fullscreen)
             ;; display header line so that we can use face-remapping
             ;; to create big enought blank space at the top
             (setq-local header-line-format " ")
             ;; incraease font size
             (setq-local
              face-remapping-alist
              '((default (:height 1.5) variable-pitch)
                (header-line (:height 4.0) variable-pitch)
                (org-document-title (:height 1.75) org-document-title)
                (org-code (:height 1.55) org-code)
                (org-verbatim (:height 0.7) org-verbatim)
                (org-block (:height 1.25) org-block)
                (org-block-begin-line (:height 0.7) org-block)))
             ;; from org-present, after font rescale
             (org-present-read-only)
             (org-present-hide-cursor)
             (org-display-inline-images)
             ;; center the screen
             (visual-fill-column-mode 1)
             (setq-local visual-fill-column-center-text t)
             (setq-local visual-fill-column-width 90)
             ;; hide mode line
             (hide-mode-line-mode 1)
             ;;
             (org-variable-pitch-minor-mode 1))))
  (:with-hook org-present-mode-quit-hook
    (:hook (lambda ()
             (toggle-frame-fullscreen)
             (hide-mode-line-mode -1)
             (kill-local-variable 'face-remapping-alist)
             (kill-local-variable 'header-line-format)
             (eat/prose-mode 1)
             ;; from org-present
             (org-present-show-cursor)
             (org-remove-inline-images)
             (org-present-read-write))))

  (defun my/org-present-prepare-slide (buffer-name heading)
    ;; Show only top-level hedlines.
    (org-overview)
    ;; Unfold the current entry.
    (org-fold-show-entry)
    ;; Show only direct subheadings of the slide but don't expand them.
    (org-fold-show-children))
  (add-hook 'org-present-after-navigate-functions #'my/org-present-prepare-slide))
#+end_src
* Application
** Magit
*** config
#+begin_src emacs-lisp
(setup magit
  (:needs "git")
  (:package magit)
  (:with-hook git-commit-setup-hook
    (:hook git-commit-turn-on-flyspell))
  (:with-hook magit-diff-visit-file
    (:hook my-recenter-and-pulse-line))
  (defun eat/magit-yadm ()
    (interactive)
    (magit-status "/yadm::"))
  (with-eval-after-load 'magit)
  (fullframe magit-status magit-mode-quit-window)
  (setq-default magit-diff-refine-hunk t))
#+end_src

*** magit-delta
#+begin_src emacs-lisp
(setup magit-delta
  (:needs "delta")
  (:package magit-delta)
  (:hook-into magit-mode-hook))
#+end_src

*** diff-hl
#+begin_src emacs-lisp
(setup diff-hl
  (:needs "diff")
  (:package diff-hl)
  (:with-hook (prog-mode-hook conf-mode-hook)
    (:hook diff-hl-mode))
  (:with-hook dired-mode-hook
    (:hook diff-hl-dired-mode))
  (:option diff-hl-draw-borders nil)
  (with-eval-after-load 'diff-hl
    (:with-hook magit-pre-refresh-hook
      (:hook diff-hl-magit-pre-refresh))
    (:with-hook magit-post-refresh-hook
      (:hook diff-hl-magit-post-refresh))
    ;; Highlight on-the-fly
    (diff-hl-flydiff-mode 1)
    (unless (display-graphic-p)
      ;; Fall back to the display margin since the fringe is unavailable in tty
      (diff-hl-margin-mode 1)
      ;; Avoid restoring `diff-hl-margin-mode'
      (with-eval-after-load 'desktop
        (add-to-list 'desktop-minor-mode-table
                     '(diff-hl-margin-mode nil))))))
#+end_src
** File Manager (dirvish)
#+begin_src elisp
(setup dired
  (:hook dired-hide-details-mode)
  (when eat/macp
    (setq insert-directory-program "gls"))
  (:option dired-dwim-target t
           dired-kill-when-opening-new-dired-buffer t
           dired-listing-switches
           "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group")
  (with-eval-after-load 'dired
    (:option dired-recursive-deletes 'top)
    (:bind
     "h" dired-up-directory
     [mouse-2] dired-find-file
     "C-c C-p" wdired-change-to-wdired-mode)))

(setup (:package dirvish)
  (:with-hook after-init-hook
    (:hook dirvish-override-dired-mode))
  (:option dirvish-attributes '(vc-state subtree-state))
  (when (eat/modulep '+icon)
    (add-to-list 'dirvish-attributes 'all-the-icons))
  (:global "<f1>" dirvish-side
           "C-c f" dirvish-fd)
  (with-eval-after-load 'dirvish
    (dirvish-side-follow-mode)
    (:bind
     "TAB" dirvish-subtree-toggle
     "<tab>" dirvish-subtree-toggle
     "a" dirvish-quick-access
     "f" dirvish-file-info-menu
     "y" dirvish-yank-menu
     "N" dirvish-narrow
     "H" dirvish-history-jump
     "s" dirvish-quicksort
     "v" dirvish-vc-menu
     "M-f" dirvish-history-go-forward
     "M-b" dirvish-history-go-backward
     "M-l" dirvish-ls-switches-menu
     "M-m" dirvish-mark-menu
     "M-t" dirvish-layout-toggle
     "M-s" dirvish-setup-menu
     "M-e" dirvish-emerge-menu
     "M-j" dirvish-fd-jump
     "<mouse-1>" dirvish-subtree-toggle-or-open
     "<mouse-2>" dired-mouse-find-file-other-window
     "<mouse-3>" dired-mouse-find-file)))
#+end_src
** TODO Terminal
#+begin_src elisp
(setup eshell
  (:global "C-`" eshell))

;; Quick editing in `describe-variable'
(with-eval-after-load 'help-fns
  (put 'help-fns-edit-variable 'disabled nil))
#+end_src
* Module
** Benchmark
#+begin_src elisp
(setup (:only-if (eat/modulep '+benchmark))
  (:package benchmark-init)
  (benchmark-init/activate)
  (with-eval-after-load 'benchmark-init
    (add-hook 'after-init-hook 'benchmark-init/deactivate)))
 #+end_src

** Icon
#+begin_src elisp
(setup (:only-if (eat/modulep '+icon))
  (:package all-the-icons all-the-icons-ibuffer all-the-icons-completion)
  (:with-hook ibuffer-mode-hook
    (:hook all-the-icons-ibuffer-mode))
  (:with-hook after-init-hook
    (:hook (lambda ()
             (all-the-icons-completion-mode))))
  (with-eval-after-load 'all-the-icons-completion
    (with-eval-after-load 'marginalia
      (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))))
#+end_src
** Telega
Need =telegram-tdlib=.
Run =docker pull zevlg/telega-server:latest=

#+begin_src elisp
(setup (:only-if (eat/modulep '+telega))
  (:package telega company)
  (:with-hook telega-load-hook
    (:hook(telega-notifications-mode telega-appindicator-mode)))
  (:option telega-use-docker t
           telega-chat-fill-column 75
           telega-server-libs-prefix "/usr")

  (defun eat/telega-root-setup ()
    ;; (eat/fixed-pitch-setup) ;; FIXME
    (hl-line-mode 1))
  (add-hook 'telega-root-mode-hook 'eat/telega-root-setup)

  ;; Use capf to complete in telega chat buffer.
  (defun my-telega-chat-mode ()
    (require 'company)
    (add-hook 'completion-at-point-functions
              #'telega-chatbuf-complete-at-point nil 'local))

  (defun eat/telega-chat-setup ()
    (my-telega-chat-mode)
    ;; (make-variable-buffer-local 'face-font-rescale-alist)
    ;; (add-to-list 'face-font-rescale-alist `(,eat/font-chinese . 0.9))
    ;; (add-to-list 'face-font-rescale-alist `(,eat/font-emoji . 0.8))
    (require 'yasnippet)
    (yas-minor-mode-on)
    (visual-line-mode)
    (hl-line-mode))
  (add-hook 'telega-chat-mode-hook #'eat/telega-chat-setup)

  (defun lg-telega-chat-update (chat)
    (with-telega-root-buffer
      (hl-line-highlight)))
  (add-hook 'telega-chat-update-hook 'lg-telega-chat-update)

  (with-eval-after-load 'telega
    ;; ignore blocked user
    (add-hook 'telega-msg-ignore-predicates
              (telega-match-gen-predicate "msg-" '(sender blocked)))

    (setq telega-chat-input-format "›"
          telega-animation-play-inline nil
          telega-video-play-inline nil
          ;; make sticker larger to read
          telega-sticker-size '(10 . 24)
          ;; change reply symbol
          telega-symbol-reply "↫"
          ;; set date format for old messages
          telega-old-date-format "%Y/%M/%D")

    ;; syntax highlighting in telega code
    (require 'telega-mnz)
    (global-telega-mnz-mode 1)))
#+end_src

** Blog (org-static-blog)
#+begin_src elisp
(setup (:only-if (eat/modulep '+blog))
  (:package org-static-blog)
  (:option org-static-blog-publish-title "404cn's blog"
           org-static-blog-publish-url "https://404cn.github.io/"
           org-static-blog-publish-directory "~/p/blog/"
           org-static-blog-posts-directory "~/p/blog/posts/"
           org-static-blog-drafts-directory "~/p/blog/drafts/"
           org-static-blog-enable-tags t
           org-static-blog-use-preview t
           org-static-blog-preview-ellipsis ""
           org-export-with-toc nil
           org-export-with-section-numbers nil)
  (with-eval-after-load 'org-static-blog
    (:option org-static-blog-page-header (get-string-from-file "~/p/blog/static/header.html")
             org-static-blog-page-preamble (get-string-from-file "~/p/blog/static/preamble.html")
             org-static-blog-page-postamble (get-string-from-file "~/p/blog/static/postamble.html"))))
#+end_src

** Mail (notmuch)
#+begin_src elisp
(setup (:and (:needs "notmuch") (:only-if (eat/modulp +mail)))
  (:package notmuch)
  (defun eat/async-notmuch-poll ()
    (interactive)
    (message "Start polling email...")
    (async-start
     `(lambda ()
        ,(async-inject-variables "\\`load-path\\'")
        (require 'notmuch)
        (notmuch-poll))
     (lambda (result)
       (message "eat/async-notmuch-poll: %s" result))))
  (defvar +notmuch-delete-tags '("+trash" "-inbox" "-unread")
    "Tags applied to mark email for deletion.

When replacing the +trash tag by a different tag such as
+deleted, you will need to update the notmuch-saved-searches
variable accordingly.")

  (defvar +notmuch-spam-tags '("+spam" "-inbox" "-unread")
    "Tags applied to mark email as spam.")

  (defun +notmuch/search-delete ()
    (interactive)
    (notmuch-search-add-tag +notmuch-delete-tags)
    (notmuch-tree-next-message))

  (defun +notmuch/tree-delete ()
    (interactive)
    (notmuch-tree-add-tag +notmuch-delete-tags)
    (notmuch-tree-next-message))

  (defun +notmuch/show-delete ()
    "Mark email for deletion in notmuch-show"
    (interactive)
    (notmuch-show-add-tag +notmuch-delete-tags)
    (notmuch-show-next-thread-show))

  (defun +notmuch/search-spam ()
    (interactive)
    (notmuch-search-add-tag +notmuch-spam-tags)
    (notmuch-search-next-thread))

  (defun +notmuch/tree-spam ()
    (interactive)
    (notmuch-tree-add-tag +notmuch-spam-tags)
    (notmuch-tree-next-message))
  (:option
   notmuch-search-oldest-first nil
   notmuch-fcc-dirs nil
   notmuch-search-result-format '(("date" . "%12s ")
                                  ("count" . "%-7s ")
                                  ("authors" . "%-30s ")
                                  ("subject" . "%-72s ")
                                  ("tags" . "(%s)")))
  (with-eval-after-load 'notmuch
    (:global [remap notmuch-poll-and-refresh-this-buffer] #'eat/async-notmuch-poll)
    (:with-mode notmuch-search-mode
      (:hook eat/fixed-pitch-setup))))

(setup message
  (:with-hook message-mode-hook
    (:hook (lambda ()
             (setq-local fill-column 72)
             (auto-fill-mode))))
  (setq user-full-name eat/user-full-name
        user-mail-address eat/user-mail-address
        message-kill-buffer-on-exit t
        message-mail-alias-type 'ecomplete
        message-send-mail-function #'message-use-send-mail-function
        message-signature user-full-name))

(setup sendmail
  (setq send-mail-function #'smtpmail-send-it))

(setup smtpmail
  (setq smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-user user-mail-address
        smtpmail-smtp-service 587
        smtpmail-stream-type 'ssl))
#+end_src
** Note Taking (xeft)
Need =xapian-core=.

#+begin_src elisp
(unless (package-installed-p 'xeft)
  (package-vc-install "https://github.com/casouri/xeft.git"))
(setup xeft
  (:only-if (eat/modulep '+note-taking))
  (setq xeft-directory "~/Dropbox/org/roam"
        xeft-database "~/.xeft/db")
  (with-eval-after-load 'xeft
    (require 'flique)
    (defun xeft-setup ()
      (flique-append-to-index (buffer-file-name))
      (local-set-key (kbd "M-]") #'flique-forward)
      (local-set-key (kbd "M-[") #'flique-backward)
      (flique-show-navigation))
    (add-hook 'xeft-find-file-hook #'xeft-setup)
    (add-hook 'xeft-find-file-hook #'bklink-minor-mode)))
#+end_src
** Kubernetes
#+begin_src emacs-lisp
(setup (and (:needs "kubectl") (:only-if (eat/modulep '+kubernetes)))
  (:package kubernetes)
  (with-eval-after-load 'kubernetes
    (:option kubernetes-poll-frequency 3600
             kubernetes-redraw-frequency 3600)))
#+end_src

* Modes
#+begin_src elisp
(setup (:package toml-mode yaml-mode docker-compose-mode dockerfile-mode k8s-mode git-modes terraform-mode markdown-mode markdown-toc protobuf-mode)
  (:with-hook (toml-mode-hook yaml-mode-hook)
    (:hook goto-address-prog-mode))
  (add-to-list 'auto-mode-alist
               (cons "/.dockerignore\\'" 'gitignore-mode))
  (:option markdown-enable-wiki-links t
           markdown-italic-underscore t
           markdown-asymmetric-header t
           markdown-make-gfm-checkboxes-buttons t
           markdown-gfm-uppercase-checkbox t
           markdown-fontify-code-blocks-natively t)
  (with-eval-after-load "protobuf-mode"
    (add-hook 'protobuf-mode-hook
              (lambda ()
                (setq imenu-generic-expression
                      '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2)))))))
#+end_src

* TOOD
* Site Lisp
** Load Path
#+begin_src elisp
(add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
(add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))
#+end_src

** Form Feed
#+begin_src elisp
(setup form-feed
  (:autoload form-feed-mode)
  (:with-hook (emacs-lisp-mode-hook text-mode-hook special-mode-hook)
    (:hook form-feed-mode)))
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/form-feed.el
;;; form-feed.el --- Display ^L glyphs as horizontal lines

;; Copyright (C) 2014 Vasilij Schneidermann <mail@vasilij.de>

;; Author: Vasilij Schneidermann <mail@vasilij.de>
;; Maintainer: Yuan Fu <casouri@gmail.com>
;; URL: https://depp.brause.cc/form-feed
;; Keywords: faces
;; Version: 0.2.3

;; This file is NOT part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING. If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:

;; This minor mode displays page delimiters which usually appear as ^L
;; glyphs on a single line as horizontal lines spanning the entire
;; window.  It is suitable for inclusion into mode hooks and is
;; intended to be used that way.  The following snippet would enable
;; it for Emacs Lisp files for instance:
;;
;;     (add-hook 'emacs-lisp-mode-hook 'form-feed-mode)

;;; Note:
;;
;; Yuan: I removed a bunch of functions and variables and changed
;; font-lock to jit-lock.


;;; Code:


;;; variables

(defgroup form-feed nil
  "Turn ^L glyphs into horizontal lines."
  :prefix "form-feed-"
  :group 'faces)

(defface form-feed-line
  '((((type graphic)
      (background light)) :strike-through "black")
    (((type graphic)
      (background dark)) :strike-through "white")
    (((type tty)) :inherit font-lock-comment-face :underline t))
  "Face for form-feed-mode lines."
  :group 'form-feed)

(defcustom form-feed-line-width t
  "Width of the form feed line.
It may be one of the following values:

t: Full width.

floating point number: Ratio of full width.  A value of 0.5 would
use half the width.

positive integer number: Width as measured in columns.  A value
of 80 would use a 80 characters wide line.

negative integer number: Full width minus specified number of
columns.  A value of -1 would leave the last column empty."
  :type '(choice (const :tag "Full width" t)
                 (float :tag "Ratio")
                 (integer :tag "Columns"))
  :group 'form-feed)

(defvar form-feed--line-width
  (cond
   ((integerp form-feed-line-width)
    (if (>= form-feed-line-width 0)
        form-feed-line-width
      `(- text ,(abs form-feed-line-width))))
   ((floatp form-feed-line-width)
    `(,form-feed-line-width . text))
   (t 'text)))

(defvar form-feed--font-lock-keywords
  ;; NOTE see (info "(elisp) Search-based fontification") and the
  ;; `(MATCHER . SUBEXP-HIGHLIGHTER)' section
  `((,page-delimiter 0 form-feed--font-lock-face t)))

(defcustom form-feed-lighter " ^L"
  "Lighter for `form-feed-mode'."
  :type 'string
  :group 'form-feed
  :risky t)


;;; Functions

(defun form-feed-fontify (beg end)
  "Fonfity page breaks at beginning of line between BEG and END."
  (goto-char beg)
  (while (re-search-forward "^" end t)
    (put-text-property (match-beginning 0) (match-end 0)
                       'font-lock-face 'form-feed-line)
    (put-text-property (match-beginning 0) (match-end 0)
                       'display `(space :width ,form-feed--line-width))))

;;;###autoload
(define-minor-mode form-feed-mode
  "Toggle form-feed-mode.

This minor mode displays page delimiters which usually appear as ^L
glyphs on a single line as horizontal lines spanning the entire
window."
  :lighter form-feed-lighter
  (if form-feed-mode
      (jit-lock-register #'form-feed-fontify)
    (jit-lock-unregister #'form-feed-fontify))
  (jit-lock-refontify))

(provide 'form-feed)
;;; form-feed.el ends here
#+end_src

** Dired Toggle Sudo
#+begin_src elisp
(setup dired-toggle-sudo
  (:autoload dired-toggle-sudo))
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/dired-toggle-sudo.el
;;; dired-toggle-sudo.el --- Browse directory with sudo privileges.

;; Copyright © 2011 Sebastien Gross <seb•ɑƬ•chezwam•ɖɵʈ•org>

;; Author: Sebastien Gross <seb•ɑƬ•chezwam•ɖɵʈ•org>
;; Keywords: emacs, dired
;; Created: 2011-07-06
;; Last changed: 2020-04-01 15:52:40
;; Licence: WTFPL, grab your copy here: http://sam.zoy.org/wtfpl/

;; This file is NOT part of GNU Emacs.

;;; Commentary:
;;
;; Allow to switch from current user to sudo when browsind `dired' buffers.
;;
;; To activate and switch with "C-c C-s" just put in your .emacs:
;;
;; (require 'dired-toggle-sudo)
;; (define-key dired-mode-map (kbd "C-c C-s") 'dired-toggle-sudo)
;; (eval-after-load 'tramp
;;  '(progn
;;     ;; Allow to use: /sudo:user@host:/path/to/file
;;     (add-to-list 'tramp-default-proxies-alist
;;		  '(".*" "\\`.+\\'" "/ssh:%h:"))))



;;; Code:

(require 'files)
(require 'tramp)
(require 'dired)

(defun dired-toggle-sudo-internal (path &optional sudo-user)
  "Convert PATH to its sudoed version. root is used by default
unless SUDO-USER is provided."
  (let* (;; Handle the case of local files. `tramp-dissect-file-name' does
	 ;; not raise an error anymore.
	 (tramp-pseudo-method (if (> emacs-major-version 25)
				  "/-::" "/:"))
	 (path (if (tramp-tramp-file-p path)
		   path
		 (concat tramp-pseudo-method path)))
	 (file-vec (or (ignore-errors (tramp-dissect-file-name
				       path))
		       (tramp-dissect-file-name
			(concat tramp-pseudo-method path) 1)))
	 (method  (tramp-file-name-method file-vec))
	 (user (tramp-file-name-user file-vec))
	 (host  (tramp-file-name-host file-vec))
	 (localname (expand-file-name
		     (tramp-file-name-localname file-vec))))
    ;; (message "(tramp-make-tramp-file-name %s %s %s %s %s %s)"
    ;; 	     method
    ;; 	     (tramp-file-name-domain file-vec)
    ;; 	     user host
    ;; 	     (tramp-file-name-port file-vec)
    ;; 	     localname)
    (when (or (string= system-name host)
	      (string= "-" host))
      (setq host nil))
    (cond
     ;; remote directory -> sudo
     ((and host (string= method "ssh"))
      (setq method "sudo" user sudo-user))
     ;; remote directory -> normal
     ((and host (string= method "sudo"))
      (setq method "ssh" user nil))
     ;; Local directory -> normal
     ((and (not host) (string= method "ssh"))
      (setq method "sudo"))
     ;; Local directory -> sudo
     ((and (not host) (string= method "sudo"))
      (setq method nil user sudo-user))
     ;; Local directory -> normal
     (t
      (setq method "sudo" user sudo-user)))
    ;; (message "%s -> %s" path file-vec)
    ;; (message "(tramp-make-tramp-file-name %s %s %s %s %s %s)"
    ;; 	     method
    ;; 	     (tramp-file-name-domain file-vec)
    ;; 	     user host
    ;; 	     (tramp-file-name-port file-vec)
    ;; 	     localname)
    (replace-regexp-in-string
     "^/:/" "/"
     (if (> emacs-major-version 25)
	 (tramp-make-tramp-file-name method
				     user
				     (tramp-file-name-domain file-vec)
				     host
				     (tramp-file-name-port file-vec)
				     localname)
	 (tramp-make-tramp-file-name method user host localname)))))

(defun dired-toggle-sudo-find (fname)
  "Create a new buffer for file name FNAME."
  (let ((save-point (point)))
    (find-alternate-file fname)
    (goto-char save-point)))

;;;###autoload
(defun dired-toggle-sudo (&optional sudo-user)
  "Reopen current file or dired buffer with sudo.
If SUDO-USER is nil assume root.
If called with `universal-argument' (C-u), ask for username.
"
  (interactive "P")
  (let* ((fname (or buffer-file-name
		    dired-directory))
	 (sudo-user (if current-prefix-arg
			(read-string "Username: ")
		      sudo-user))
	 (orig (current-buffer))
         (file-now (if (eq major-mode 'dired-mode)
                       (dired-get-filename t))))
    (when fname
      (setq fname (dired-toggle-sudo-internal fname sudo-user))
      (if (not (eq major-mode 'dired-mode))
	  (dired-toggle-sudo-find fname)
	(kill-buffer orig)
	(dired fname)
        (when file-now
          (dired-goto-file (expand-file-name file-now fname)))))))

(provide 'dired-toggle-sudo)

;;; dired-toggle-sudo.el ends here
#+end_src

** Color Outline
#+begin_src elisp
(setup color-outline
  (:autoload color-outline-mode)
  (:hook-into prog-mode))
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/color-outline.el
;;; color-outline.el --- Outline w/ color      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; This package is a basic version of outshine.el, it provides a quick
;; and easy way of setting up headline patterns and integration with
;; outline commands, highlighting of headlines and imenu support.
;;
;; Usage:
;;
;; M-x color-outline-mode RET
;;
;; Header level is determined by the number of comment characters.
;; The first level header starts from 3 comment characters.
;; For example, in ‘emacs-lisp-mode’:
;;
;;     ;;; Header 1
;;     ;;;; Header 2
;;     ;;;;; Header 3
;;
;; In ‘python-mode’:
;;
;;     ### Header 1
;;     #### Header 2
;;     ##### Header 3
;;
;; To toggle each header, use outline commands.
;;
;; Ideally, ‘comment-start’ defined by major modes are enough for
;; setting up color-outline, however, sometimes ‘comment-char’ is not
;; sufficient. Then you can add support for new major modes by
;;
;;     (color-outline-define-header MODE COMMENT-CHAR COMMENT-BEGIN)
;;
;; For example, COMMENT-CHAR for ‘python-mode’ is “#”. It can be more
;; than one character. COMMENT-BEGIN is the (possibly empty) beginning
;; of the header. For example, in OCaml, comments are (* ... *). Then
;; COMMENT-BEGIN is “(” and COMMENT-CHAR is “*”.
;;
;; Instead of using ‘color-outline-define-header’, you can also modify
;; ‘color-outline-comment-char-alist’ directly.
;;
;; If you want buffer-local setting for color-outline, you can add a
;; file-local variable ‘color-outline-local-comment-char’.
;;
;; Color-outline looks for comment char settings in the following order:
;; 1. Buffer-local ‘color-outline-local-comment-char’
;; 2. ‘color-outline-comment-char-alist’
;; 3. ‘comment-start’ defined by the major mode.

;;; Code:
;;

(require 'cl-lib)
(require 'subr-x)
(require 'rx)

(defgroup color-outline
  '((color-outline-comment-char-alist custom-variable)
    (color-outline-disable-list custom-variable)
    (color-outline-face-list custom-variable))
  "Easy programming mode outline with visual highlight."
  :group 'outline)

(defcustom color-outline-comment-char-alist
  '((c-mode "*" "/")
    (c++-mode "*" "/")
    (python-mode "#")
    (javascript-mode "/")
    (css-mode "*" "/")
    (tuareg-mode "*" "(")
    (shell-script-mode "#")
    (web-mode "-" "<!")
    (sh-mode "#"))
  "Stores custom comment character for each major mode.
An alist of (MAJOR-MODE . (COMMENT-CHAR COMMENT-BEGIN))
or (MAJOR-MODE . (COMMENT-CHAR)). For other major modes,
‘comment-start’ is enough."
  :type '(alist :key-type symbol
                :value-type sexp)
  :group 'color-outline)

(defcustom color-outline-disable-list '(org-mode outline-mode)
  "Color-outline mode is not enabled in these modes."
  :type '(repeat symbol)
  :group 'color-outline)

(defcustom color-outline-face-list
  '(outline-1 outline-2 outline-3 outline-4)
  "Face for each level."
  :type '(repeat symbol)
  :group 'color-outline)

(defvar-local color-outline-local-comment-char nil
  "Overriding buffer local setting for color-outline comment char.
This value takes the same form as the values in alist
‘color-outline-comment-char-alist’. I.e., a list (COMMENT-CHAR
COMMENT-BEGIN).")

(defvar-local color-outline--keywords nil
  "We store font-lock keywords in this variable.
This is used to remove font-lock rules when ‘color-outline-mode’
is turned off.")

(defvar-local color-outline--imenu-expression nil
  "We store imenu expressions in this variable.
This is used to remove imenu expressions when ‘color-outline-mode’
is turned off.")

(defun color-outline--create-pattern (comment-char comment-begin)
  "Return the header pattern for major mode MODE.
COMMENT-CHAR (string) is the comment character of this mode.
COMMENT-BEGIN is string pattern starting a comment.
The result pattern is

<COMMENT-START><COMMENT-CHAR>{3}<COMMENT-CHAR>*<SPACE><ANYCHAR>*

The first group is the second group of COMMENT-CHARS, the second
group is <ANYCHAR>*.

Return a plist

    (:outline PATTERN :font-lock PATTERN-LIST)

where PATTERN is suitable for `outline-regepx', PATTERN-LIST is suitable
for `font-lock-add-keywords' (a list of specs)."
  (let* ((header-level (length color-outline-face-list))
         (outline-re (rx-to-string `(seq ,comment-begin
                                         (= 3 ,comment-char)
                                         (group (* ,comment-char))
                                         " "
                                         (group (* (not (any ?\t ?\n)))))))
         (re-list (cl-loop
                   for level from 0 to (1- header-level)
                   collect
                   (rx-to-string `(seq bol
                                       ,comment-begin
                                       (= 3 ,comment-char)
                                       (= ,level ,comment-char)
                                       " "
                                       (* (not (any ?\t ?\n)))))))
         (font-lock-list (cl-loop for re in re-list
                                  for face in color-outline-face-list
                                  collect `(,re (0 ',face t t)))))
    (list :outline outline-re :font-lock font-lock-list)))

(defun color-outline-define-header (mode comment-char comment-begin)
  "Define the header pattern for major mode MODE.
COMMENT-CHAR (char) is the comment character of this mode.
COMMENT-BEGIN is string pattern starting a comment."
  (setf (alist-get mode color-outline-comment-char-alist)
        (color-outline--create-pattern comment-char comment-begin)))

(define-minor-mode color-outline-mode
  "Color outline."
  :lighter "Co"
  (if (and color-outline-mode
           (not (apply #'derived-mode-p color-outline-disable-list)))
      (if-let* ((rule (or color-outline-local-comment-char
                          (alist-get major-mode
                                     color-outline-comment-char-alist)
                          (list comment-start "")))
                (comment-char (or (car rule) comment-start))
                (comment-begin (or (cadr rule) ""))
                (config (color-outline--create-pattern
                         comment-char comment-begin))
                (outline-re (plist-get config :outline))
                (imenu-expression `("Section" ,outline-re 2))
                (font-lock-keyword-list (plist-get config :font-lock)))
          (progn (setq-local outline-regexp outline-re)
                 (setq-local outline-level
                             (lambda () (1+ (/ (length (match-string 1))
                                               (length comment-char)))))
                 (setq-local imenu-generic-expression
                             (cons imenu-expression
                                   imenu-generic-expression))
                 (when (not (bound-and-true-p
                             outline-minor-mode-highlight))
                   (font-lock-add-keywords nil font-lock-keyword-list))
                 (setq color-outline--keywords font-lock-keyword-list)
                 (setq color-outline--imenu-expression imenu-expression)
                 (outline-minor-mode))
        ;; Don’t error in major mode hooks.
        (message "No color-outline pattern configured for %s"
                 major-mode))
    (kill-local-variable 'outline-regexp)
    (kill-local-variable 'outline-level)
    (font-lock-remove-keywords nil color-outline--keywords)
    (setq-local imenu-generic-expression
                (remove color-outline--imenu-expression
                        imenu-generic-expression))
    (outline-minor-mode -1))
  (jit-lock-refontify))

(provide 'color-outline)

;;; color-outline.el ends here
#+end_src

** iimg
*** config
#+begin_src elisp
(setup iimg
  (:autoload iimg-enable)
  (setq iimg-prune-slices-p nil))
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/iimg.el
;;; iimg.el --- Inline image      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; This package provides three functionalities:
;;  1. Embedding images into text files by encoding them to base64
;;     strings.
;;  2. Rendering embedded images.
;;  3. Controlling the size of the displayed image.
;;
;; Why embed the image? This way everything is in a single file and I
;; feel safe.
;;
;; Update: embedding the image in the text brings problems in indexing
;; the text, the best alternative is to embed the image data in a
;; separate supplement file “current-file-name.iimg”. If you want to
;; insert a image and store the data in the supplement file, answer yes
;; when asked when inserting the image.
;;
;;;; To enable:
;;
;;     M-x iimg-enable RET
;;
;;;; To insert an image:
;;
;; Drag and drop the image or use `iimg-insert'. Iimg will prompt for
;; a caption/name for the image. If you don’t enter anything, iimg
;; generates a unique string as the fallback.
;;
;; When you insert an image, the image appears at point is just a
;; link, the actual base64 data is appended at the end of the file (or
;; in the supplement file). I separate link and data because that way
;; readers incapable of rendering inline images can still view the
;; rest of the document without problems.
;;
;;;; To resize an image:
;;
;; Type s on an image or use `iimg-resize'. In the minibuffer, type in
;; the specification in the format of “SIDE UNIT AMOUNT”.
;;
;; SIDE can be width or height.
;; UNIT can be char or pixel.
;; AMOUNT can be a float or a integer.
;;
;; For example, “width char 40” means 40 characters wide. If AMOUNT is
;; a floating point number like 0.5, it is interpreted as a percentage
;; to the width/height of the window and UNIT is ignored.
;;
;; The default size is (width char 70).
;;
;;;; To toggle thumbnail display:
;;
;; Type t on an image or use `iimg-toggle-thumbnail'.
;;
;;;; To delete an image or image data
;;
;; To protect the image data, iimg marks them read-only, to delete
;; the data, press D on the data.
;;
;;;; To render an image across multiple lines:
;;
;; Type m on an image or use `iimg-toggle-multi-line'.
;;
;; When an image is displayed across multiple lines, scrolling is much
;; smoother. However, this doesn't work well when image size is set to
;; n percent of the window width/height: if you change the window
;; width/height, the number of lines needed for the image changes, but
;; iimg doesn't update its "image lines" automatically.
;;
;; Another way to get smooth scrolling over images is to use
;; iscroll.el. In that case you don't need to make the image
;; multi-line.

;;; Developer
;;
;; IIMG-DATA := ({iimg-data (:name STRING :data STRING)})
;; IIMG-LINK := ({iimg-link (:name STRING :thumbnail BOOL :size SIZE)})
;; SIZE  := (SIDE UNIT NUMBER)
;; SIDE  := width | height
;; UNIT  := char | pixel
;;
;; How does iimg work:
;;  1. Scan through the file for iimg data, load images into
;;     `iimg--data-alist'.
;;  2. In jit-lock, render iimg links to images.
;;  3. When inserting a new image, update `iimg--data-alist',
;;     insert the data at the end of the file, and insert the link
;;     at point.
;;
;; `iimg--data-alist' is always up to date: any image in the file are
;; in the alist.
;;
;; Why text property instead of overlay: text property seems to be
;; faster (when scrolling, etc).

;;; Code:
;;
;; For `with-buffer-modified-unmodified'.
(require 'bookmark)

;;; Variables

(defvar-local iimg--data-alist nil
  "An alist of (NAME . IMAGE-DATA).
NAME (string) is the name of the image.
IMAGE-DATA is the image binary data.")

(defvar iimg-multi-line t
  "Render image in multiple lines.")

(defvar iimg-prune-slices-p t
  "If non-nil, iims prunes image slices when save.")

(defvar iimg--data-regexp (rx (seq "({iimg-data "
                                   (group (+? anything))
                                   "})"))
  "Regular expression for inline image data.
The first group is the plist containing data.")

(defvar iimg--link-regexp
  (rx (seq "({iimg-link " (group (+? anything)) "})"
           (group (* "\n---"))))
  "Regular expression for inline image link.
The first group is the plist containing data. The second group
contains the slices.")

(defsubst iimg--format-data (plist)
  "Return formatted iimg data.
PLIST is the plist part of the link, should be a plist."
  (format "({iimg-data %s})" (prin1-to-string plist)))

(defun iimg--format-link (plist)
  "Return formatted iimg link.
PLIST is the plist part of the link, should be a plist.
The image must already be in `iimg--data-alist'."
  (let* ((img (iimg--image-from-props plist))
         (multi-line (plist-get plist :multi-line))
         (row-count (ceiling (/ (cdr (image-size img t))
                                (frame-char-height)))))
    (format "({iimg-link %s})%s"
            (prin1-to-string plist)
            (if multi-line
                (with-temp-buffer
                  (dotimes (_ (1- row-count))
                    (insert "\n---"))
                  (buffer-string))
              ""))))

(defvar iimg--link-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map "t" #'iimg-toggle-thumbnail)
    (define-key map "s" #'iimg-resize)
    (define-key map "d" #'iimg-delete-image-at-point)
    (define-key map "m" #'iimg-toggle-multi-line)
    map)
  "Keymap used on images.")

(defvar iimg--data-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map "D" #'iimg-delete-data-at-point)
    map)
  "Keymap used on image data.")

;;; Loading and rendering


(defun iimg--image-from-props (props)
  "Given plist PROPS, return an image spec."
  (let* ((name (plist-get props :name))
         (thumbnail (plist-get props :thumbnail))
         (size (plist-get props :size))
         (size-spec (if thumbnail
                        ;; TODO This thumbnail size should work in most
                        ;; cases, but can be improved.
                        (iimg--calculate-size '(width char 30))
                      (iimg--calculate-size (or size '(width char 1.0))))))
    ;; Below `iimg--data-of' calls `iimg--load-image' which does
    ;; regexp search. I added `save-match-data' in `iimg--load-image'.
    (or (apply #'create-image (iimg--data-of name) nil t size-spec)
        (error "failed to create image"))))

(defun iimg--fontify-1 (beg end display)
  "Add overlay to text between BEG and END with DISPLAY property."
  (put-text-property beg end 'display display)
  (put-text-property beg end 'keymap iimg--link-keymap)
  (put-text-property beg end 'iimg t)
  (put-text-property beg end 'rear-nonstick '(display keymap iimg)))

(defun iimg--fontify (beg end)
  "Fontify embedded image links between BEG and END."
  (dolist (ov (overlays-in beg end))
    (if (overlay-get ov 'iimg)
        (delete-overlay ov)))
  ;; Fontify link.
  (goto-char beg)
  (while (and (re-search-forward iimg--link-regexp nil t)
              (< (match-beginning 0) end))
    ;; PROPS includes :name, :thumbnail, :size
    (let* ((props (read (match-string-no-properties 1)))
           (image (iimg--image-from-props props))
           (multi-line (plist-get props :multi-line))
           (name (plist-get props :name))
           (inhibit-read-only t))
      (cond
       ((not (display-graphic-p))
        ;; In terminal.
        (put-text-property
         (match-beginning 0) (match-end 0)
         'display (format "[iimg link of %s]" name)))
       ((not multi-line)
        ;; Render the image on a single line.
        (iimg--fontify-1 (match-beginning 0) (match-end 0) image))
       (t
        ;; Render the image across multiple lines. We assume the
        ;; number of placeholder lines in the buffer is correct.
        (save-excursion
          (let* ((slice-height (frame-char-height))
                 (image-width (car (image-size image t)))
                 (x 0) (y 0))
            (goto-char (match-beginning 0))
            (while (< (point) (match-end 0))
              (let ((beg (line-beginning-position))
                    (end (line-end-position)))
                (iimg--fontify-1
                 beg end (list (list 'slice x y image-width slice-height)
                               image))
                (put-text-property end (1+ end) 'line-height t)
                (setq y (+ y slice-height)))
              (forward-line))))))
      (put-text-property (match-beginning 0) (match-end 0)
                         'read-only t)
      ;; This allows inserting after the image.
      (put-text-property (match-beginning 0) (match-end 0)
                         'rear-nonsticky
                         '(read-only display iimg keymap))))
  (cons 'jit-lock-response (cons beg end)))

(defun iimg--calculate-size (size)
  "Translate SIZE to an size that `create-image' recognizes.
IOW, (:width NUMBER) or (:height NUMBER), where NUMBER is in
pixels.
Calculation is done based on the current window."
  (pcase-let*
      ((`(,side ,unit ,amount) size)
       ;; Pixel width/height of a character.
       (char-pixel-len (pcase side
                         ('width (frame-char-width))
                         ('height (frame-char-height))
                         (_ (signal 'iimg-invalid-size size))))
       ;; Pixel wdith/height of the window
       (window-len (pcase side
                     ('width (window-width nil t))
                     ('height (window-height nil t))
                     (_ (signal 'iimg-invalid-size size))))
       ;; Pixel width/height of a character or pixel.
       (unit-len (pcase unit
                   ('char char-pixel-len)
                   ('pixel 1)
                   (_ (signal 'iimg-invalid-size size))))
       (len (pcase amount
              ;; This much char or pixels.
              ((pred integerp) (floor (* amount unit-len)))
              ;; This percent of the window width/height.
              ((pred floatp) (floor (* amount window-len)))
              (_ (signal 'iimg-invalid-size size)))))

    (pcase side
      ('width (list :width len))
      ('height (list :height len)))))

(defun iimg--load-image-data (beg end)
  "Load iimg data from BEG to END.
Look for iimg-data’s and store them into an alist, then return it."
  ;; This could be called from within `iimg--fontify', and we
  ;; don’t want to mess up its match data.
  (save-match-data
    (save-excursion
      (goto-char beg)
      (let (alist)
        (while (re-search-forward iimg--data-regexp end t)
          (let* ((beg (match-beginning 1))
                 (end (match-end 1))
                 (props (read (buffer-substring-no-properties beg end)))
                 (name (plist-get props :name))
                 (base64-string (plist-get props :data))
                 (image-data (base64-decode-string base64-string)))
            (push (cons name image-data) alist)
            ;; We fontify data here because data are usually to long
            ;; to be handled correctly by jit-lock.
            (with-silent-modifications
              (let ((beg (match-beginning 0))
                    (end (match-end 0)))
                (put-text-property
                 beg end 'display (format "[iimg data of %s]" name))
                (put-text-property beg end 'read-only t)
                ;; This allows inserting after the data.
                (put-text-property beg end 'rear-nonsticky
                                   '(read-only display))
                (put-text-property beg end 'keymap iimg--data-keymap)
                (put-text-property beg end 'iimg t)))))
        alist))))

(defun iimg--supplement-file (&optional create)
  "Return the supplement-file if it exists, nil if not.
If CREATE non-nil, create the file when it doesn’t exist."
  (let ((supplement-file (concat (file-name-nondirectory
                                  (buffer-file-name))
                                 ".iimg")))
    (if (and create (not (file-exists-p supplement-file)))
        (with-temp-buffer
          (write-file supplement-file)))
    (if (file-exists-p supplement-file)
        supplement-file
      nil)))

(defun iimg--data-of (name)
  "Get the image data of NAME (string)."
  (when (not iimg--data-alist)
    (setq iimg--data-alist
          (append (iimg--load-image-data (point-min) (point-max))
                  (if-let ((file (iimg--supplement-file)))
                      (with-temp-buffer
                        (insert-file-contents file nil nil nil t)
                        (iimg--load-image-data
                         (point-min) (point-max)))))))
  (alist-get name iimg--data-alist nil nil #'equal))

(defun iimg--replenish-slices ()
  "Re-slice images.
We don't save the slices under a link, so we need to add them back."
  (save-excursion
    (with-buffer-modified-unmodified
     (goto-char (point-min))
     (while (re-search-forward iimg--link-regexp nil t)
       (when-let* ((props (read (buffer-substring-no-properties
                                 (match-beginning 1) (match-end 1))))
                   (multi-line (plist-get props :multi-line))
                   (inhibit-read-only t))
         (replace-match (iimg--format-link props)))))))

(defun iimg--prune-slices ()
  "Remove slices under a link before saving to a file."
  (save-excursion
    (let ((this-buffer (current-buffer))
          (this-file (buffer-file-name))
          (inhibit-read-only t))
      (with-temp-buffer
        (insert-buffer-substring this-buffer)
        (goto-char (point-min))
        (while (re-search-forward iimg--link-regexp nil t)
          (when-let ((beg (match-beginning 2))
                     (end (match-end 2)))
            (delete-region beg end)))
        (write-region (point-min) (point-max) this-file))
      (clear-visited-file-modtime)
      (set-buffer-modified-p nil)
      t)))

;;; Inserting and modifying

(defun iimg-insert (file name separate-file)
  "Insert FILE at point as an inline image.
NAME is the name of the image, THUMBNAIL determines whether to
display the image as a thumbnail, SIZE determines the size of the
image. See Commentary for the format of NAME, THUMBNAIL, and SIZE.

If SEPARATE-FILE non-nil, insert image data in a separate file
that appends .iimg extension to the current buffer’s filename."
  (interactive
   (list (expand-file-name (read-file-name "Image: "))
         (let ((name (read-string "Caption/name for the image: ")))
           (if (equal name "")
               (format-time-string "%s")
             name))
         (y-or-n-p "Insert in separate file? ")))
  (let* ((data (with-temp-buffer
                 (insert-file-contents-literally file nil nil nil t)
                 (base64-encode-region (point-min) (point-max))
                 ;; TODO Check for max image file size?
                 (buffer-string)))
         (data-string (iimg--format-data (list :name name :data data)))
         iimg-alist
         (insert-fn
          (lambda ()
            ;; Insert data.
            (save-excursion
              (goto-char (point-max))
              (when (text-property-any
                     (max (point-min) (1- (point))) (point) 'read-only t)
                (goto-char
                 (previous-single-char-property-change
                  (point) 'read-only)))
              (let ((beg (point)))
                (insert "\n" data-string "\n")
                (setq iimg-alist (iimg--load-image-data beg (point))))))))
    (if separate-file
        (let ((supp-file (iimg--supplement-file t)))
          (with-temp-buffer
            (insert-file-contents supp-file nil nil nil t)
            (funcall insert-fn)
            (write-file supp-file)))
      (funcall insert-fn))
    (setq iimg--data-alist (append iimg-alist iimg--data-alist))
    ;; Insert link. We insert link after loading image data.
    (insert (iimg--format-link
             (list :name name :size '(width pixel 0.6)
                   :ext (file-name-extension file))))))

(defun iimg--search-link-at-point (&optional datap)
  "Search for iimg link at point.
If found, set match data accordingly and return t, if not, return nil.

If DATAP non-nil, search for image data instead."
  (catch 'found
    (save-excursion
      (let ((pos (point)))
        (beginning-of-line)
        ;; First search in current line.
        (while (and (<= (point) pos)
                    (re-search-forward
                     (if datap iimg--data-regexp iimg--link-regexp)
                     nil t))
          (if (<= (match-beginning 0) pos (match-end 0))
              (throw 'found t)))
        ;; Next search by search backward.
        (goto-char pos)
        (if (and (search-backward
                  (if datap "({iimg-data" "({iimg-link")
                  nil t)
                 (re-search-forward
                  (if datap iimg--data-regexp iimg--link-regexp)
                  nil t)
                 (<= (match-beginning 0) pos (match-end 0)))
            (throw 'found t))))))

(defun iimg--link-at-point ()
  "Return the data (plist) of the iimg link at point.
Return nil if not found."
  (if (iimg--search-link-at-point)
      (read (match-string 1))
    nil))

(defun iimg--set-link-at-point-refresh (props)
  "Set iimg link at point to PROPS, if there is any link.
Also refresh the image at point."
  (when (iimg--search-link-at-point)
    (save-excursion
      (let ((beg (match-beginning 0))
            (inhibit-read-only t))
        (goto-char beg)
        (delete-region beg (match-end 0))
        (insert (iimg--format-link props))
        (iimg--fontify beg (point))))))

(defun iimg-resize ()
  "Resize the inline image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (let ((size (read
                   (format "(%s)"
                           (read-string
                            "width/height char/pixel amount: ")))))
        (setq img-props (plist-put img-props :size size))
        (iimg--set-link-at-point-refresh img-props))
    (user-error "There is no image at point")))

(defun iimg-toggle-thumbnail ()
  "Toggle thumbnail display for the image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (progn (setq img-props
                   (plist-put img-props :thumbnail
                              (not (plist-get img-props :thumbnail))))
             (iimg--set-link-at-point-refresh img-props))
    (user-error "There is no image at point")))

(defun iimg-toggle-multi-line ()
  "Toggle multi-line display for the image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (progn (setq img-props
                   (plist-put img-props :multi-line
                              (not (plist-get img-props :multi-line))))
             (iimg--set-link-at-point-refresh img-props))
    (user-error "There is no image at point")))

(defun iimg-delete-image-at-point ()
  "Delete the image at point."
  (interactive)
  (if (iimg--search-link-at-point)
      (let ((inhibit-read-only t))
        (delete-region (match-beginning 0) (match-end 0)))
    (user-error "There is no image at point")))

(defun iimg-delete-data-at-point ()
  "Delete the image data at point."
  (interactive)
  (if (iimg--search-link-at-point t)
      (let ((inhibit-read-only t))
        (delete-region (match-beginning 0) (match-end 0)))
    (user-error "There is no image data at point")))

(defun iimg-export ()
  "Export image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (let ((path (concat (read-file-name "Export to (w/o extension): ")
                          (or (plist-get img-props :ext) ".png")))
            (data (iimg--data-of (plist-get img-props :name))))
        (when (file-exists-p path)
          (user-error "File exists, can’t export to it"))
        (when (not (file-writable-p path))
          (user-error "File not wraiteble, can’t export to it"))
        (with-temp-file path
          (insert data))
        (message "Exported to %s" path))
    (user-error "There is no image at point")))

;;; Entry

(defun iimg-enable ()
  "Enable iimg."
  (jit-lock-register #'iimg--fontify)
  (setq-local dnd-protocol-alist
              (cons '("^file:" . iimg-dnd-open-file)
                    dnd-protocol-alist))
  (when iimg-prune-slices-p
    (add-hook 'write-file-functions #'iimg--prune-slices 90 t))
  (iimg--replenish-slices))

;;; Drag and drop

(defun iimg-dnd-open-file (uri _action)
  "Drag-and-drop handler for iimg. URI is the file path."
  (let ((file (dnd-get-local-file-name uri t)))
    (if (and file (file-readable-p file))
        (iimg-insert
         file (let ((name (read-string "Caption/name for the image: ")))
                (if (equal name "")
                    (format-time-string "%s")
                  name))
         (y-or-n-p "Insert in separate file? ")))))

(provide 'iimg)

;;; iimg.el ends here
#+end_src
** bklink
#+begin_src elisp
(setup bklink
  (:autoload bklink-minor-mode)
  (with-eval-after-load 'bklink
    (:bind "C-c l" bklink-show-back-link
           "C-c i" bklink-insert))
  (setq bklink-summary-read-only-p nil
        bklink-prune-summary-p nil))
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/bklink.el
;;; bklink.el --- Poor man's back-link      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; In org-roam, you can show back links -- a list of files that
;; contains a link to the current file. The idea is nice but I don’t
;; like how org-roam and zetteldeft implement things. Hence this
;; minimal package.
;;
;; Some assumptions about the files that contains bklink:
;;
;;  1. All the files are in the same directory. So we can use filename
;;     to uniquely identify files.
;;  2. There is no sub-directories.
;;  3. There aren’t a ton of files. We use grep to search for links,
;;     no caching (though not hard to add one).
;;  4. filenames don’t contain “}]”.
;;
;; Advantages:
;;
;;  1. Filename as link, no id, no database.
;;  2. Works for multiple directories without configuration.
;;  3. Works for any file format.
;;  4. Back-link summary is not saved to the file.
;;
;; To use with Deft:
;;
;;     (add-hook 'deft-open-file-hook #'bklink-minor-mode)
;;     (setq deft-use-filter-string-for-filename t)
;;
;; Usage:
;;
;; Link format is [{filename.ext}]. Extension is optional.
;; Links are displayed as [filename] with 'link face.
;;
;; Insert a link to another file or edit a link:
;;
;;     M-x bklink-insert RET
;;
;; Show back-links:
;;
;;     M-x bklink-show-back-link RET
;;
;; Rename all links to the current file:
;;
;;     M-x bklink-rename new-name RET
;;
;; And then manually rename the current file.
;;
;; Notes:
;;
;; - If a link doesn’t have extension, bklink appends “.txt” to it
;;   when searching for the corresponding file.
;; - If the file a link points to doesn’t exist, bklink doesn’t create
;;   that file. Instead, bklink creates a buffer, and you can show
;;   back-links to it without creating that file.
;; - When ‘bklink-show-back-link-on-start’ is non-nil, back-link
;;   summary is shown on startup.
;; - When ‘bklink-use-form-feed’ is non-nil, bklink uses form-feed
;;   character to delineate back-link summary.
;; - Using id instead of title as filenames is a dumb idea.

;;; Code:

(require 'cl-lib)
;; For `with-buffer-modified-unmodified'.
(require 'bookmark)

;;; Customize

(defvar bklink-use-form-feed t
  "If non-nil, use form-feed instead of dashes.")

(defvar bklink-show-back-link-on-start t
  "If non-nil, show back-links when `bklink-minor-mode' starts.")

(defvar bklink-more-match nil
  "If non-nil, bklink includes more matches in the back-link summary.

Besides explicitly links, we also include text that matches the
title but isn't a link.

For example, for Emacs.txt, we match not only [{Emacs.txt}],
but also Emacs.")

(defvar bklink-summary-read-only-p t
  "If non-nil, bklink marks the summary read-only.")

(defvar bklink-prune-summary-p t
  "If non-nil, bklink prunes summary when save.")

;;; Backstage

(defvar bklink-regexp (rx (seq (group "[{")
                               (group (+? (not (any "/"))))
                               (group (? (or ".txt" ".org" ".md")))
                               (group "}]")))
  "Regular expression that matches a bklink.

Group 1 is opening delimiter.
Group 2 is base filename.
Group 3 is filename extension (if exists).
Group 4 is ending delimiter.

Change this variable and
`bklink--format-link' to change link format.")

(defsubst bklink--format-link (file)
  "Format FILE into a bklink. Basically [[FILE]]."
  (format "[{%s}]" file))

(defun bklink--get-file-list (file)
  "Return a list of files that’s in the same project with FILE.
Ignore dotfiles and directories."
  (cl-remove-if (lambda (f) (or (string-prefix-p "." f)
                                (file-directory-p f)))
                ;; FILE could be a file-less buffer.
                (directory-files (or (file-name-directory file)
                                     default-directory))))

(defun bklink--search-at-point ()
  "Search for links at point and set match data accordingly.
Return t if found, nil otherwise. See `bklink--regepx' for
groups."
  (save-excursion
    (catch 'found
      (let ((p (point)))
        (beginning-of-line)
        (while (re-search-forward bklink-regexp (line-end-position) t)
          (if (<= (match-beginning 0) p (match-end 0))
              (throw 'found t)))))))

(defun bklink--file-at-point ()
  "Return the filename of the link at point.
Return nil if not found."
  (bklink--search-at-point)
  (buffer-substring-no-properties (match-beginning 2) (match-end 3)))

(defun bklink--set-file-at-point (name)
  "Set the file name of the link at point to NAME.
Do nothing if there is no link at point."
  (bklink--search-at-point)
  (save-excursion
    (goto-char (match-beginning 2))
    (delete-region (match-beginning 2) (match-end 3))
    (insert name)))

;;;; Link button

(define-button-type 'bklink
  'action #'bklink-follow-link
  'filename nil
  'follow-link t
  'use-window nil
  'help-echo "Jump to file")

;; Please the byte compiler.
(defvar bklink-minor-mode)
(defun bklink-follow-link (button)
  "Jump to the file that BUTTON represents.
If the file doesn't exist, create a buffer."
  (with-demoted-errors "Error when following the link: %s"
    (let* ((file (button-get button 'filename))
           (fullname (if (file-name-extension file)
                         file
                       (concat file ".txt"))))
      (if (file-exists-p fullname)
          (find-file fullname)
        (switch-to-buffer (get-buffer-create fullname))
        (when (eq (point) 1)
          (insert (file-name-base file) "\n\n"))))
    (when (eq major-mode 'fundamental-mode)
      (text-mode))
    (unless bklink-minor-mode
      (bklink-minor-mode))))

(define-button-type 'bklink-url
  'action #'bklink-browse-url
  'url nil
  'follow-link t
  'help-echo "Open URL")

(defun bklink-browse-url (button)
  "Open URL in BUTTON."
  (browse-url (button-get button 'url)))

;;;; Highlight links

(define-minor-mode bklink-minor-mode
  "Recognizes bklinks."
  :lighter ""
  :keymap (make-sparse-keymap)
  (if bklink-minor-mode
      (progn (jit-lock-register #'bklink-fontify)
             (unless (derived-mode-p 'org-mode 'markdown-mode)
               (jit-lock-register #'bklink-fontify-url))
             (when bklink-prune-summary-p
               (add-hook 'write-file-functions
                         #'bklink--write-file-function 90 t))
             ;; (add-hook 'fill-nobreak-predicate #'bklink--nobreak-p 90 t)
             (if (and bklink-show-back-link-on-start
                      (not bklink-show-back-link))
                 (bklink-show-back-link)))
    (jit-lock-unregister #'bklink-fontify)
    (jit-lock-unregister #'bklink-fontify-url)
    ;; (remove-hook 'fill-nobreak-predicate #'bklink--nobreak-p t)
    (with-silent-modifications
      (put-text-property (point-min) (point-max) 'display nil)))
  (jit-lock-refontify))

(defun bklink-fontify (beg end)
  "Highlight bklinks between BEG and END."
  (goto-char beg)
  (while (and (re-search-forward bklink-regexp nil t)
              (< (point) end))
    (let* ((inhibit-read-only t)
           (filename (concat
                      (match-string-no-properties 2)
                      (or (match-string-no-properties 3)
                          ""))))
      ;; Hide opening and closing delimiters and file extension.
      (with-silent-modifications
        ;; (put-text-property (match-beginning 0) (match-end 0)
        ;;                    'bklink-no-break t)
        (add-text-properties
         (match-beginning 1) (match-end 1)
         '(display "[" font-lock-face shadow face shadow))
        (add-text-properties
         (match-beginning 4) (match-end 4)
         '(display "]" font-lock-face shadow face shadow))
        (when (match-beginning 3)
          (put-text-property (match-beginning 3)
                             (match-end 3) 'invisible t))
        (put-text-property (match-beginning 0) (match-end 0)
                           'rear-nonsticky t)
        ;; Highlight link.
        (make-text-button (match-end 1)
                          (match-beginning 4)
                          :type 'bklink
                          'filename filename)))))

(defun bklink-fontify-url (beg end)
  "Add clickable buttons to URLs between BEG and END.
Everything that matches `browse-url-button-regexp' will be made
clickable and will use `browse-url' to open the URLs in question."
  ;; Change face to font-lock-face.
  (goto-char beg)
  (while (re-search-forward browse-url-button-regexp end t)
    (make-text-button (match-beginning 0)
                      (match-end 0)
                      :type 'bklink-url
                      'url (match-string-no-properties 0))))

;; (defun bklink--nobreak-p ()
;;   "Return non-nil if shouldn't break at point."
;;   (text-property-any
;;    (max (1- (point)) (point-min)) (point) 'bklink-no-break t))

;;;; Back-link summary

(defvar bklink--back-link-regexp
  (rx (seq "\n" (or "\x0C" (= 70 "-")) "\n"
           ;; Non-greedy is important: otherwise we risk of
           ;; regexp stack overflow. That happened for buffers
           ;; when iimg data.
           (+? digit) " linked reference" (? "s") (+? anything)
           (or "\x0C" (= 70 "-")) "\n"))
  "Regular expression that matches the beginning of a summary.")

(defun bklink--prune-back-link-summary ()
  "Remove back-links before save."
  (goto-char (point-min))
  (let ((inhibit-read-only t))
    ;; Remove summary.
    (when (re-search-forward bklink--back-link-regexp nil t)
      (delete-region (match-beginning 0) (match-end 0)))))

(defun bklink--insert-back-link-summary (files buffer this-file)
  "Append back-link summary to BUFFER.
FILES is a list of filenames that contains the link.
THIS-FILE is the filename we are inserting summary into."
  (with-current-buffer buffer
    (save-excursion
      (with-buffer-modified-unmodified
       (bklink--prune-back-link-summary)
       (goto-char (point-max))
       (let* ((summary-start (point))
              (this-link (bklink--format-link this-file))
              (this-link-re
               (replace-regexp-in-string
                " " "[ \n]*" (regexp-quote this-link)))
              ;; A list of (FILE . SUMMARY). The grep search didn't
              ;; match against the complete link and we need to filter
              ;; out the false-positives here.
              (summary-list
               (mapcar
                (lambda (file)
                  (if (not (equal file this-file))
                      (with-temp-buffer
                        (insert-file-contents file nil nil nil t)
                        (goto-char (point-min))
                        (if (re-search-forward this-link-re nil t)
                            (let ((summary
                                   (or (string-trim
                                        (thing-at-point 'line))
                                       "(No summary)")))
                              (cons file summary))))))
                files))
              (summary-list (remove nil summary-list))
              (inhibit-read-only t))
         ;; Insert separator.
         (insert "\n"
                 (if bklink-use-form-feed "\x0C" (make-string 70 ?-))
                 "\n"
                 (format "%d linked reference%s:\n"
                         (length summary-list)
                         ;; Plural when more than one.
                         (if (eq (length summary-list) 1) "" "s")
                         this-link))
         (dolist (summary summary-list)
           (insert "\n")
           ;; Insert file link.
           (insert (bklink--format-link (car summary)) ":\n")
           ;; Insert surrounding sentence. We only get the first
           ;; sentence. Don’t fill the paragraph, filling might break
           ;; the layout of the original text.
           (let ((beg (point)))
             (insert (cdr summary))
             (indent-rigidly beg (point) 2))
           (insert "\n"))
         (insert (if bklink-use-form-feed "\x0C" (make-string 70 ?-)))
         (put-text-property summary-start (point)
                            'read-only bklink-summary-read-only-p)
         ;; Add an non-read-only newline so the user and other
         ;; commands can append text at the end of the file.
         (insert "\n")
         (bklink-fontify summary-start (point)))))))

(defun bklink--write-file-function ()
  "Write to file without the back-links."
  (save-excursion
    (let ((this-buffer (current-buffer))
          (this-file (buffer-file-name)))
      (with-temp-buffer
        (insert-buffer-substring this-buffer)
        (bklink--prune-back-link-summary)
        (write-region (point-min) (point-max) this-file))
      (clear-visited-file-modtime)
      (set-buffer-modified-p nil)
      t)))

;;;; Retrieve back-links

(defun bklink--get-linked-files (file callback)
  "Call CALLBACK with a list of filenames that has a link to FILE."
  (let* ((name (generate-new-buffer-name " *bklink grep*"))
         (process (apply
                   #'start-process
                   name name "grep" "-ilF"
                   ;; The link could span multiple lines (because of
                   ;; filling), so we only search for the part before
                   ;; first space as a preliminary filter. We later do
                   ;; an accurate search in
                   ;; `bklink--insert-back-link-summary'.
                   (car (split-string
                         (if bklink-more-match
                             (file-name-base file)
                           (bklink--format-link
                            (file-name-nondirectory file)))))
                   (bklink--get-file-list file)))
         ;; When the grep process finishes, we parse the result files
         ;; and call CALLBACK with them.
         (sentinal
          (lambda (process event)
            (if (string-match-p (rx (or "finished" "exited"))
                                event)
                (if-let ((buf (process-buffer process)))
                    (unwind-protect
                        (with-current-buffer buf
                          (let ((files (split-string
                                        (buffer-string) "\n")))
                            (funcall callback
                                     (mapcar #'file-name-nondirectory
                                             (remove "" files)))))
                      (kill-buffer buf))
                  (error "Bklink’s grep process’ buffer is killed"))
              (error "Bklink’s grep process failed with signal: %s"
                     event)))))
    (set-process-sentinel process sentinal)))

;;; Userland

(defun bklink-insert ()
  "Insert a link to a file.
If point not on a link, insert a new link, if already on a link,
edit the link."
  (interactive)
  (if (bklink--search-at-point)
      (let ((file (completing-read
                   "New file: "
                   (mapcar #'file-name-base
                           (bklink--get-file-list (buffer-file-name)))
                   nil nil (bklink--file-at-point))))
        (bklink--set-file-at-point file))
    (let* ((file (completing-read
                  "File: "
                  (mapcar #'file-name-nondirectory
                          (bklink--get-file-list (buffer-file-name))))))
      (insert (bklink--format-link file))))
  (bklink-minor-mode))

(define-minor-mode bklink-show-back-link
  "Toggle display of a buffer that show back-links.
The back-links are links to the files that has a link to this file."
  :lighter ""
  (unless (executable-find "grep")
    (user-error "Displaying back-link needs grep but we cannot find it"))
  (unless bklink-minor-mode
    (user-error "Bklink-minor-mode is not on"))
  (if bklink-show-back-link
      ;; The buffer could be not having a file.
      (if-let ((file (or (buffer-file-name) (buffer-name)))
               (buffer (current-buffer)))
          ;; Fire a sub-process to retrieve back-links.
          (bklink--get-linked-files
           file (lambda (file-list)
                  (bklink--insert-back-link-summary
                   file-list buffer (file-name-nondirectory file))))
        (user-error "This buffer is not associated with any file"))
    (with-buffer-modified-unmodified
     (save-excursion
       (bklink--prune-back-link-summary)))))

(defun bklink-rename (new-name)
  "Rename current file to NEW-NAME.
Rename bklinks that points to the current file point to NEW-NAME.
This command only rename links, you need to manually rename the
current file."
  ;; We run grep to find files that contain the old link, save them to
  ;; /tmp/bklink-rename, and use emacs to replace old links with new
  ;; links in each file. I can’t believe there is no painless way to
  ;; replace literal strings in sed.
  (interactive
   (let ((name (file-name-nondirectory (buffer-file-name))))
     (list (completing-read
            (format "Rename %s to: " name) nil nil name))))
  (unless (executable-find "grep")
    (user-error "Rename needs grep but we cannot find it"))
  (unless (executable-find "emacs")
    (user-error "Rename needs Emacs in PATH but we cannot find it"))
  (when (file-exists-p new-name)
    (user-error "Cannot rename to %s, this file already exists" new-name))
  (when (yes-or-no-p (format "Replace %s to %s?"
                             (file-name-nondirectory
                              (buffer-file-name))
                             new-name))
    (let* ((old-link (bklink--format-link (file-name-nondirectory
                                           (buffer-file-name))))
           (new-link (bklink--format-link new-name))
           (tmp-file (concat "/tmp/bklink-rename-"
                             (format-time-string "%s")))
           (command
            (concat
             (format "grep -ilF '%s' %s > %s"
                     (car (split-string old-link))
                     default-directory tmp-file)
             (format "; emacs --batch -l '%s'"
                     (find-library-name "bklink"))
             (format
              " --eval '(bklink--process-rename \"%s\" \"%s\" \"%s\")'"
              old-link new-link tmp-file))))
      (start-process-shell-command
       "bklink rename" " *bklink rename*" command)
      (message "Replacing %s with %s in the background"
               old-link new-link))))

(defun bklink--process-rename (old-link new-link path-file)
  "Replace OLD-LINK with NEW-LINK.
The files to replace are in PATH-FILE"
  (with-temp-buffer
    (insert-file-contents path-file)
    (dolist (file (split-string (buffer-string) "\n"))
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (let ((link-re (string-join
                        (mapcar #'regexp-quote
                                (split-string old-link))
                        "[ \n]*")))
          (while (re-search-forward link-re nil t)
            (replace-match new-link)))
        (write-file file)))))

(provide 'bklink)

;;; bklink.el ends here
#+end_src

** flique
*** config
#+begin_src emacs-lisp
(setup flique)
#+end_src
*** Source
#+begin_src elisp :tangle site-lisp/flique.el
;;; flique.el --- File cliques  -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; This package complements bklink.el. With this package, you can
;; easily group related note files into cliques and go back and
;; forth within the clique.
;;
;; To start, create a file "index.flique" under the directory where
;; all the notes are. Each line is a filename. Consecutive lines define
;; a clique. Separate cliques by empty lines. For example,
;;
;; file1.txt
;; file2.txt
;;
;; file3.txt
;; file4.txt
;;
;; defines two cliques, file1 and 2, and file3 and 4.
;;
;; Then, you can go back and forth by
;;
;;  - ‘flique-forward’
;;  - ‘flique-backward’
;;
;; If a line in the index file contains a file that doesn’t exist,
;; flique just ignores that.

;;; Code:

(defun flique--index ()
  "Return the index buffer."
  (with-current-buffer (get-buffer-create " *flique index*")
    (when (file-exists-p "index.flique")
      (insert-file-contents "index.flique" nil nil nil t))
    (current-buffer)))

(defun flique-append-to-index (file)
  "Add FILE to the end of the index file.
Only add if FILE is not already in the index file."
  (with-current-buffer (flique--index)
    (goto-char (point-min))
    ;; Unless already exists...
    (unless (re-search-forward
             (concat "^" (regexp-quote
                          (file-name-nondirectory file))
                     "$")
             nil t)
      ;; ...append to the end.
      (goto-char (point-max))
      (unless (looking-back "\n" 1)
        (insert "\n"))
      (insert (file-name-nondirectory file))
      ;; If we use ‘write-file’, this buffer is associated with
      ;; index.flique. (Changes from *flique index* to index.flique.)
      (write-region (point-min) (point-max) "index.flique"))))

(defun flique--next-file (filename step)
  "Return the next file of FILENAME. FILENAME cannot be a path.
STEP can be either 1 or -1, 1 for going forward, -1 for going
backward."
  (with-current-buffer (flique--index)
    (goto-char (point-min))
    (when (and (re-search-forward
                (concat "^" (regexp-quote filename) "$") nil t)
               (eq 0 (forward-line step)))
      (let ((next (buffer-substring
                   (line-beginning-position)
                   (line-end-position))))
        (unless (equal next "")
          next)))))

(defun flique-forward ()
  "Go forward in the clique."
  (interactive)
  (let ((next (flique--next-file
               (file-name-nondirectory (buffer-file-name))
               1)))
    (when (and next (file-exists-p next))
      (find-file next)
      (flique-show-navigation))))

(defun flique-backward ()
  "Go backward in the clique."
  (interactive)
  (let ((next (flique--next-file
               (file-name-nondirectory (buffer-file-name))
               -1)))
    (when (and next (file-exists-p next))
      (find-file next)
      (flique-show-navigation))))

(defun flique-show-navigation ()
  "Display a navigation bar in header-line."
  (let* ((filename (file-name-nondirectory (buffer-file-name)))
         (prev (flique--next-file filename -1))
         (next (flique--next-file filename 1)))
    (when (or prev next)
      (setq header-line-format
            (propertize
             (concat
              (if (and prev (file-exists-p prev))
                  (concat "← " (file-name-base prev))
                ":-O")
              (propertize "\t" 'display `(space :width ,tab-width))
              (if (and next (file-exists-p next))
                  (concat (file-name-base next) " →")
                ":-D")
              (propertize " " 'display '(raise 0.3))
              (propertize " " 'display '(raise -0.2)))
             'face '(:height 130))))))

(defun flique-list ()
  "Show the current file in the flique index file."
  (interactive)
  (let ((filename (file-name-nondirectory (buffer-file-name))))
    (find-file "index.flique")
    (goto-char (point-min))
    (re-search-forward (concat "^" (regexp-quote filename) "$") nil t)
    (beginning-of-line)))

(define-derived-mode flique-mode fundamental-mode
  "Flique"
  "Editing flique index files."
  (setq outline-regexp (rx "*"))
  (outline-minor-mode))

(add-to-list 'auto-mode-alist '("\\.flique\\'" . flique-mode))

(provide 'flique)

;;; flique.el ends here
#+end_src

** window-numbering
#+begin_src elisp
(setup window-numbering
  (:autoload window-numbering-mode)
  (:with-hook (after-init-hook)
    (:hook window-numbering-mode)))
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/window-numbering.el
;;; window-numbering.el --- Numbered window shortcuts
;;
;; Copyright (C) 2006-2007, 2013, 2015 Nikolaj Schumacher <bugs * nschum , de>
;;
;; Author: Nikolaj Schumacher <bugs * nschum de>
;; Version: 1.1.2
;; Keywords: faces, matching
;; URL: http://nschum.de/src/emacs/window-numbering-mode/
;; Compatibility: GNU Emacs 22.x, GNU Emacs 23.x, GNU Emacs 24.x
;;
;; This file is NOT part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;
;;; Commentary:
;;
;; Enable window-numbering-mode and use M-1 through M-0 to navigate.
;;
;; If you want to affect the numbers, use window-numbering-before-hook or
;; window-numbering-assign-func.
;; For instance, to always assign the calculator window the number 9, add the
;; following to your .emacs:
;;
;; (setq window-numbering-assign-func
;;       (lambda () (when (equal (buffer-name) "*Calculator*") 9)))
;;
;;; Changes Log:
;; 2022-07-06
;;
;;   Use cl-lib instead of cl.
;;   Update `define-minor-mode' key.
;;
;; Doglooksgod
;;
;;    Fix numbering of minibuffer for recent Emacs versions.
;;
;; 2013-03-23 (1.1.2)
;;    Fix numbering in terminal mode with menu bar visible.
;;    Add face for window number.  (thanks to Chen Bin)
;;
;; 2008-04-11 (1.1.1)
;;    Added possibility to delete window with prefix arg.
;;    Cleaned up code and migrated to `defcustom'.
;;
;; 2007-02-18 (1.1)
;;    Added window-numbering-before-hook, window-numbering-assign-func.
;;
;;; Code:

(eval-when-compile (require 'cl-lib))

(push "^No window numbered .$" debug-ignored-errors)

(defgroup window-numbering nil
  "Numbered window shortcuts"
  :group 'convenience)

(defcustom window-numbering-auto-assign-0-to-minibuffer t
  "*If non-nil, `window-numbering-mode' assigns 0 to the minibuffer if active."
  :group 'window-numbering
  :type '(choice (const :tag "Off" nil)
                 (const :tag "On" t)))

(defcustom window-numbering-before-hook nil
  "*Hook called before `window-numbering-mode' starts assigning numbers.
The number of windows that will be numbered is passed as a parameter.
Use `window-numbering-assign' to manually assign some of them a number.
If you want to assign a number to just one buffer, use
`window-numbering-assign-func' instead."
  :group 'window-numbering
  :type 'hook)

(defcustom window-numbering-assign-func nil
  "*Function called for each window by `window-numbering-mode'.
This is called before automatic assignment begins.  The function should
return a number to have it assigned to the current-window, nil otherwise."
  :group 'window-numbering
  :type 'function)

(defconst window-numbering-mode-line-position 1
  "The position in the mode-line `window-numbering-mode' displays the number.")

(defface window-numbering-face
  '()
  "Face used for the number in the mode-line."
  :group 'window-numbering)

(defvar window-numbering-table nil
  "table -> (window vector . number table)")

(defun select-window-by-number (i &optional arg)
  "Select window given number I by `window-numbering-mode'.
If prefix ARG is given, delete the window instead of selecting it."
  (interactive "P")
  (let ((windows (car (gethash (selected-frame) window-numbering-table)))
        window)
    (if (and (>= i 0) (< i 10)
             (setq window (aref windows i)))
        (if arg
            (delete-window window)
          (select-window window))
      (error "No window numbered %s" i))))

;; define interactive functions for keymap
(dotimes (i 10)
  (eval `(defun ,(intern (format "select-window-%s" i)) (&optional arg)
           ,(format "Select the window with number %i." i)
           (interactive "P")
           (select-window-by-number ,i arg))))

(defun window-numbering-calculate-left (windows)
  (let ((i 9) left)
    (while (>= i 0)
      (let ((window (aref windows i)))
        (unless window
          (push (% (1+ i) 10) left)))
      (cl-decf i))
    left))

(defvar window-numbering-windows nil
  "A vector listing the window for each number.")
(defvar window-numbering-numbers
  "A hash map containing each window's number.")
(defvar window-numbering-left
  "A list of unused window numbers.")

(defun window-numbering-assign (window &optional number)
  (if number
      (if (aref window-numbering-windows number)
          (progn (message "Number %s assigned to two buffers (%s and %s)"
                          number window (aref window-numbering-windows number))
                 nil)
        (setf (aref window-numbering-windows number) window)
        (puthash window number window-numbering-numbers)
        (setq window-numbering-left (delq number window-numbering-left))
        t)
    ;; else default adding
    (when window-numbering-left
      (unless (gethash window window-numbering-numbers)
        (let ((number (car window-numbering-left)))
          (window-numbering-assign window number)
          number)))))

(defun window-numbering-update ()
  "Update the window numbering for the current frame.
Optional parameter PREASSIGNED-WINDOWS is a hashmap already mapping some
windows to numbers."
  (setq window-numbering-windows (make-vector 10 nil)
        window-numbering-numbers (make-hash-table :size 10)
        window-numbering-left
        (window-numbering-calculate-left window-numbering-windows))
  (puthash (selected-frame)
           (cons window-numbering-windows window-numbering-numbers)
           window-numbering-table)
  (when (and window-numbering-auto-assign-0-to-minibuffer
             (active-minibuffer-window))
    (window-numbering-assign (active-minibuffer-window) 0))
  (let ((windows (window-list nil 0 (frame-first-window))))
    (run-hook-with-args 'window-numbering-before-hook windows)
    (when window-numbering-assign-func
      (mapc (lambda (window)
              (with-selected-window window
                (with-current-buffer (window-buffer window)
                  (let ((num (funcall window-numbering-assign-func)))
                    (when num
                      (window-numbering-assign window num))))))
            windows))
    (dolist (window windows)
      (window-numbering-assign window))))

(defun window-numbering-get-number-string (&optional window)
  (let ((s (int-to-string (window-numbering-get-number window))))
    (propertize s 'face 'window-numbering-face)))

(defun window-numbering-get-number (&optional window)
  (gethash (or window (selected-window))
           (cdr (gethash (selected-frame) window-numbering-table))))

(defvar window-numbering-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map "\M-0" 'select-window-0)
    (define-key map "\M-1" 'select-window-1)
    (define-key map "\M-2" 'select-window-2)
    (define-key map "\M-3" 'select-window-3)
    (define-key map "\M-4" 'select-window-4)
    (define-key map "\M-5" 'select-window-5)
    (define-key map "\M-6" 'select-window-6)
    (define-key map "\M-7" 'select-window-7)
    (define-key map "\M-8" 'select-window-8)
    (define-key map "\M-9" 'select-window-9)
    map)
  "Keymap used in by `window-numbering-mode'.")

;;;###autoload
(define-minor-mode window-numbering-mode
  "A minor mode that assigns a number to each window."
  :init-value nil :lighter nil :keymap window-numbering-keymap :global t
  (if window-numbering-mode
      (unless window-numbering-table
        (save-excursion
          (setq window-numbering-table (make-hash-table :size 16))
          (add-hook 'minibuffer-setup-hook 'window-numbering-update)
          (add-hook 'window-configuration-change-hook
                    'window-numbering-update)
          (dolist (frame (frame-list))
            (select-frame frame)
            (window-numbering-update))))
    (window-numbering-clear-mode-line)
    (remove-hook 'minibuffer-setup-hook 'window-numbering-update)
    (remove-hook 'window-configuration-change-hook
                 'window-numbering-update)
    (setq window-numbering-table nil)))

(defun window-numbering-clear-mode-line ()
  "Remove the window number of `window-numbering-mode' from the mode-line."
  (let ((mode-line (default-value 'mode-line-format))
        (res))
    (while mode-line
      (let ((item (car mode-line)))
        (unless (equal item '(:eval (window-numbering-get-number-string)))
          (push item res)))
      (pop mode-line))
    (setq-default mode-line-format (nreverse res)))
  (force-mode-line-update t))

(provide 'window-numbering)

;;; window-numbering.el ends here
#+end_src

** Themes
*** nano
#+begin_src elisp :tangle themes/nano-theme.el
;;; nano-theme.el --- A theme split from nano-emacs  -*- lexical-binding: t; -*-

;; Copyright (C) 2021-2022 LiuBo

;; Author: LiuBo <https://github.com/404cn>
;; Created: May 30, 2021
;; Version: 1.0.0
;; Keywords: theme
;; Homepage: https://github.com/404cn/nano-theme.el
;; Package-Requires: ((emacs "28.0.50"))

;;
;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.


;;; Commentary:

;;; A theme split from nano-emacs.

;;; Code:

(deftheme nano "Theme split from nano-emacs")

(defgroup nano-theme nil
  "Options of nano theme."
  :group 'faces)

(defcustom nano-theme-light/dark 'light
  "Nano theme uses light theme or dark theme?"
  :type 'symbol
  :group 'nano-theme)

(defun nano-theme--light?dark (light dark)
  "Determine using the LIGHT or the DARK color of nano-theme."
  (if (eq nano-theme-light/dark 'light)
      light
    dark))
(defalias '--l?d #'nano-theme--light?dark)

(defun nano-theme-toggle ()
  "Toggle between light/dark nano theme"
  (interactive)
  (if (eq nano-theme-light/dark 'light)
      (setq nano-theme-light/dark 'dark)
    (setq nano-theme-light/dark 'light))
  (mapc #'disable-theme custom-enabled-themes)
  (load-theme 'nano))

(let ((foreground (--l?d "#37474F" "#ECEFF4"))
      (background (--l?d "#FFFFFF" "#2E3440"))
      (highlight  (--l?d "#FAFAFA" "#3B4252"))
      (critical   (--l?d "#FF6F00" "#EBCB8B"))
      (salient    (--l?d "#673AB7" "#81A1C1"))
      (strong     (--l?d "#263238" "#FFFFFF"))
      (popout     (--l?d "#FFAB91" "#D08770"))
      (subtle     (--l?d "#ECEFF1" "#434C5E"))
      (faded      (--l?d "#90A4AE" "#677691")))
  (custom-theme-set-faces
   `nano
   ;; Basic
   `(default                    ((((type tty)))
                                 (((type graphic)) :background ,background :foreground ,foreground)))
   `(shadow                     ((t (:foreground ,faded))))
   `(link                       ((t (:foreground ,salient))))
   `(link-visited               ((t (:foreground ,salient))))
   `(highlight                  ((t (:background ,highlight))))
   `(match                      ((t (:foreground ,popout))))
   `(isearch                    ((t (:background ,subtle :box (:line-width (-1 . -1))))))
   `(lazy-highlight             ((t (:background ,subtle :box (:line-width (-1 . -1))))))
   `(warning                    ((t (:foreground ,popout))))
   `(success                    ((t (:foreground ,faded))))
   `(cursor                     ((t (:background ,foreground))))
   `(fringe                     ((t (:foreground ,faded))))
   `(show-paren-match           ((t (:box (:line-width (-1 . -1))))))
   `(hl-line                    ((t (:background ,highlight))))
   `(region                     ((t (:background ,subtle))))
   `(line-number                ((t (:foreground ,faded))))
   `(line-number-current-line   ((t (:foreground ,strong))))
   `(minibuffer-prompt          ((t (:foreground ,strong))))
   `(vertical-border            ((t (:foreground ,subtle))))
   `(window-divider             ((t (:foreground ,subtle))))
   `(window-divider-first-pixel ((t (:foreground ,subtle))))
   `(window-divider-last-pixel  ((t (:foreground ,subtle))))
   `(fill-column-indicator      ((t (:foreground ,strong))))
   `(trailing-whitespace        ((t (:background ,subtle))))
   `(completions-common-part    ((t (:foreground ,faded))))
   `(secondary-selection        ((t (:background ,subtle))))
   `(header-line                ((t ( :background ,subtle :foreground ,strong
                                      :box (:line-width 2 :style released-button)))))

   ;; Font Locks
   `(font-lock-comment-face           ((t (:foreground ,faded))))
   `(font-lock-comment-delimiter-face ((t (:foreground ,faded))))
   `(font-lock-keyword-face           ((t (:foreground ,salient))))
   `(font-lock-string-face            ((t (:foreground ,popout))))
   `(font-lock-doc-face               ((t (:foreground ,faded))))
   `(font-lock-builtin-face           ((t ())))
   `(font-lock-type-face              ((t ())))
   `(font-lock-variable-name-face     ((t ())))
   `(font-lock-constant-face          ((t (:foreground ,salient))))
   `(font-lock-function-name-face     ((t (:foreground ,strong :underline t))))
   `(font-lock-warning-face           ((t ())))
   `(font-lock-preprocessor-face      ((t ())))

   ;; Eldoc
   `(eldoc-highlight-function-argument ((t (:foreground ,strong :bold t))))

   ;; Outline
   `(outline-1 ((t (:foreground ,foreground :bold t :slant italic))))
   `(outline-2 ((t (:inherit outline-1))))
   `(outline-3 ((t (:inherit outline-1))))
   `(outline-4 ((t (:inherit outline-1))))
   `(outline-5 ((t (:inherit outline-1))))
   `(outline-6 ((t (:inherit outline-1))))
   `(outline-7 ((t (:inherit outline-1))))
   `(outline-8 ((t (:inherit outline-1))))

   ;; magit
   `(magit-diff-hunk-heading ((t (:background ,subtle))))

   ;; Agenda
   `(org-agenda-calendar-event   ((t (:foreground ,foreground :background ,background))))
   `(org-agenda-calendar-sexp    ((t (:foreground ,salient))))
   `(org-agenda-clocking         ((t (:foreground ,faded))))
   `(org-agenda-column-dateline  ((t (:foreground ,faded))))
   `(org-agenda-current-time     ((t (:foreground ,foreground :bold t))))
   `(org-agenda-date             ((t (:foreground ,salient))))
   `(org-agenda-date-today       ((t (:foreground ,salient :bold t))))
   `(org-agenda-date-weekend     ((t (:foreground ,faded))))
   `(org-agenda-diary            ((t (:foreground ,faded))))
   `(org-agenda-dimmed-todo-face ((t (:foreground ,faded))))
   `(org-agenda-done             ((t (:foreground ,faded))))
   `(org-agenda-filter-category  ((t (:foreground ,faded))))
   `(org-agenda-filter-effort    ((t (:foreground ,faded))))
   `(org-agenda-filter-regexp    ((t (:foreground ,faded))))
   `(org-agenda-filter-tags      ((t (:foreground ,faded))))
   `(org-agenda-restriction-lock ((t (:foreground ,faded))))
   `(org-agenda-structure        ((t (:foreground ,foreground :bold t))))

   ;; Notmuch
   `(notmuch-tag-face             ((t (:foreground ,faded))))
   `(notmuch-search-date          ((t (:foreground ,faded))))
   `(notmuch-tag-deleted          ((t (:strike-through ,popout))))
   `(notmuch-tag-added            ((t (:underline ,popout))))
   `(notmuch-wash-cited-text      ((t (:foreground ,faded))))
   `(notmuch-message-summary-face ((t (:foreground ,strong :bold t :background ,subtle))))

   ;; Mode Line
   `(mode-line          ((t ( :background ,foreground :foreground ,background))))
   `(mode-line-inactive ((t ( :background ,faded :foreground ,background))))

   ;; tab-bar
   `(tab-bar                    ((t (:background ,background :foreground ,foreground))))
   `(tab-bar-tab-group-current  ((t ())))
   `(tab-bar-tab                ((t (:inverse-video t :bold t))))
   `(tab-bar-tab-group-inactive ((t ())))
   `(tab-bar-tab-inactive       ((t (:inherit shadow))))

   ;; solaire Mode
   `(solaire-default-face             ((t (:inherit default :background ,highlight))))

   ;; Orderless
   `(orderless-match-face-0           ((t (:foreground ,strong :bold t))))
   `(orderless-match-face-1           ((t (:foreground ,strong :bold t))))
   `(orderless-match-face-2           ((t (:foreground ,strong :bold t))))
   `(orderless-match-face-3           ((t (:foreground ,strong :bold t))))

   ;; Eshell
   `(eshell-prompt                    ((t (:foreground ,popout :bold t))))

   ;; telega
   `(telega-msg-inline-reply ((t (:foreground ,faded))))
   `(telega-msg-heading      ((t (:underline t))))

   ;; which-func
   `(which-func ((t (:foreground ,highlight))))

   ;; Imenu-ist
   `(imenu-list-entry-subalist-face-0 ((t (:foreground ,strong :weight bold :underline t))))
   `(imenu-list-entry-subalist-face-1 ((t (:foreground ,salient :weight bold :underline t))))
   `(imenu-list-entry-subalist-face-2 ((t (:foreground ,popout :weight bold :underline t))))
   `(imenu-list-entry-subalist-face-3 ((t (:foreground ,critical :weight bold :underline t))))
   `(imenu-list-entry-face-0          ((t (:foreground ,strong))))
   `(imenu-list-entry-face-1          ((t (:foreground ,salient))))
   `(imenu-list-entry-face-2          ((t (:foreground ,popout))))
   `(imenu-list-entry-face-3          ((t (:foreground ,critical))))))

;;;###autoload
(and load-file-name
     (boundp 'custom-theme-load-path)
     (add-to-list 'custom-theme-load-path
                  (file-name-as-directory
                   (file-name-directory load-file-name))))

(provide-theme 'nano)

;;; nano-theme.el ends here
#+end_src
*** carbon
#+begin_src elisp :tangle themes/carbon-theme.el
;;; carbon-theme.el --- A minimal dark theme  -*- lexical-binding: t; -*-

;; Author: Shi Tianshu
;; Keywords: theme
;; Package-Requires: ((emacs "28.0.50"))
;; Version: 1.0.2

;;
;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.


;;; Commentary:

;;; This is a minimal light theme.

;;; Code:

(deftheme carbon "A minimal light theme.")

(defvar carbon-theme-header-scales '(1.0 1.0 1.0 1.0 1.0 1.0 1.0)
  "Scales for headers.")

(let ((bg "#202020")
      (fg "#A0A0A0")
      (cm "#707070")
      (rg "#024347")
      (hl "#2A2A2A")
      (lh "#0DA59B")
      (ss "#353535")
      (kw "#EEEEEE")
      (fn "#bfaa6b")
      (st "#4b9e6b")
      (str "#4a95b5")
      (num "#9466a5")
      (doc "#cc725b")
      (cur "#EFEFEF")
      (pop "#272727")
      (tb "#000000"))
  (custom-theme-set-faces
   `carbon
   ;; We don't specify default foreground/background in TTY.
   `(default                        ((((type tty)))
                                     (((type graphic)) :background ,bg :foreground ,fg)))
   ;; Basics
   `(cursor                         ((t (:background ,cur))))
   `(region                         ((t (:background ,rg :extend nil))))
   `(hl-line                        ((t (:background ,hl))))
   `(fringe                         ((t (:background ,bg))))
   `(show-paren-match               ((t (:background ,hl :box (:line-width (-1 . -1) :style nil)))))
   `(highlight                      ((t (:inverse-video t))))
   `(button                         ((t (:box (:line-width (-1 . -1))))))
   `(vertical-border                ((t ())))
   `(window-divider                 ((t (:foreground ,cm))))
   `(window-divider-first-pixel     ((t (:foreground ,cm))))
   `(window-divider-last-pixel      ((t (:foreground ,cm))))
   `(line-number                    ((t (:foreground ,cm))))
   `(line-number-current-line       ((t (:foreground ,fn :background ,hl))))
   `(completions-common-part        ((t ())))
   `(minibuffer-prompt              ((t ())))
   `(lazy-highlight                 ((t (:foreground ,lh :underline t))))
   `(compilation-info               ((t ())))
   `(compilation-warning            ((t ())))
   `(warning                        ((t ())))
   `(match                          ((t (:inverse-video t))))
   `(secondary-selection            ((t (:background ,ss :extend nil))))
   `(help-key-binding               ((t (:bold t))))
   `(shadow                         ((t (:foreground ,cm))))

   ;; ISearch
   `(isearch                        ((t (:inverse-video t))))
   `(isearch-fail                   ((t (:inverse-video t))))

   ;; Font Locks
   `(font-lock-comment-face         ((t (:foreground ,doc))))
   `(font-lock-comment-delimiter-face  ((t (:inherit font-lock-comment-face))))
   `(font-lock-string-face          ((t (:foreground ,str))))
   `(font-lock-doc-face             ((t (:foreground ,doc))))
   `(font-lock-builtin-face         ((t ())))
   `(font-lock-type-face            ((t ())))
   `(font-lock-variable-name-face   ((t ())))
   `(font-lock-keyword-face         ((((type tty)) (:bold t))
                                     (((type graphic)) (:foreground ,kw))))
   `(font-lock-constant-face        ((t (:foreground ,st))))
   `(font-lock-function-name-face   ((t (:foreground ,fn))))
   `(font-lock-warning-face         ((t ())))
   `(font-lock-preprocessor-face    ((t ())))
   `(error                          ((t (:background "red" :foreground ,fn))))

   `(highlight-numbers-number       ((t (:foreground ,num))))

   ;; shell
   `(sh-quoted-exec                 ((t ())))

   ;; IMenu
   `(imenu-list-entry-face-0          ((t ())))
   `(imenu-list-entry-subalist-face-0 ((t (:bold t))))

   ;; Mode Line
   `(tab-line                       ((t ())))
   `(mode-line                      ((t (:background ,fg :foreground ,bg))))
   `(mode-line-inactive             ((t (:background ,cm :foreground ,hl))))
   `(header-line                    ((t ())))
   `(header-line-inactive           ((t ())))

   ;; Company
   `(company-tooltip-common         ((t ())))
   `(company-tooltip-common-selection ((t ())))
   `(company-tooltip                ((t (:background ,pop))))
   `(company-tooltip-search         ((t ())))
   `(company-tooltip-selection      ((t (:inverse-video t))))
   `(company-tooltip-annotation     ((t ())))
   `(company-scrollbar-bg           ((t (:background ,cm))))
   `(company-scrollbar-fg           ((t (:background ,fg))))
   `(company-template-field         ((t (:inherit yas-field-highlight-face))))

   ;; Yasnippet
   `(yas-field-highlight-face       ((t (:underline t))))

   ;; Meow
   `(meow-beacon-indicator          ((t (:bold t))))
   `(meow-keypad-indicator          ((t (:bold t))))
   `(meow-insert-indicator          ((t (:bold t))))
   `(meow-normal-indicator          ((t (:bold t))))
   `(meow-motion-indicator          ((t (:bold t))))
   `(meow-keypad-cursor             ((t (:background ,cur))))
   `(meow-insert-cursor             ((t (:background ,cur))))
   `(meow-normal-cursor             ((t (:background ,cur))))
   `(meow-motion-cursor             ((t (:background ,cur))))
   `(meow-unknown-cursor            ((t (:background ,cur))))
   `(meow-beacon-cursor             ((t (:background ,cur))))

   ;; colorful paren
   `(colorful-round           ((t ())))
   `(colorful-square          ((t (:foreground ,str))))
   `(colorful-curly           ((t (:foreground ,st))))
   `(colorful-semicolon       ((t (:foreground ,fn))))

   ;; Cider
   `(cider-result-overlay-face      ((t (:inverse-video t))))
   `(cider-repl-stderr-face         ((t ())))
   `(cider-repl-stdout-face         ((t (:foreground "gray60"))))
   `(cider-test-error-face          ((t (:foreground "yellow" :inverse-video t))))

   ;; Clojure
   `(clojure-character-face         ((t ())))

   ;; Magit
   `(magit-branch-local                ((t (:foreground ,st))))
   `(magit-branch-remote               ((t (:foreground ,fn))))
   `(magit-header-line                 ((t ())))
   `(magit-head                        ((t ())))
   `(magit-section-highlight           ((t (:background ,hl))))
   `(magit-section-heading             ((t ())))
   `(magit-section-selection           ((t ())))
   `(magit-diff-removed                ((t (:background "#311"))))
   `(magit-diff-removed-highlight      ((t (:background "#311"))))
   `(magit-diff-added                  ((t (:background "#131"))))
   `(magit-diff-added-highlight        ((t (:background "#131"))))
   `(magit-diff-context-highlight      ((t (:background ,hl :foreground ,fg))))

   ;; ;; SMerge
   ;; `(smerge-refined-added           ((t (:background "#253325"))))
   ;; `(smerge-lower                   ((t (:background "#173017"))))
   ;;
   ;; Diff-hl
   `(diff-hl-insert                 ((t (:foreground ,cm :background ,cm))))
   `(diff-hl-change                 ((t (:foreground ,hl :background ,hl))))
   `(diff-hl-delete                 ((t (:foreground ,fg :background ,fg))))

   `(eshell-prompt                  ((t (:bold t))))
   ;;
   ;; ;; Term
   ;; `(term-color-blue                ((t (:foreground ,blue :background ,blue))))
   ;; `(term-color-green               ((t (:foreground ,green :background ,green))))
   ;; `(term-color-red                 ((t (:foreground ,red :background ,red))))
   ;;
   ;; ;; Popup
   ;; `(popup-tip-face                 ((t (:background ,bg+4 :foreground ,fg))))
   ;; `(popup-isearch-match            ((t (:background "#CFA300" :foreground "black"))))
   ;;
   ;; `(tooltip                        ((t ())))
   ;; `(dired-directory                ((t (:foreground ,light-purple))))
   ;; `(web-mode-html-attr-name-face   ((t ())))
   ;; `(web-mode-html-tag-face         ((t ())))
   ;;
   ;; Emacs Rime
   `(rime-preedit-face              ((t (:underline t))))
   `(rime-cursor-face               ((t (:inherit font-lock-constant-face))))
   `(rime-indicator-face            ((t ())))
   `(rime-indicator-dim-face        ((t ())))
   `(rime-candidate-num-face        ((t ())))
   `(rime-comment-face              ((t ())))
   `(rime-code-face                 ((t (:bold t))))
   `(rime-default-face              ((t ())))
   `(rime-highlight-candidate-face  ((t ())))

   ;;
   ;; ;; Web Mode
   `(web-mode-function-call-face    ((t ())))
   `(web-mode-function-name-face    ((t ())))
   `(web-mode-html-tag-bracket-face ((t (:inherit parenthesis))))
   `(web-mode-symbol-face           ((t ())))
   `(css-selector                   ((t ())))
   ;;
   ;; Markdown
   `(markdown-header-face-1         ((t (:underline t :height ,(nth 0 carbon-theme-header-scales)))))
   `(markdown-header-face-2         ((t (:underline t :height ,(nth 1 carbon-theme-header-scales)))))
   `(markdown-header-face-3         ((t (:underline t :height ,(nth 2 carbon-theme-header-scales)))))
   `(markdown-header-face-4         ((t (:underline t :height ,(nth 3 carbon-theme-header-scales)))))
   `(markdown-header-face-5         ((t (:underline t :height ,(nth 4 carbon-theme-header-scales)))))
   `(markdown-header-face-6         ((t (:underline t :height ,(nth 5 carbon-theme-header-scales)))))
   `(markdown-header-face-7         ((t (:underline t :height ,(nth 6 carbon-theme-header-scales)))))
   ;;
   ;; ;; Telega
   `(telega-entity-type-code        ((t ())))
   `(telega-msg-heading             ((t ())))
   `(telega-msg-self-title          ((t (:foreground ,fn))))
   `(telega-unmuted-count           ((t ())))
   ;;
   ;; ;; Org-mode
   `(org-document-title             ((t (:bold t :height ,(nth 0 carbon-theme-header-scales)))))
   `(org-link                       ((t (:underline t))))
   `(org-document-title             ((t ())))
   `(org-code                       ((t (:inherit font-lock-constant-face))))
   `(org-level-1                    ((t (:inherit font-lock-string-face :height ,(nth 0 carbon-theme-header-scales)))))
   `(org-level-2                    ((t (:inherit font-lock-function-name-face :height ,(nth 1 carbon-theme-header-scales)))))
   `(org-level-3                    ((t (:inherit font-lock-keyword-face :height ,(nth 2 carbon-theme-header-scales)))))
   `(org-level-4                    ((t (:height ,(nth 3 carbon-theme-header-scales)))))
   `(org-level-5                    ((t (:height ,(nth 4 carbon-theme-header-scales)))))
   `(org-level-6                    ((t (:height ,(nth 5 carbon-theme-header-scales)))))
   `(org-level-7                    ((t (:height ,(nth 6 carbon-theme-header-scales)))))
   ;;
   ;; ;; Treemacs
   ;; `(treemacs-root-face             ((t (:inherit font-lock-function-name-face :height 1.4 :underline t))))
   `(fill-column-indicator          ((t (:foreground ,cm))))
   `(scroll-bar                     ((t (:foreground ,fg))))
   `(parenthesis                    ((t (:foreground ,cm))))
   `(eldoc-box-body                 ((t (:background ,pop :inherit variable-pitch))))

   `(flycheck-warning               ((t (:underline (:style wave :color ,cm)))))
   `(flycheck-error                 ((t (:underline (:style wave :color ,st)))))
   `(flymake-warning                ((t (:underline (:style wave :color ,st)))))
   `(flymake-error                  ((t (:underline (:style wave :color ,st)))))
   `(flymake-note                   ((t (:underline (:style wave :color ,cm)))))

   `(wgrep-face                     ((t (:underline ,st))))

   `(anzu-mode-line                 ((t (:foreground ,bg :background ,fg))))
   `(erc-nick-default-face          ((t (:inherit font-lock-keyword-face))))
   `(erc-input-face                 ((t (:inherit font-lock-function-name-face))))
   `(erc-timestamp-face             ((t (:inherit font-lock-constant-face))))
   `(erc-notice-face                ((t (:inherit font-lock-comment-face))))

   `(tab-bar                        ((t (:background ,fg :foreground ,bg))))
   `(tab-bar-tab                    ((t (:inverse-video t :bold t))))
   `(tab-bar-tab-inactive           ((t ())))

   `(ansi-color-blue                ((t (:foreground "#169edd"))))
   `(ansi-color-bright-blue         ((t (:foreground "#169edd"))))
   `(yascroll:thumb-fringe          ((t (:foreground ,cm :background ,cm))))
   `(yascroll:thumb-text-area       ((t (:foreground ,cm :background ,cm))))

   `(embark-keybinding              ((t (:inherit font-lock-constant-face))))))

(and load-file-name
     (boundp 'custom-theme-load-path)
     (add-to-list 'custom-theme-load-path
                  (file-name-as-directory
                   (file-name-directory load-file-name))))

(provide-theme 'carbon)

;;; carbon-theme.el ends here
#+end_src
*** default
#+begin_src elisp :tangle themes/default-theme.el
(deftheme default "Emacs default theme, better version.")

(defvar my-bg-light "#F5F5F5"
  "Light background color, from minder-theme.")

;; TODO
(defvar my-bg-dark "#282c34"
  "Dark background color, from atom-one-dark.
See https://github.com/atom/atom/blob/master/packages/one-dark-syntax/styles/colors.less.")

(custom-theme-set-faces
 `default
 ;; basic
 `(default           ((((type tty)))
                      (((type graphic)) :background ,my-bg-light)))
 `(fringe            ((t (:inherit default))))
 `(cursor            ((t (:background "black"))))
 `(highlight         ((t (:background "#CFD8DC"))))
 '(minibuffer-prompt ((t ())))

 ;; Font Locks
 `(font-lock-comment-face           ((t (:foreground "#90A4AE" :slant italic))))
 `(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face))))
 `(font-lock-doc-face               ((t (:inherit font-lock-comment-face))))
 `(font-lock-string-face            ((t ())))
 `(font-lock-builtin-face           ((t ())))
 `(font-lock-type-face              ((t ())))
 `(font-lock-variable-name-face     ((t ())))
 `(font-lock-keyword-face           ((t ())))
 `(font-lock-constant-face          ((t ())))
 `(font-lock-function-name-face     ((t (:bolt t :underline t))))
 `(font-lock-warning-face           ((t (:inherit warning))))
 `(font-lock-preprocessor-face      ((t ())))

 ;; org-mode
 `(org-level-1 ((t ())))
 `(org-level-2 ((t (:inherit org-level-1))))
 `(org-level-3 ((t (:inherit org-level-1))))
 `(org-level-4 ((t (:inherit org-level-1))))
 `(org-level-5 ((t (:inherit org-level-1))))
 `(org-level-6 ((t (:inherit org-level-1))))
 `(org-level-7 ((t (:inherit org-level-1))))
 `(org-level-8 ((t (:inherit org-level-1))))

 ;; mode-line
 `(mode-line          ((t (:foreground "black" :background "grey75"))))
 `(mode-line-inactive ((t (:foreground "#535c65" :background "#e3e5e8" :weight light))))
 )

(and load-file-name
     (boundp 'custom-theme-load-path)
     (add-to-list 'custom-theme-load-path
                  (file-name-as-directory
                   (file-name-directory load-file-name))))

(provide-theme 'default)
#+end_src
*** grayscale
#+begin_src elisp :tangle themes/grayscale-theme.el
;;; grayscale-theme.el --- A gray light theme  -*- lexical-binding: t; -*-

;; Author: Shi Tianshu
;; Keywords: theme
;; Package-Requires: ((emacs "28.0.50"))
;; Version: 1.0.2

;;
;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.


;;; Commentary:

;;; This is a minimal gray light theme.

;;; Code:

(deftheme grayscale "A minimal light theme.")

(defvar grayscale-theme-header-scales '(1.4 1.4 1.2 1.0 1.0 1.0 1.0)
  "Scales for headers.")

(setq awesome-tray-mode-line-active-color "#353535"
      awesome-tray-mode-line-inactive-color "#a9bdb5")

(let ((bg "#c4d3cd")
      (fg "#353535")
      (kw "#000000")
      (cm "#61726b")
      (ss "#96b0a5")
      (hl "#a9bdb5")
      (fn "#b6c6c0")
      (cur "#202020"))
  (custom-theme-set-faces
   `grayscale
   ;; We don't specify default foreground/background in TTY.
   `(default                        ((((type tty)))
                                     (((type graphic)) :background ,bg :foreground ,fg)))
   ;; Basics
   `(cursor                         ((t (:background ,cur))))
   `(region                         ((t (:background ,hl))))
   `(hl-line                        ((t)))
   `(fringe                         ((t (:background ,bg))))
   `(show-paren-match               ((t (:box (:line-width (-1 . -1))))))
   `(highlight                      ((t (:inverse-video t))))
   `(button                         ((t (:box (:line-width (-1 . -1))))))
   `(vertical-border                ((t ())))
   `(window-divider                 ((t (:foreground ,cm))))
   `(window-divider-first-pixel     ((t (:foreground ,cm))))
   `(window-divider-last-pixel      ((t (:foreground ,cm))))
   `(line-number                    ((t (:foreground ,cm))))
   `(line-number-current-line       ((t (:foreground ,fg))))
   `(parenthesis                    ((t (:foreground ,fg))))
   `(completions-common-part        ((t ())))
   `(minibuffer-prompt              ((t ())))
   `(lazy-highlight                 ((t (:foreground ,fg :box (:line-width (-1 . -1))))))
   `(compilation-info               ((t ())))
   `(compilation-warning            ((t ())))
   `(warning                        ((t ())))
   `(match                          ((t (:foreground ,fg :box (:line-width (-1 . -1))))))
   `(secondary-selection            ((t (:background ,ss))))
   `(help-key-binding               ((t ())))
   `(shadow                         ((t (:foreground ,cm))))

   ;; ISearch
   `(isearch                        ((t (:inverse-video t))))
   `(isearch-fail                   ((t (:inverse-video t))))

   ;; Font Locks
   `(font-lock-comment-face         ((t (:foreground ,cm :italic t))))
   `(font-lock-comment-delimiter-face         ((t (:foreground ,cm :italic t))))
   `(font-lock-string-face          ((t (:foreground ,cm))))
   `(font-lock-doc-face             ((t (:foreground ,cm))))
   `(font-lock-builtin-face         ((t ())))
   `(font-lock-type-face            ((t ())))
   `(font-lock-variable-name-face   ((t ())))
   `(font-lock-keyword-face         ((t (:bold t))))
   `(font-lock-constant-face        ((t (:italic t))))
   `(font-lock-function-name-face   ((t (:background ,fn))))
   `(font-lock-warning-face         ((t ())))
   `(font-lock-preprocessor-face    ((t ())))

   ;; shell
   `(sh-quoted-exec                 ((t ())))

   ;; IMenu
   `(imenu-list-entry-face-0          ((t ())))
   `(imenu-list-entry-subalist-face-0 ((t (:bold t))))

   ;; Mode Line
   `(tab-line                       ((t ())))
   `(mode-line                      ((t (:inverse-video t))))
   `(mode-line-inactive             ((t (:background ,hl))))
   `(header-line                    ((t ())))
   `(header-line-inactive           ((t ())))

   ;; Company
   `(company-tooltip-common         ((t ())))
   `(company-tooltip-common-selection ((t (:bold t))))
   `(company-tooltip                ((t (:background ,hl))))
   `(company-tooltip-search         ((t ())))
   `(company-tooltip-selection      ((t (:inverse-video t))))
   `(company-tooltip-annotation     ((t ())))
   `(company-scrollbar-bg           ((t (:background ,bg))))
   `(company-scrollbar-fg           ((t (:background ,fg))))
   `(company-template-field         ((t (:inherit yas-field-highlight-face))))

   ;; Yasnippet
   `(yas-field-highlight-face       ((t (:background ,hl))))

   ;; Meow
   `(meow-keypad-indicator          ((t (:bold t))))
   `(meow-insert-indicator          ((t (:bold t))))
   `(meow-normal-indicator          ((t (:bold t))))
   `(meow-motion-indicator          ((t (:bold t))))
   `(meow-beacon-indicator          ((t (:bold t))))
   `(meow-keypad-cursor             ((t ())))
   `(meow-insert-cursor             ((t ())))
   `(meow-normal-cursor             ((t ())))
   `(meow-motion-cursor             ((t ())))
   `(meow-beacon-cursor             ((t ())))

   ;; colorful paren
   `(colorful-round           ((t (:foreground ,cm))))
   `(colorful-square          ((t ())))
   `(colorful-curly           ((t ())))

   ;; Cider
   `(cider-result-overlay-face      ((t (:inverse-video t))))
   `(cider-repl-stderr-face         ((t (:bold t))))
   `(cider-repl-stdout-face         ((t ())))

   ;; Clojure
   `(clojure-character-face         ((t ())))

   ;; Magit
   ;; `(magit-diff-file-heading-highlight ((t (:background ,bg+1))))
   `(magit-branch-current              ((t (:box t :background ,hl))))
   `(magit-branch-local                ((t (:background ,hl))))
   `(magit-branch-remote               ((t (:background ,cm :foreground ,bg))))
   `(magit-branch-remote-head          ((t (:box t :background ,cm :foreground ,bg))))
   `(magit-header-line                 ((t (:bold t))))
   `(magit-head                        ((t ())))
   `(magit-section-highlight           ((t (:background ,hl))))
   `(magit-section-heading             ((t (:bold t))))
   `(magit-section-selection           ((t (:bold t))))
   `(magit-diff-hunk-heading-highlight ((t (:inverse-video t))))
   `(magit-diff-hunk-heading ((t (:foreground ,cm))))
   `(magit-diff-removed             ((t ())))
   `(magit-diff-added               ((t ())))
   `(magit-diff-removed-highlight   ((t (:background ,hl))))
   `(magit-diff-added-highlight     ((t (:background ,cm :foreground ,bg))))
   `(magit-diff-highlight           ((t ())))
   `(magit-diff-context-highlight   ((t ())))
   ;;
   ;; ;; SMerge
   ;; `(smerge-refined-added           ((t (:background "#253325"))))
   ;; `(smerge-lower                   ((t (:background "#173017"))))
   ;;
   ;; Diff-hl
   `(diff-hl-insert                 ((t (:foreground ,cm :background ,cm))))
   `(diff-hl-change                 ((t (:foreground ,hl :background ,hl))))
   `(diff-hl-delete                 ((t (:foreground ,fg :background ,fg))))

   `(eshell-prompt                  ((t (:bold t))))
   ;;
   ;; ;; Term
   ;; `(term-color-blue                ((t (:foreground ,blue :background ,blue))))
   ;; `(term-color-green               ((t (:foreground ,green :background ,green))))
   ;; `(term-color-red                 ((t (:foreground ,red :background ,red))))
   ;;
   ;; ;; Popup
   ;; `(popup-tip-face                 ((t (:background ,bg+4 :foreground ,fg))))
   ;; `(popup-isearch-match            ((t (:background "#CFA300" :foreground "black"))))
   ;;
   `(tooltip                        ((t ())))
   `(dired-directory                ((t (:bold t))))
   `(web-mode-html-attr-name-face   ((t ())))
   `(web-mode-html-tag-face         ((t ())))

   ;; Emacs Rime
   `(rime-preedit-face              ((t (:underline t))))
   `(rime-cursor-face               ((t (:inherit font-lock-constant-face))))
   `(rime-indicator-face            ((t ())))
   `(rime-indicator-dim-face        ((t ())))
   `(rime-candidate-num-face        ((t ())))
   `(rime-comment-face              ((t (:inherit font-lock-comment))))
   `(rime-code-face                 ((t (:bold t))))
   `(rime-default-face              ((t ())))
   `(rime-highlight-candidate-face  ((t ())))

   ;;
   ;; ;; Web Mode
   `(web-mode-function-call-face    ((t ())))
   `(web-mode-function-name-face    ((t ())))
   `(web-mode-html-tag-bracket-face ((t (:inherit parenthesis))))
   `(web-mode-symbol-face           ((t (:inherit font-lock-constant-face))))
   `(web-mode-doctype-face          ((t (:inherit shadow))))
   ;; `(css-selector                   ((t (:foreground ,purple))))
   ;;
   ;; ;; Markdown
   `(markdown-header-face-1         ((t (:bold t :height ,(nth 0 grayscale-theme-header-scales)))))
   `(markdown-header-face-2         ((t (:bold t :height ,(nth 1 grayscale-theme-header-scales)))))
   `(markdown-header-face-3         ((t (:bold t :height ,(nth 2 grayscale-theme-header-scales)))))
   `(markdown-header-face-4         ((t (:bold t :height ,(nth 3 grayscale-theme-header-scales)))))
   `(markdown-header-face-5         ((t (:bold t :height ,(nth 4 grayscale-theme-header-scales)))))
   `(markdown-header-face-6         ((t (:bold t :height ,(nth 5 grayscale-theme-header-scales)))))
   `(markdown-header-face-7         ((t (:bold t :height ,(nth 6 grayscale-theme-header-scales)))))
   ;;
   ;; ;; Telega
   `(telega-entity-type-code        ((t ())))
   `(telega-msg-heading             ((t ())))
   `(telega-unmuted-count           ((t ())))
   ;;
   ;; ;; Org-mode
   `(org-document-title             ((t (:bold t :height ,(nth 0 grayscale-theme-header-scales)))))
   `(org-link                       ((t (:underline t))))
   `(org-document-title             ((t ())))
   `(org-code                       ((t (:inherit font-lock-constant-face))))
   `(org-level-1                    ((t (:bold t :height ,(nth 0 grayscale-theme-header-scales)))))
   `(org-level-2                    ((t (:bold t :height ,(nth 1 grayscale-theme-header-scales)))))
   `(org-level-3                    ((t (:bold t :height ,(nth 2 grayscale-theme-header-scales)))))
   `(org-level-4                    ((t (:bold t :height ,(nth 3 grayscale-theme-header-scales)))))
   `(org-level-5                    ((t (:bold t :height ,(nth 4 grayscale-theme-header-scales)))))
   `(org-level-6                    ((t (:bold t :height ,(nth 5 grayscale-theme-header-scales)))))
   `(org-level-7                    ((t (:bold t :height ,(nth 6 grayscale-theme-header-scales)))))
   `(org-todo                       ((t (:bold t))))
   `(org-done                       ((t (:bold t :inherit shadow))))
   `(org-headline-done              ((t (:inherit shadow))))
   `(org-drawer                     ((t (:foreground ,cm))))

   ;; ;; Treemacs
   `(fill-column-indicator          ((t (:foreground ,cm))))
   `(scroll-bar                     ((t (:foreground ,fg))))
   `(sp-pair-overlay-face           ((t (:background ,hl))))
   `(sp-wrap-overlay-face           ((t (:background ,hl))))

   `(flycheck-warning ((t (:underline (:style wave :color ,cm)))))
   `(flycheck-error   ((t (:underline (:style wave :color ,fg)))))
   `(flymake-warning  ((t (:underline (:style wave :color ,cm)))))
   `(flymake-error    ((t (:underline (:style wave :color ,fg)))))
   `(flymake-note     ((t (:underline (:style wave :color ,hl)))))


   `(tab-bar                        ((t (:background ,hl))))
   `(tab-bar-tab-group-current      ((t ())))
   `(tab-bar-tab                    ((t (:bold t))))
   `(tab-bar-tab-group-inactive     ((t ())))
   `(tab-bar-tab-inactive           ((t (:bold nil :inherit shadow))))

   `(yascroll:thumb-fringe          ((t (:foreground ,cm :background ,cm))))
   `(yascroll:thumb-text-area       ((t (:foreground ,cm :background ,cm))))))

(and load-file-name
     (boundp 'custom-theme-load-path)
     (add-to-list 'custom-theme-load-path
                  (file-name-as-directory
                   (file-name-directory load-file-name))))

(provide-theme 'grayscale)

;;; grayscale-theme.el ends here
#+end_src
