#+STARTUP: fold
#+PROPERTY: header-args :tangle init.el :mkdirp yes

* Basic
** Early init
#+begin_src elisp :tangle early-init.el
(setq frame-inhibit-implied-resize t
      package-enable-at-startup nil
      file-name-handler-alist nil
      message-log-max 16384
      gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6
      default-frame-alist '((scroll-bar-mode . 0)
                            (vertical-scroll-bars . nil)
                            ;; (undecorated . t)
                            (menu-bar-lines . 0)
                            (tool-bar-lines . 0))
      ;; disable native compilation
      native-comp-jit-compilation nil)
#+end_src

** Load custom file
#+begin_src elisp
;;; -*- lexical-binding: t -*-
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (and (file-exists-p custom-file) (file-readable-p custom-file))
  (load custom-file :no-error :no-message))
#+end_src
** Package manager
#+begin_src emacs-lisp
(setq package-archives '(("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
			             ("nongnu" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/")
                         ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"))
      package-quickstart t)
(package-activate-all)

(defmacro eat/pkg (package &optional vc)
  `(unless (package-installed-p ',package)
     (unless (memq ',package package-archive-contents)
       (package-refresh-contents))
     (if ,vc (package-vc-install ,vc)
       (package-install ',package))))

(eat/pkg elpa-mirror)
(setq elpamr-default-output-directory "~/Sync/myelpa")
#+end_src

** Key binding
#+begin_src emacs-lisp
(eat/pkg bind)

;; bind `describe-keymap', added in emacs 28
(keymap-global-set "C-h C-k" #'describe-keymap)
;; this will stuck emacs
(keymap-global-unset "C-h h")
#+end_src
** Hook
#+begin_src elisp
(defun eat/hook (hook function)
  "Add hooks FUNCTION to HOOK.
If FUNCTION is a list, then add all FUNCTION hooks to HOOK.
If HOOK is a list, then add all FUNCTION hooks to HOOK."
  (cond
   ((and (listp hook) (listp function))
    (dolist (h hook)
      (dolist (f function)
        (add-hook h f))))
   ((listp hook)
    (dolist (h hook)
      (add-hook h function)))
   ((listp function)
    (dolist (f function)
      (add-hook hook f)))
   (t
    (add-hook hook function))))

;; Disable cursor blink
(add-hook 'after-init-hook (lambda () (blink-cursor-mode -1)))
#+end_src
** Variables
#+begin_src elisp
(defvar eat/user-full-name "Liu Bo")
(defvar eat/user-mail-address "liubolovelife@gmail.com")

(defconst eat/macp (eq system-type 'darwin)
  "Are we running on a Mac system?")

(defconst eat/linuxp (eq system-type 'gnu/linux)
  "Are we running on a GNU/Linux system?")

(defconst eat/winp (eq system-type 'windows-nt)
  "Are we running on a Windows system?")

;; Don't ping things that look like domain names.
(setq ffap-machine-p-known 'reject)

(setq dired-mouse-drag-files t
      mouse-drag-and-drop-region t
      mouse-drag-and-drop-region-cross-program t)

;; Contrary to what many Emacs users have in their configs, you don't need
;; more than this to make UTF-8 the default coding system:
(set-language-environment "UTF-8")

;; Do not show cursor in nonselected windows
(setq-default cursor-in-non-selected-windows nil)

;; Suppress GUI features and more
(setq inhibit-splash-screen t ;; 这个和 `inhibit-startup-screen' 有什么区别吗
      inhibit-x-resources t
      inhibit-default-init t
      inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-buffer-menu t)

(setq redisplay-skip-fontification-on-input t)

;; Pixelwise resize
(setq ;; window-resize-pixelwise nil ;; NOTE this cause lsp-bridge-ref buffer didn't show
 frame-resize-pixelwise t)

;; Shut up!
(defun display-startup-echo-area-message()
  (message nil))

;; indent with whitespace by default
(setq-default
 tab-width 4
 indent-tabs-mode nil)

;; Disable default auto backup and save file
(setq-default
 create-lockfiles nil                               ; Don't create lockfiles
 make-backup-files nil                              ; Disable auto save and backup
 auto-save-default nil
 auto-save-list-file-prefix nil)

(setq
 initial-scratch-message (concat ";; Happy hacking, " user-login-name " - Emacs ♥ you!\n\n")
 initial-major-mode 'fundamental-mode               ; Don't use prog-mode an stratup
 ring-bell-function 'ignore
 read-process-output-max (* 4 1024 1024)
 suggest-key-bindings nil                           ; Disable "You can run the command balabala..."
 word-wrap-by-category t                            ; Emacs 之光！
 use-short-answers t                                ; yse-or-no -> y-or-n
 suggest-key-bindings nil
 enable-recursive-minibuffers t
 )

(setq-default
 inhibit-compacting-font-caches t                   ; Don’t compact font caches during GC.
 require-final-newline t                            ; add final newline
 visible-cursor t
 bidi-inhibit-bpa t                                 ; Improve long line display performance
 bidi-paragraph-direction 'left-to-right
 echo-keystrokes 0.01                               ; don't wait for keystrokes display
 warning-suppress-log-types '((comp))               ; Don't display compile warnings
 truncate-partial-width-windows 65                  ; Don't truncate lines in a window narrower than 65 chars.
 vc-follow-symlinks t                               ; always follow link
 server-client-instructions nil                     ; no client startup messages
 )

;; https://github.com/Genivia/ugrep#using-ugrep-within-emacs
(setq-default grep-template "ugrep -0Iinr -e <R>")
#+end_src
** Module
#+begin_src emacs-lisp
(defvar eat/module-list
  `(
    ;; +icon
    ;; +blog
    ;; +telega
    ;; +note-taking
    ))

(defvar eat/module--hash-table
  ((lambda ()
     (setq hash--table (make-hash-table))
     (dolist (m eat/module-list)
       (puthash m t hash--table))
     hash--table)))

(defun eat/modulep (module)
  (gethash module eat/module--hash-table))
#+end_src
** Optimization
*** TODO on.el
Some of hook of this packgae is too hacked, maybe drop it.
#+begin_src emacs-lisp
(eat/pkg on "https://gitlab.com/ajgrf/on.el")
(require 'on)
#+end_src

*** garbage collection
#+begin_src elisp
(eat/pkg gcmh)
(add-hook 'after-init-hook #'gcmh-mode)
(setq gcmh-idle-delay 5
      gcmh-high-cons-threshold #x6400000)

;; GC automatically while unfocusing the frame
(add-function :after after-focus-change-function
              (lambda ()
                (unless (frame-focus-state)
                  (garbage-collect))))
#+end_src

*** Show start up time
#+begin_src elisp
(defun eat/show-startup-time ()
  "Print startup time."
  (message
   "Emacs loaded in %s with %d garbage collections."
   (format
    "%.2f seconds"
    (float-time
     (time-subtract after-init-time before-init-time)))
   gcs-done))
(add-hook 'emacs-startup-hook #'eat/show-startup-time)
#+end_src

** PATH
#+begin_src elisp
;;; Setup PATH
;; https://emacs-china.org/t/emacs-mac-port-profile/2895/29?u=rua
;; NOTE: When PATH is changed, run the following command
;; $ sh -c 'printf "%s" "$PATH"' > ~/.path
;; then add this to custom.el
;; (add-hook 'after-init-hook #'eat/getenv-path)
(defun eat/getenv-path()
  (interactive)
  (condition-case err
      (let ((path (with-temp-buffer
                    (insert-file-contents-literally "~/.path")
                    (buffer-string))))
        (setenv "PATH" path)
        (setq exec-path (append (parse-colon-path path) (list exec-directory))))
    (error (warn "%s" (error-message-string err)))))
#+end_src

** MacOS
#+begin_src elisp
(when eat/macp
  (setq mac-option-modifier 'meta
        mac-command-modifier 'super
        ;; Render thinner fonts
        ns-use-thin-smoothing t
        ;; Don't open a file in a new frame
        ns-pop-up-frames nil)

  (add-hook 'after-init-hook #'eat/getenv-path)

  (global-set-key [(super a)] #'mark-whole-buffer)
  (global-set-key [(super v)] #'yank)
  (global-set-key [(super c)] #'kill-ring-save)
  (global-set-key [(super s)] #'save-buffer)
  (global-set-key [(super l)] #'goto-line)
  (global-set-key [(super w)] #'delete-frame)
  (global-set-key [(super z)] #'undo)
  ;; `save-buffers-kill-emacs' will shutdown emacs daemon
  (global-set-key [(super q)] #'save-buffers-kill-terminal))
#+end_src

** Linux
#+begin_src elisp
(when eat/linuxp
  (setq x-underline-at-descent-line t)
  (setq-default
   ;; Don't use Fcitx5 in Emacs in PGTK build
   pgtk-use-im-context-on-new-connection nil
   x-gtk-resize-child-frames nil)

  ;; Don't use GTK+ tooltip
  (when (boundp 'x-gtk-use-system-tooltips)
    (setq x-gtk-use-system-tooltips nil)))
#+end_src

** Dvorak
#+begin_src elisp
;; Make “C-t” act like “C-x”, so it's easier to type on Dvorak layout
;; (keyboard-translate ?\C-t ?\C-x)
;; (keyboard-translate ?\C-x ?\C-t)
#+end_src

** Built-in packages
*** recentf
#+begin_src emacs-lisp
(add-hook 'on-first-input-hook #'recentf-mode)
(setq recentf-max-saved-items 1000
      recentf-exclude `(,tramp-file-name-regexp
                        "COMMIT_EDITMSG"))
(keymap-global-set "C-x C-r" #'recentf-open-files)
#+end_src

*** webjump
#+begin_src emacs-lisp
(keymap-global-set "C-x C-/" #'webjump)
(setq webjump-sites
      '(("Emacs Wiki" . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" #1=""])
        ("Emacs China" . "emacs-china.org")
        ("Emacs Reddit" . "www.reddit.com/r/emacs/")
        ("Emacs News" . "sachachua.com/blog/category/emacs-news/")
        ("Github" . [simple-query "github.com" "github.com/search?q=" #1#])
        ("Google" . [simple-query "google.com" "google.com/search?q=" #1#])
        ("Youtube" . [simple-query "youtube.com" "youtube.com/results?search_query=" #1#])
        ("Google Groups" . [simple-query "groups.google.com" "groups.google.com/groups?q=" #1#])
        ("stackoverflow" . [simple-query "stackoverflow.com" "stackoverflow.com/search?q=" #1#])
        ("Wikipedia" . [simple-query "wikipedia.org" "wikipedia.org/wiki/" #1#])))
#+end_src

*** repeat
#+begin_src emacs-lisp
(setq repeat-mode t
      repeat-keep-prefix t
      repeat-exit-timeout 3
      repeat-exit-key (kbd "RET"))
#+end_src

*** context-menu
#+begin_src emacs-lisp
(add-hook 'on-init-ui-hook #'context-menu-mode)
#+end_src

*** project.el
#+begin_src elisp
;; go to the end of buffer after `project-compile'
(add-hook 'compilation-start-hook #'end-of-buffer)

(defun eat/project-name ()
  (file-name-nondirectory
   (directory-file-name
    (project-root
     (project-current)))))

;; do not remember tramp project
(defun eat/project-remember-advice (fn pr &optional no-write)
  (let* ((remote? (file-remote-p (project-root pr)))
         (no-write (if remote? t no-write)))
    (funcall fn pr no-write)))
(advice-add 'project-remember-project :around
            'eat/project-remember-advice)

(with-eval-after-load 'project

  ;; use fd in `project-find-file'
  (defun eat/project-files-in-directory (dir)
    "Use `fd' to list files in DIR."
    (let* ((default-directory dir)
           (localdir (file-local-name (expand-file-name dir)))
           (command (format "fd -c never -H -t f -0 . %s" localdir)))
      (project--remote-file-names
       (sort (split-string (shell-command-to-string command) "\0" t)
             #'string<))))
  (when (executable-find "fd")
    (cl-defmethod project-files ((project (head local)) &optional dirs)
      "Override `project-files' to use `fd' in local projects."
      (mapcan #'eat/project-files-in-directory
              (or dirs (list (project-root project))))))

  (setq project-vc-ignores '("target/" "bin/" "obj/")
        project-vc-extra-root-markers '(".project"
                                        "go.mod"
                                        "Cargo.toml"
                                        "project.clj"
                                        "pom.xml"
                                        "package.json"
                                        "Makefile"
                                        "README.org"
                                        "README.md")))
#+end_src

*** TODO xref
Must set before consult.
Use control-left-click to jump to defintions.
Need ugrep installed(check external program).

Set cursor pos to mouse pos if they are not in same pos.
#+begin_src elisp
(add-hook 'xref-after-return-hook #'recenter)
(add-hook 'xref-after-jump-hook #'recenter)

(keymap-global-unset "C-<down-mouse-1>")
(keymap-global-set "C-<mouse-1>" #'xref-find-definitions-at-mouse)

(setq xref-prompt-for-identifier nil
      ;; Commands such as `project-find-regexp' that rely on Xref can now leverage the power of ugrep.
      xref-search-program 'ugrep
      xref-show-xrefs-function #'xref-show-definitions-completing-read
      xref-show-definitions-function #'xref-show-definitions-completing-read
      ;; fix massed xref cross multiple project
      xref-history-storage 'xref-window-local-history)
#+end_src

* Lib

#+begin_src elisp
(eat/pkg fullframe)
(eat/pkg hide-mode-line)
(eat/pkg pinyinlib)
(autoload #'pinyinlib-build-regexp-string "pinyinlib")
#+end_src

* TODO Frame

Some config need these hooks to work in emacsclient, like code or theme.

#+begin_src elisp
(defvar eat/after-make-console-frame-hooks '()
  "Hooks to run after creating a new TTY frame")
(defvar eat/after-make-window-system-frame-hooks '()
  "Hooks to run after creating a new window-system frame")

(defun eat/run-after-make-frame-hooks (frame)
  "Run configured hooks in response to the newly-created FRAME.
Selectively runs either `eat/after-make-console-frame-hooks' or
`eat/after-make-window-system-frame-hooks'"
  (with-selected-frame frame
    (run-hooks (if window-system
                   'eat/after-make-window-system-frame-hooks
                 'eat/after-make-console-frame-hooks))))

;; FIXME font and theme not work
;; (add-hook 'server-after-make-frame-hook 'eat/run-after-make-frame-hooks)

(defconst eat/initial-frame (selected-frame)
  "The frame (if any) active during Emacs initialization.")

(add-hook 'after-init-hook
          (lambda () (when eat/initial-frame
                       (eat/run-after-make-frame-hooks eat/initial-frame))))
#+end_src

* Window
** Helper funcs
#+begin_src emacs-lisp
(defun eat/quit ()
  "Delete current window switch to prevous buffer."
  (interactive)
  (if (> (seq-length (window-list (selected-frame))) 1)
      (delete-window)
    (previous-buffer)))
#+end_src
** TODO tab-bar
#+begin_src elisp
(defun eat/tab-bar-tab-name-format-function (tab i)
  (let ((current-p (eq (car tab) 'current-tab)))
    (concat
     (propertize (concat
                  " "
                  (alist-get 'name tab)
                  " ")
                 'face
                 (funcall tab-bar-tab-face-function tab))
     " ")))

(defun eat/tab-bar-switch-project ()
  "Switch to project in a new tab, project name will be used as tab name.

No tab will created if the command is cancelled."
  (interactive)
  (let (succ)
    (unwind-protect
        (progn
          (tab-bar-new-tab)
          (call-interactively #'project-switch-project)
          (when-let ((proj (project-root (project-current))))
            (tab-bar-rename-tab (format "%s" (file-name-nondirectory (directory-file-name proj))))
            (setq succ t)))
      (unless succ
        (tab-bar-close-tab)))))

(add-hook 'tab-bar-mode-hook
          #'(lambda ()
              (setq tab-bar-border nil
                    tab-bar-close-button nil ;; TODO this make tab face wired
                    tab-bar-new-button (propertize " 🞤 " 'display '(:height 2.0))
                    tab-bar-back-button nil
                    tab-bar-tab-name-format-function 'eat/tab-bar-tab-name-format-function
                    tab-bar-tab-name-truncated-max 10)))

(with-eval-after-load 'tab-bar
  ;; FIXME 这会导致焦点在 tui emacs 和其他程序切换时自动输入 IO
  ;; (keymap-global-set "M-[" #'tab-bar-switch-to-prev-tab)
  ;; (keymap-global-set "M-]" #'tab-bar-switch-to-next-tab)

  (keymap-set tab-prefix-map "." #'tab-bar-switch-to-recent-tab)
  (keymap-set tab-prefix-map "," #'tab-bar-rename-tab)
  (keymap-set tab-prefix-map "l" #'eat/tab-bar-switch-project))
#+end_src

** Change Default Behavior of Split Window
#+begin_src elisp
;; When splitting window, show (other-buffer) in the new window

(defun split-window-func-with-other-buffer (split-function)
  (lambda (&optional arg)
    "Split this window and switch to the new window unless ARG is provided."
    (interactive "P")
    (funcall split-function)
    (let ((target-window (next-window)))
      (set-window-buffer target-window (other-buffer))
      (unless arg
        (select-window target-window)))))

(keymap-global-set "C-x 2" (split-window-func-with-other-buffer 'split-window-vertically))
(keymap-global-set "C-x 3" (split-window-func-with-other-buffer 'split-window-horizontally))

(defun sanityinc/toggle-delete-other-windows ()
  "Delete other windows in frame if any, or restore previous window config."
  (interactive)
  (if (and winner-mode
           (equal (selected-window) (next-window)))
      (winner-undo)
    (delete-other-windows)))

(keymap-global-set "C-x 1" 'sanityinc/toggle-delete-other-windows)
#+end_src
** Rearrange Split Winows
#+begin_src elisp
(defun split-window-horizontally-instead ()
  "Kill any other windows and re-split such that the current window is on the top half of the frame."
  (interactive)
  (let ((other-buffer (and (next-window) (window-buffer (next-window)))))
    (delete-other-windows)
    (split-window-horizontally)
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun split-window-vertically-instead ()
  "Kill any other windows and re-split such that the current window is on the left half of the frame."
  (interactive)
  (let ((other-buffer (and (next-window) (window-buffer (next-window)))))
    (delete-other-windows)
    (split-window-vertically)
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(keymap-global-set "C-x |" 'split-window-horizontally-instead)
(keymap-global-set "C-x _" 'split-window-vertically-instead)
#+end_src
** winner
#+begin_src elisp
(add-hook 'on-first-buffer-hook #'winner-mode)
(setq winner-dont-bind-my-keys t)
#+end_src
** ace-window
#+begin_src elisp
(eat/pkg ace-window)

(keymap-global-set "M-o" 'ace-window)

(setq aw-keys '(?a ?o ?e ?u ?i)
      aw-scope 'frame
      aw-dispatch-alist
      '((?d aw-delete-window "Ace - Delete Window")
        (?s aw-swap-window "Ace - Swap Window")
        (?p aw-flip-window)
        (?v aw-split-window-vert "Ace - Split Vert Window")
        (?h aw-split-window-horz "Ace - Split Horz Window")
        (?m delete-other-windows "Ace - Maximize Window")
        (?g delete-other-windows)
        (?b balance-windows)
        (?u (lambda ()
              (progn
                (winner-undo)
                (setq this-command 'winner-undo))))
        (?r winner-redo)))
(with-eval-after-load 'ace-window
  (dolist (cmd '(ace-window
                 aw--select-window))
    (advice-add cmd :after #'eat/pulse-momentary-line)))
#+end_src
** popper
#+begin_src elisp
(eat/pkg popper)

(add-hook 'on-first-buffer-hook #'popper-mode)

(setq popper-reference-buffers
      '("\\*Messages\\*"
        "Output\\*$"
        "\\*Async Shell Command\\*"
        "\\*Compile-Log\\*"
        "\\*Completions\\*"
        "\\*Warnings\\*"

        "^\\*eshell.*\\*$" eshell-mode  ;eshell as a popup
        "^\\*shell.*\\*$"  shell-mode   ;shell as a popup
        "^\\*term.*\\*$"   term-mode    ;term as a popup
        "^\\*vterm.*\\*$"  vterm-mode   ;vterm as a popup
        "^\\*eat.*\\*$"    eat-mode     ;eat as a popup

        ;; help & message
        help-mode
        ghelp-page-mode
        compilation-mode))

(with-eval-after-load 'project
  (setq popper-group-function 'popper-group-by-project))

(with-eval-after-load 'popper
  (keymap-global-set "C-M-`" #'popper-toggle-type)
  (defun my-popper-fit-window-height (win)
    "Determine the height of popup window WIN by fitting it to the buffer's content."
    (fit-window-to-buffer
     win
     (floor (frame-height) 3)
     (floor (frame-height) 3)))
  (setq popper-window-height #'my-popper-fit-window-height))
#+end_src
** window-numbering
#+begin_src emacs-lisp
(eat/pkg window-numbering)
(add-hook 'after-init-hook #'window-numbering-mode)
#+end_src
** switch-window

#+begin_src elisp
(eat/pkg switchy-window)

(eat/hook 'on-first-file-hook #'switchy-window-minor-mode)

;; (keymap-set switchy-window-minor-mode-map "<remap> <other-window>" #'switchy-window)
#+end_src
** auto balance
https://zck.org/balance-emacs-windows
#+begin_src emacs-lisp
;; (seq-doseq (fn (list #'split-window #'delete-window))
;;   (advice-add fn
;;               :after
;;               #'(lambda (&rest args) (balance-windows))))
#+end_src

* Buffer
** Functions
#+begin_src emacs-lisp
(defun eat/delete-to-the-begining ()
  (interactive)
  (delete-region (point-min) (point)))

(defun eat/delete-to-the-end ()
  (interactive)
  (delete-region (point) (point-max)))

(defun eat/delete-whole-buffer ()
  (interactive)
  (delete-region (point-min) (point-max)))

(defun eat/delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))

(defun get-string-from-file (filePath)
  "Return file content as string."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))
#+end_src
** Ibuffer
#+begin_src elisp
(eat/pkg ibuffer-vc)
(fset 'list-buffers 'ibuffer)
(setq-default ibuffer-show-empty-filter-groups nil)
(keymap-global-set "C-x B" 'ibuffer)
;; Modify the default ibuffer-formats (toggle with `)
(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 22 22 :left :elide)
              " "
              (size-h 9 -1 :right)
              " "
              (mode 12 12 :left :elide)
              " "
              vc-relative-file)
        (mark modified read-only vc-status-mini " "
              (name 22 22 :left :elide)
              " "
              (size-h 9 -1 :right)
              " "
              (mode 14 14 :left :elide)
              " "
              (vc-status 12 12 :left)
              " "
              vc-relative-file)))
(with-eval-after-load 'ibuffer
  (setq ibuffer-filter-group-name-face 'font-lock-doc-face)
  (with-eval-after-load 'fullframe
    (fullframe ibuffer ibuffer-quit))
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (file-size-human-readable (buffer-size))))

;; Ibuffer-vc
(add-hook 'ibuffer-hook #'ibuffer-set-up-preferred-filters)

(defun ibuffer-set-up-preferred-filters ()
  (ibuffer-vc-set-filter-groups-by-vc-root)
  (unless (eq ibuffer-sorting-mode 'filename/process)
    (ibuffer-do-sort-by-filename/process)))
#+end_src
** Auto-save
#+begin_src elisp
(add-hook 'on-first-file-hook #'auto-save-visited-mode)
#+end_src
** Isearch
#+begin_src elisp
(setq
 ;; Match count next to the minibuffer prompt
 isearch-lazy-count t
 ;; Don't be stingy with history; default is to keep just 16 entries
 search-ring-max 200
 regexp-search-ring-max 200
 ;; htighlighted all matching
 isearch-lazy-highlight t
 lazy-highlight-buffer t
 ;; show search count, TODO not work in isearch-mb-mode
 lazy-count-prefix-format nil
 lazy-count-suffix-format " [%s/%s]"
 ;; Record isearch in minibuffer history, so C-x ESC ESC can repeat it.
 isearch-resume-in-command-history t
 ;; M-< and M-> move to the first/last occurrence of the current search string.
 isearch-allow-motion t
 isearch-motion-changes-direction t
 ;; space matches any sequence of characters in a line.
 isearch-regexp-lax-whitespace t
 search-whitespace-regexp ".*?")

(with-eval-after-load 'isearch
  (define-advice isearch-occur (:after (_regexp &optional _nlines))
    (isearch-exit)))

(keymap-global-set "C-s" #'isearch-forward-regexp)
(keymap-global-set "C-r" #'isearch-backward-regexp)
(keymap-set isearch-mode-map "C-c C-o" #'isearch-occur)
(keymap-substitute isearch-mode-map #'isearch-delete-chac #'isearch-del-chac)
;; TODO
(define-key isearch-mode-map [escape] #'isearch-cancel)

(eat/pkg isearch-mb)
(add-hook 'isearch-mode-hook #'isearch-mb-mode)
(with-eval-after-load 'isearch-mb
  (define-advice isearch-mb--update-prompt (:around (fn &rest _) show-case-fold-info)
    "Show case fold info in the prompt."
    (cl-letf* ((isearch--describe-regexp-mode-orig
                (symbol-function 'isearch--describe-regexp-mode))
               ((symbol-function 'isearch--describe-regexp-mode)
                (lambda (regexp-function &optional space-before)
                  (concat (if isearch-case-fold-search "[Case Fold] " "")
                          (funcall isearch--describe-regexp-mode-orig
                                   regexp-function space-before)))))
      (funcall fn _))))
#+end_src

** Misc
#+begin_src elisp
(setq display-line-numbers-width 3)

;;; whitespace
(add-hook 'prog-mode-hook #'whitespace-mode)
(add-hook 'hook #'whitespace-mode)
(setq whitespace-style '(face trailing))

;;; savehist
(add-hook 'after-init-hook #'savehist-mode)
;; Restore histories and registers after saving
(setq history-length 1000)

(eat/hook 'on-first-file-hook '(global-goto-address-mode
                                global-auto-revert-mode
                                save-place-mode
                                global-so-long-mode))
#+end_src

* Minibuffer
#+begin_src elisp
(setq
 completion-styles '(basic partial-completion)
 completion-category-overrides '((file (styles basic partial-completion)))
 completion-cycle-threshold t
 minibuffer-depth-indicate-mode t
 minibuffer-eldef-shorten-default t
 minibuffer-electric-default-mode t)
;; Quit that fucking minibuffer!
(keymap-set minibuffer-local-map "C-g" #'keyboard-quit)
#+end_src

** Vertico
#+begin_src elisp
;;; vertico
(eat/pkg vertico)

(add-hook 'after-init-hook #'vertico-mode)
(add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

;; Use `consult-completion-in-region' if Vertico is enabled.
;; Otherwise use the default `completion--in-region' function.
(setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                   #'consult-completion-in-region
                 #'completion--in-region)
               args)))

(with-eval-after-load 'vertico
  (keymap-set vertico-map "DEL" #'vertico-directory-delete-char)
  (keymap-set vertico-map "M-DEL" #'vertico-directory-delete-word)
  (keymap-set vertico-map "RET" #'vertico-directory-enter))

(setq vertico-resize nil
      vertico-count 17)

;;; marginalia
(eat/pkg marginalia)
(add-hook 'after-init-hook #'marginalia-mode)

;;; consult
(eat/pkg consult)

(advice-add #'multi-occur :override #'consult-multi-occur)
;; (global-set-key (kbd "C-s") #'consult-line)
(global-set-key [remap apropos] #'consult-apropos)
(global-set-key [remap bookmark-jump] #'consult-bookmark)
(global-set-key [remap goto-line] #'consult-goto-line)
(global-set-key [remap imenu] #'consult-imenu)
(global-set-key [remap locate] #'consult-locate)
(global-set-key [remap man] #'consult-man)
(global-set-key [remap recentf-open-files] #'consult-recent-file)
(global-set-key [remap switch-to-buffer] #'consult-buffer)
(global-set-key [remap switch-to-buffer-other-window] #'consult-buffer-other-window)
(global-set-key [remap switch-to-buffer-other-frame] #'consult-buffer-other-frame)
(global-set-key [remap yank-pop] #'consult-yank-pop)
(global-set-key [remap project-find-regexp] #'consult-grep)

(setq consult-project-root-function  (lambda ()
                                       (when-let (project (project-current))
                                         (car (project-roots project))))
      consult-narrow-key             "<"
      consult-line-numbers-widen     t
      consult-async-min-input        2
      consult-async-refresh-delay    0.15
      consult-async-input-throttle   0.2
      consult-async-input-debounce   0.1
      xref-show-xrefs-function       #'consult-xref
      xref-show-definitions-function #'consult-xref)

(with-eval-after-load 'consult
  (consult-customize consult-ripgrep consult-git-grep consult-grep
                     consult-bookmark consult-recent-file consult-xref
                     :preview-key nil))

;;; orderless
(eat/pkg orderless)

(defun sanityinc/use-orderless-in-minibuffer ()
  (setq-local completion-styles '(substring orderless)))

(add-hook 'minibuffer-setup-hook #'sanityinc/use-orderless-in-minibuffer)

(with-eval-after-load 'orderless
  (defun completion--regex-pinyin (str)
    (orderless-regexp (pinyinlib-build-regexp-string str)))
  (add-to-list 'orderless-matching-styles 'completion--regex-pinyin))

;;; embark
(eat/pkg embark)
(eat/pkg embark-consult)

(with-eval-after-load 'vertico
  (keymap-set vertico-map "C-c C-o" #'embark-export)
  (keymap-set vertico-map "C-c C-c" #'embark-act))

(with-eval-after-load 'embark
  (keymap-set embark-meta-map "<escape>" #'keyboard-escape-quit))

(with-eval-after-load 'embark
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (with-eval-after-load 'consult
    (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode)))

;;; consult-yasnippet
(eat/pkg consult-yasnippet)
;;; consult-dir
(eat/pkg consult-dir)

(global-set-key [remap list-directory] #'consult-dir)
(with-eval-after-load 'vertico
  (keymap-set vertico-map "C-x C-d" #'consult-dir)
  (keymap-set vertico-map "C-x C-j" #'consult-dir-jump-file))

;;; consult-eglot
(eat/pkg consult-eglot)
#+end_src

* UI
** Windows/frames
#+begin_src emacs-lisp
(eat/pkg breadcrumb)

(setq-default frame-title-format
              '((:eval (breadcrumb-project-crumbs))
                " : "
                (:eval (breadcrumb-imenu-crumbs))))

(setq use-dialog-box nil
      ;; Monitors are trending toward wide, rather than tall.
      split-width-threshold 160
      split-height-threshold nil)
#+end_src
** Scrolling
#+begin_src emacs-lisp
(setq hscroll-step 1
      hscroll-margin 2
      ;; The nano style for truncated long lines.
      auto-hscroll-mode 'current-line
      scroll-margin 0
      scroll-conservatively 101
      scroll-preserve-screen-position t
      auto-window-vscroll nil
      ;; Use shift + mouse wheel to scrll horizontally.
      mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
      mouse-wheel-scroll-amount-horizontal 2)

(when (fboundp 'pixel-scroll-precision-mode)
  (add-hook 'after-init-hook (lambda () (pixel-scroll-precision-mode)))

  (setq pixel-scroll-precision-interpolate-page t)
  (defun +pixel-scroll-interpolate-down (&optional lines)
    (interactive)
    (if lines
        (pixel-scroll-precision-interpolate (* -1 lines (pixel-line-height)))
      (pixel-scroll-interpolate-down)))

  (defun +pixel-scroll-interpolate-up (&optional lines)
    (interactive)
    (if lines
        (pixel-scroll-precision-interpolate (* lines (pixel-line-height))))
    (pixel-scroll-interpolate-up))

  (defalias 'scroll-up-command '+pixel-scroll-interpolate-down)
  (defalias 'scroll-down-command '+pixel-scroll-interpolate-up))
#+end_src
** Font
#+begin_src elisp
(defun font-installed-p (font-list)
  (let ((font-installed nil))
    (catch 'foo
      (dolist (font font-list)
        (when (find-font (font-spec :name font))
          (setq font-installed font)
          (throw 'foo t))))
    font-installed))

(defvar eat/fonts-default        '("DejaVu Sans Mono" "Monaco" "Cascadia Code" "Menlo" "Source Code Pro"))
(defvar eat/fonts-variable-pitch '("Bookerly" "Cardo" "Times New Roman" "DejaVu Sans"))
(defvar eat/fonts-cjk            '("LXGW WenKai" "WenQuanYi Micro Hei" "Microsoft Yahei"))
(defvar eat/fonts-unicode        '("Symbols Nerd Font"))
(defvar eat/fonts-emoji          '("Apple Color Emoji" "Segoe UI Symbol" "Noto Color Emoji"))

(defvar eat/font-size-default   13)
(defvar eat/font-default        (font-installed-p eat/fonts-default))
(defvar eat/font-variable-pitch (font-installed-p eat/fonts-variable-pitch))
(defvar eat/font-cjk            (font-installed-p eat/fonts-cjk))
(defvar eat/font-unicode        (font-installed-p eat/fonts-unicode))
(defvar eat/font-emoji          (font-installed-p eat/fonts-emoji))

(defvar eat/font-rescale-alist
  `((,eat/font-cjk     . 0.95)
    (,eat/font-emoji   . 0.85)
    (,eat/font-unicode . 0.85))
  "A list of font names that should be rescaled.")

(defun eat/rescale-font ()
  (interactive)
  (dolist (setting eat/font-rescale-alist)
    (when (car setting)
      (setf (alist-get (car setting)
                       face-font-rescale-alist nil nil #'equal)
		    (cdr setting)))))

(defun eat/fixed-pitch-setup ()
  (interactive)
  (setq buffer-face-mode-face '(:family "等距更纱黑体 SC"))
  (buffer-face-mode +1))

(defun eat/setup-mode-line-font ()
  (set-face-attribute 'mode-line nil :inherit 'variable-pitch)
  (set-face-attribute 'mode-line-inactive nil :inherit 'variable-pitch))

(defun eat/setup-font ()
  (interactive)
  (set-face-attribute 'default     nil :height (* 10 eat/font-size-default))
  (when eat/font-default
    (set-face-attribute 'default     nil :family eat/font-default)
    (set-face-attribute 'fixed-pitch nil :font eat/font-default))
  ;; variable-pitch
  (when eat/font-variable-pitch (set-face-font 'variable-pitch eat/font-variable-pitch))
  ;;  emoji
  (when eat/font-emoji
    (set-fontset-font t 'unicode eat/font-unicode)
    (set-fontset-font t 'emoji   eat/font-emoji))
  ;; Chinese font, NOTE must set after unicode
  (when eat/font-cjk
    (set-fontset-font t 'kana     eat/font-cjk)
    (set-fontset-font t 'han      eat/font-cjk)
    (set-fontset-font t 'cjk-misc eat/font-cjk))
  (eat/setup-mode-line-font))

(add-hook 'eat/after-make-window-system-frame-hooks #'eat/setup-font)
(add-hook 'eat/after-make-window-system-frame-hooks #'eat/rescale-font)
#+end_src
** Theme
#+begin_src elisp
(setq modus-themes-fringes nil)

(defvar eat/theme 'pale
  "Default theme.")

(defvar eat/theme-tui 'wombat
  "Default TUI theme.")

(defvar eat/theme-system-light 'modus-operandi
  "Default light theme after system appearance changed.")

(defvar eat/theme-system-dark 'wombat
  "Default dark theme after system appearance changed.")

(defvar load-theme-hook nil
  "Hooks that run after `load-theme'.")

(defun eat/load-theme (f theme &optional no-confirm no-enable &rest args)
  (interactive
   (list
    (intern (completing-read "Theme: "
                             (mapcar #'symbol-name
				                     (custom-available-themes))))))
  (dolist (theme custom-enabled-themes)
    (disable-theme theme))
  (if (featurep (intern (format "%s-theme" theme)))
      (enable-theme theme)
    (apply f theme t no-enable args))
  (run-hooks 'load-theme-hook))
(advice-add 'load-theme :around #'eat/load-theme)

(defun eat/tui-load-theme ()
  (when (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when eat/theme-tui
    (load-theme eat/theme-tui)))

(defun eat/gui-load-theme ()
  (when eat/theme
    (load-theme eat/theme))
  ;; For MacOS, load theme after system appearance changed.
  (when (boundp 'ns-system-appearance)
    (add-to-list 'ns-system-appearance-change-functions
                 (lambda (l?d)
                   (if (eq l?d 'light)
                       (load-theme eat/theme-system-light)
                     (load-theme eat/theme-system-dark))))))

(add-hook 'eat/after-make-console-frame-hooks       #'eat/tui-load-theme)
(add-hook 'eat/after-make-window-system-frame-hooks #'eat/gui-load-theme)
(add-hook 'load-theme-hook #'eat/setup-mode-line-font)
#+end_src
** solaire mode

#+begin_src emacs-lisp
(eat/pkg solaire-mode)

(add-hook 'after-init-hook #'solaire-global-mode)
#+end_src

** Adjust opacity
#+begin_src emacs-lisp
(defun eat/adjust-opacity (frame incr)
  "Adjust the background opacity of FRAME by increment INCR."
  (unless (display-graphic-p frame)
    (error "Cannot adjust opacity of this frame"))
  (let* ((oldalpha (or (frame-parameter frame 'alpha-background) 100))
         (oldalpha (if (listp oldalpha) (car oldalpha) oldalpha))
         (newalpha (+ incr oldalpha)))
    (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
      (modify-frame-parameters frame (list (cons 'alpha-background newalpha))))))
(global-set-key (kbd "M-C-8") (lambda () (interactive) (eat/adjust-opacity nil -2)))
(global-set-key (kbd "M-C-9") (lambda () (interactive) (eat/adjust-opacity nil 2)))
(global-set-key (kbd "M-C-7") (lambda () (interactive) (modify-frame-parameters nil `((alpha-background . 100)))))
#+end_src
** Text Scale
#+begin_src elisp
(eat/pkg default-text-scale)
(keymap-global-set "C-x C-=" #'default-text-scale-increase)
(keymap-global-set "C-x C--" #'default-text-scale-decrease)
#+end_src
** hide minor modes on mode line
#+begin_src emacs-lisp
(eat/pkg minions)

(add-hook 'after-init-hook 'minions-mode)
#+end_src
** indent bars
#+begin_src emacs-lisp
(eat/pkg indent-bars "https://github.com/jdtsmith/indent-bars.git")

(eat/hook '(python-base-mode-hook
            yaml-mode-hook
            yaml-ts-mode-hook)
          #'indent-bars-mode)

(setq
 indent-bars-color '(highlight :face-bg t :blend 0.15)
 indent-bars-pattern "."
 indent-bars-width-frac 0.1
 indent-bars-pad-frac 0.1
 indent-bars-zigzag nil
 indent-bars-color-by-depth nil
 indent-bars-display-on-blank-lines nil)

(setq indent-bars-treesit-support (treesit-available-p)
      ;; indent-bars-prefer-character "│"
      indent-bars-highlight-current-depth '(:face default :blend 0.3)
      ;; https://github.com/jdtsmith/indent-bars#configuring-tree-sitter
      indent-bars-treesit-ignore-blank-lines-types '("module")
      indent-bars-treesit-wrap '((python argument_list parameters
				                         list list_comprehension
				                         dictionary dictionary_comprehension
				                         parenthesized_expression subscript)))
#+end_src
* Editing
** Functions
#+begin_src emacs-lisp
;; http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))
(global-set-key [remap move-beginning-of-line] #'smarter-move-beginning-of-line)
#+end_src
** Built In Tools
*** Ediff
#+begin_src elisp
(defvar local-ediff-saved-window-conf nil)
(defun eat/ediff-save-window-conf ()
  (setq local-ediff-saved-window-conf (current-window-configuration)))

(defun eat/ediff-restore-window-conf ()
  (when (window-configuration-p local-ediff-saved-window-conf)
    (set-window-configuration local-ediff-saved-window-conf)))

(setq ediff-window-setup-function #'ediff-setup-windows-plain
      ediff-highlight-all-diffs t
      ediff-split-window-function 'split-window-horizontally
      ediff-merge-split-window-function 'split-window-horizontally)
(with-eval-after-load 'ediff
  ;; Restore window config after quitting ediff
  (add-hook 'ediff-before-setup-hook #'eat/ediff-save-window-conf)
  (add-hook 'ediff-quit-hook #'eat/ediff-restore-window-conf))
#+end_src
*** Tramp
#+begin_src elisp
(setq
 remote-file-name-inhibit-locks t
 tramp-verbose 1 ;; only show error message
 tramp-completion-reread-directory-timeout nil ;;  speed up complete
 tramp-auto-save-directory temporary-file-directory
 ;; Always use file cache when using tramp
 remote-file-name-inhibit-cache nil
 ;; C-x C-f /ssh:
 tramp-default-method "ssh"
 vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                              vc-ignore-dir-regexp
                              tramp-file-name-regexp))

(defun eat/reopen-file-with-sudo ()
  (interactive)
  (find-alternate-file (format "/sudo::%s" (buffer-file-name))))
(keymap-global-set "C-x C-z" #'eat/reopen-file-with-sudo)

;; https://www.reddit.com/r/emacs/comments/y92y4b/tramp_users_slowness_got_you_down_check/
(defun my-vc-off-if-remote ()
  (if (file-remote-p (buffer-file-name))
      (setq-local vc-handled-backends '(Git))))

(add-hook 'find-file-hook 'my-vc-off-if-remote)

(with-eval-after-load 'tramp
  ;; ‘Private Directories’ are the settings of the $PATH environment,
  ;; as given in your ‘~/.profile’.  This entry is represented in
  ;; the list by the special value ‘tramp-own-remote-path’.
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src
*** Hl Line
#+begin_src emacs-lisp
(setq hl-line-sticky-flag nil)
;; (when (display-graphic-p)
;;   (add-hook 'prog-mode-hook #'hl-line-mode)
;;   (add-hook 'conf-mode-hook #'hl-line-mode))
(with-eval-after-load 'hl-line
  (add-hook 'post-command-hook #'(lambda ()
                                   "When `hl-line-mode' is enable, unhighlight if region is active."
                                   (when (and (bound-and-true-p hl-line-mode)
                                              (region-active-p))
                                     (hl-line-unhighlight)))))
#+end_src

*** Pulse
#+begin_src elisp
(custom-set-faces
 '(pulse-highlight-start-face ((t (:inherit region))))
 '(pulse-highlight-face ((t (:inherit region)))))

(defun eat/pulse-momentary-line (&rest _)
  "Pulse the current line."
  (pulse-momentary-highlight-one-line (point)))

(defun eat/pulse-momentary (&rest _)
  "Pulse the region or the current line."
  (if (fboundp 'xref-pulse-momentarily)
      (xref-pulse-momentarily)
    (eat/pulse-momentary-line)))

(defun eat/recenter-and-pulse(&rest _)
  "Recenter and pulse the region or the current line."
  (recenter)
  (eat/pulse-momentary))

(defun eat/recenter-and-pulse-line (&rest _)
  "Recenter and pulse the current line."
  (recenter)
  (eat/pulse-momentary-line))

(dolist (cmd '(recenter-top-bottom
               other-window windmove-do-window-select
               pager-page-down pager-page-up))
  (advice-add cmd :after #'eat/pulse-momentary-line))

(dolist (cmd '(pop-to-mark-command
               pop-global-mark
               compile-goto-error
               goto-last-change))
  (advice-add cmd :after #'eat/recenter-and-pulse))

(add-hook 'imenu-after-jump-hook #'eat/recenter-and-pulse)
(add-hook 'isearch-update-post-hook #'eat/recenter-and-pulse)

(add-hook 'bookmark-after-jump-hook #'eat/recenter-and-pulse-line)
(add-hook 'next-error #'eat/recenter-and-pulse-line)
#+end_src

*** Outline
#+begin_src emacs-lisp
(setq outline-minor-mode-cycle t
      outline-minor-mode-highlight t)
#+end_src

*** Simple
#+begin_src emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
(setq visual-line-fringe-indicators '(nil nil)
      ;; List only applicable commands.
      read-extended-command-predicate #'command-completion-default-include-p
      fill-column 72)
#+end_src

*** Subword
#+begin_src elisp
(add-hook 'prog-mode-hook #'subword-mode)
#+end_src
** Meow
*** Setup
#+begin_src elisp
(defun meow-setup-dvorak ()
  (interactive)
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-dvorak)

  (meow-motion-overwrite-define-key
   '("<escape>" . mode-line-other-buffer)
   '("'" . repeat)
   '(")" . tab-bar-switch-to-prev-tab)
   '("}" . tab-bar-switch-to-next-tab)
   )

  ;; NOTE key defined in leader same as bind to C-c
  ;; so make sure it didn't conflict with keybindings
  ;; defined in other files or bulitin that start with C-c
  ;; or use this to make it start with C-c m
  (defalias 'meow-leader-command-prefix (make-sparse-keymap))
  (defvar meow-leader-map (symbol-function 'meow-leader-command-prefix)
    "Keymap for characters following C-c m.")
  (keymap-global-set "C-c m" 'meow-leader-command-prefix)
  (add-to-list 'meow-keymap-alist (cons 'leader 'meow-leader-command-prefix))

  (meow-leader-define-key
   '("a" . execute-extended-command)
   '("e" . "C-x C-e")
   '(";" . comment-dwim)
   '("-" . negative-argument)

   ;; file
   '("f" . find-file)
   '("F" . find-file-other-window)

   ;; buffer
   '("b" . switch-to-buffer)
   '("B" . switch-to-buffer-other-window)
   '("k" . kill-this-buffer)

   ;; window
   '("w" . ace-select-window)
   '("W" . ace-swap-window)
   '("o" . "C-x 1")
   '("O" . ace-delete-window)
   '("q" . delete-window)
   '("-" . "C-x 2")
   '("s" . "C-x 3")

   ;; xref
   '("." . "M-.")
   '("," . "M-,")
   '("?" . "M-?")

   ;; project, bind to keymap
   (cons "p" project-prefix-map)
   ;; smerge
   ;; (cons "=" smerge-basic-map)

   ;; tab-bar
   (cons "t" tab-prefix-map)

   ;; app
   '("d" . dired)
   '("v" . magit)
   '("C" . xeft)

   ;; toggles
   '("$" . load-theme)
   '("L" . display-line-numbers-mode)
   '("A" . org-agenda-list)
   '("T" . telega)
   )

  (meow-normal-define-key
   '("?" . meow-cheatsheet)
   '("<escape>" . mode-line-other-buffer)
   '(";" . meow-reverse)
   '("g" . meow-cancel-selection)
   '("q" . eat/quit)
   '("\\" . comment-dwim)

   ;; expand by numbers
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)

   ;; movement, like hjkl
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("t" . meow-right)
   '("T" . meow-right-expand)
   '("n" . meow-next)
   '("N" . meow-next-expand)
   '("p" . meow-prev)
   '("P" . meow-prev-expand)

   ;; insert above/below
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("A" . meow-open-below)
   '("a" . meow-append)

   ;; move/mark by word/symbol
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("w" . meow-next-word)
   '("W" . meow-next-symbol)
   '("m" . meow-mark-word)
   '("M" . meow-mark-symbol)

   ;; kill/delete/change/replace
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("k" . meow-kill)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("c" . meow-change)

   ;; line operation
   '("j" . meow-join)
   '("e" . meow-line) ;; NOTE F3 or insert/append/change in grab to enable "every n line" grab
   '("E" . meow-goto-line)
   '("o" . meow-block)
   '("O" . meow-to-block)

   ;; yank/pop
   '("x" . meow-save)
   '("X" . meow-sync-grab)
   '("y" . meow-yank)

   ;; grab
   '("G" . meow-grab)
   '("z" . meow-pop-selection)

   ;; query replace
   '("&" . meow-query-replace)
   '("%" . meow-query-replace-regexp)

   ;; thing
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("<" . meow-beginning-of-thing)
   '(">" . meow-end-of-thing)

   ;; find/till/visit, most used in beacon mode
   '("/" . meow-search)
   '("F" . meow-find)
   '("L" . meow-till)
   '("l" . meow-visit)

   ;; undo
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)


   ;;
   '(":" . execute-extended-command)

   ;; scroll
   '("v" . scroll-up-command)
   '("V" . scroll-down-command)

   ;; buffer
   '("S" . save-buffer)

   ;; window
   '("s" . ace-select-window)

   ;; wrap && unwrap
   '("\"" . insert-pair)
   '("[" . insert-pair)
   '("{" . insert-pair)
   '("(" . insert-pair)
   '("]" . delete-pair) ;; NOTE maybe custom `delete-pair-blink-delay'

   ;; flymake
   '("Q" . flymake-goto-prev-error)
   '("J" . flymake-goto-next-error)

   ;; tab-bar
   '(")" . tab-bar-switch-to-prev-tab)
   '("}" . tab-bar-switch-to-next-tab)

   ;; misc
   '("'" . repeat)
   '("-" . avy-goto-char-timer)
   '("f" . project-find-file)
   '("K" . kill-this-buffer)
   ))
#+end_src
*** Config
#+begin_src elisp
(eat/pkg meow)

(require 'meow)
(setq meow-visit-sanitize-completion nil
      meow-esc-delay 0.001
      meow-keypad-describe-delay 1.0
      meow-replace-state-name-list
      '((normal . "N")
        (motion . "M")
        (keypad . "K")
        (insert . "I")
        (beacon . "B")))
;; specific font so that line won't break TODO chang to variable
;; (advice-add 'meow-cheatsheet :after (lambda ()
;;                                       (interactive)
;;                                       (setq buffer-face-mode-face '(:family "Menlo"))
;;                                       (buffer-face-mode +1)))
;; normal mode list
(dolist (mode '(go-dot-mod-mode
                diff-mode))
  (add-to-list 'meow-mode-state-list `(,mode . normal)))
;; motion mode list
(dolist (mode '(lsp-bridge-ref-mode
                Info-mode
                ghelp-page-mode
                notmuch-hello-mode
                notmuch-search-mode
                notmuch-tree-mode))
  (add-to-list 'meow-mode-state-list `(,mode . motion)))
(dolist (mode '(xeft-mode
                gud-mode))
  (add-to-list 'meow-mode-state-list `(,mode . insert)))

(meow-setup-dvorak)
(meow-setup-indicator)
(meow-global-mode 1)
#+end_src
** Anzu
#+begin_src elisp
(eat/pkg anzu)
(global-set-key [remap query-replace] #'anzu-query-replace)
(global-set-key [remap query-replace-regexp] #'anzu-query-replace-regexp)
#+end_src
** Separedit
#+begin_src emacs-lisp
(eat/pkg separedit)
(keymap-global-set "C-c '" #'separedit)
#+end_src
** Iscroll
Better scroll on picture in GUI
#+begin_src emacs-lisp
(eat/pkg iscroll)
#+end_src

** Undo
*** vundo
#+begin_src emacs-lisp
(eat/pkg vundo)
#+end_src

*** undo-hl
#+begin_src emacs-lisp
(eat/pkg undo-hl "https://github.com/casouri/undo-hl.git")
(add-hook 'prog-mode-hook #'undo-hl-mode)
(add-hook 'conf-mode-hook #'undo-hl-mode)
#+end_src

** TODO Chinese Input                                                 :deps:
If you install emacs and librime with nix(replace to your own path):
#+begin_src elisp
(setq rime-emacs-module-header-root "/nix/store/ayyiild8rxw94z0gj15w1bwnsaqpaix3-emacs-git-20230128.0/include")
(setq rime-librime-root "/nix/store/g5g449j7c9h0v5f6sp4jbl3w9k4ays8p-librime-1.7.3")
#+end_src
Then ~rime-compile-module~.

#+begin_src elisp
;; curl -L -O https://github.com/rime/librime/releases/download/1.7.2/rime-1.7.2-osx.zip
;; unzip rime-1.7.2-osx.zip -d ~/.config/emacs/librime
;; rm -rf rime-1.7.2-osx.zip
(eat/pkg rime)
(when eat/macp
  (setq rime-librime-root (expand-file-name "librime/dist" user-emacs-directory)))
(setq
 rime-disable-predicates '(meow-normal-mode-p
                           ;; meow-motion-mode-p
                           meow-keypad-mode-p
                           meow-beacon-mode-p)
 rime-inline-predicates '(rime-predicate-space-after-cc-p
                          rime-predicate-current-uppercase-letter-p)
 rime-translate-keybindings '("C-f" "C-b" "C-n" "C-p" "C-g" "C-v" "M-v")
 rime-inline-ascii-holder ?a
 default-input-method "rime"
 rime-cursor "|"
 rime-show-candidate 'minibuffer)
(with-eval-after-load 'rime
  (setq-default
   rime-posframe-properties (list :internal-border-width 1))
  (set-face-attribute 'rime-indicator-face nil :height 0.9)
  (set-face-attribute 'rime-indicator-dim-face nil :height 0.9)
  (define-key rime-active-mode-map [tab] 'rime-inline-ascii)
  (keymap-set rime-mode-map "M-j" 'rime-force-enable))
#+end_src

*** TODO Search with regex
Only work for orderless for now.

#+begin_src elisp
(unless (package-installed-p 'rime-regexp)
  (package-vc-install "https://github.com/colawithsauce/rime-regexp.el"))
#+end_src

** TODO Symbol Overlay
#+begin_src emacs-lisp
(eat/pkg symbol-overlay)
 #+end_src
** Hl Todo
#+begin_src emacs-lisp
(eat/pkg hl-todo)
(eat/hook '(dired-mode-hook prog-mode-hook conf-mode-hook) #'hl-todo-mode)
#+end_src
** Ligature
#+begin_src emacs-lisp
(eat/pkg ligature)

(add-hook 'prog-mode-hook #'(lambda () (ligature-mode t)))

(autoload #'global-ligature-mode "ligature")

(with-eval-after-load 'ligature
  ;; https://htmlpreview.github.io/?https://github.com/kiliman/operator-mono-lig/blob/master/images/preview/normal/index.html
  (ligature-set-ligatures 'prog-mode
                          '("&&" "||" "|>" ":=" "==" "===" "==>" "=>"
                            "=<<" "!=" "!==" ">=" ">=>" ">>=" "->" "--"
                            "-->" "<|" "<=" "<==" "<=>" "<=<" "<!--" "<-"
                            "<->" "<--" "</" "+=" "++" "??" "/>" "__" "WWW")))
#+end_src
** Avy
#+begin_src elisp
(eat/pkg avy)
(with-eval-after-load 'avy
  (setq avy-background t
        avy-style 'pre))
#+end_src
* Completion
** Corfu
#+begin_src elisp
(eat/pkg corfu)
(eat/pkg popon)
(eat/pkg corfu-terminal)

(add-hook 'after-init-hook #'(lambda () (global-corfu-mode 1)))
(add-hook 'corfu-mode-hook #'(lambda ()
                               (unless (display-graphic-p)
                                 (corfu-terminal-mode +1))
                               (corfu-popupinfo-mode)))

(setq corfu-preview-current nil
      corfu-auto-delay 0.2
      corfu-auto-prefix 2
      corfu-quit-no-match t
      corfu-quit-at-boundary t
      corfu-auto t)

(with-eval-after-load 'corfu
  (keymap-set corfu-map "<escape>" #'(lambda ()
                                       (interactive)
                                       (corfu-quit)
                                       (when (meow-insert-mode-p)
                                         (meow-insert-exit))))
  (keymap-set corfu-map "RET" nil))

(defun eat/yas-next-field-or-maybe-expand ()
  "Try complete current cond or `yas-next-field-or-maybe-expand'.

Sometime lsp client return a snippet and complete didn't work(TAB will jump to next field),
so try complete filst, if there nothing to complete then try to jump to next field or expand."
  (interactive)
  (or (corfu-insert) ;; NOTE this works
      (yas-next-field-or-maybe-expand)))
(with-eval-after-load 'yasnippet
  (keymap-set yas-keymap "<tab>" 'eat/yas-next-field-or-maybe-expand)
  (keymap-set yas-keymap "TAB" 'eat/yas-next-field-or-maybe-expand))


(eat/pkg tabnine "https://github.com/shuxiao9058/tabnine")

(with-eval-after-load 'tabnine
  (tabnine-start-process)
  (bind tabnine-completion-map
        "M-<return> "#'tabnine-accept-completion-by-line
        "C-g" #'tabnine-clear-overlay
        "M-[" #'tabnine-previous-completion
        "M-]" #'tabnine-next-completion)
  (add-hook 'kill-emacs-hook #'tabnine-kill-process))
#+end_src

** Yasnippet
#+begin_src elisp
(eat/pkg yasnippet)
(eat/hook '(prog-mode-hook conf-mode-hook) #'yas-minor-mode)
(with-eval-after-load 'yasnippet
  (let ((inhibit-message t))
    (yas-reload-all)))
#+end_src
* Programming
** Tools
*** Pair
**** elec-pair
#+begin_src elisp
(add-hook 'prog-mode-hook #'electric-pair-local-mode)
(setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
#+end_src
**** paren
#+begin_src elisp
(setq show-paren-when-point-in-periphery t
      show-paren-context-when-offscreen 'overlay
      show-paren-when-point-inside-paren t
      show-paren-context-when-offscreen t)
#+end_src
*** Smerge
#+begin_src elisp
(add-hook 'find-file-hook #'(lambda ()
                              (save-excursion
                                (goto-char (point-min))
                                (when (re-search-forward "^<<<<<<< " nil t)
                                  (smerge-mode 1)))))

(with-eval-after-load 'smerge-mode
  (bind smerge-mode-map
        "C-c r" #'smerge-refine
        "C-c c" #'smerge-keep-current
        "C-c a" #'smerge-keep-all
        "C-c n" #'smerge-next
        "C-c p" #'smerge-prev
        "C-c l" #'smerge-keep-lower
        "C-c u" #'smerge-keep-upper))
#+end_src
*** Eldoc
#+begin_src elisp
(setq eldoc-idle-delay 1)
#+end_src
*** Newcomment
Set this localy in prog mode, or auto fill mode will not work since
there’s no comment in some mode.

#+begin_src elisp
;; FIXME eat/hook
;; (eat/hook 'prog-mode-hook
;;           #'(lambda ()
;;               (setq-local comment-auto-fill-only-comments t)
;;               (turn-on-auto-fill)
;;               ))
(add-hook 'prog-mode-hook
          #'(lambda ()
              (setq-local comment-auto-fill-only-comments t)
              (turn-on-auto-fill)))
#+end_src
*** TODO Hideshow
- Seems have error message.
- And to context-menu-mode.
#+begin_src elisp
(add-hook 'prog-mode-hook #'hs-minor-mode)

;; FIXME
(defconst hideshow-folded-face '((t (:inherit 'font-lock-comment-face :box t))))

(defface hideshow-border-face
  '((((background light))
     :background "rosy brown" :extend t)
    (t
     :background "sandy brown" :extend t))
  "Face used for hideshow fringe."
  :group 'hideshow)

(define-fringe-bitmap 'hideshow-folded-fringe
  (vector #b00000000
          #b00000000
          #b00000000
          #b11000011
          #b11100111
          #b01111110
          #b00111100
          #b00011000))

(defun hideshow-folded-overlay-fn (ov)
  "Display a folded region indicator with the number of folded lines."
  (when (eq 'code (overlay-get ov 'hs))
    (let* ((nlines (count-lines (overlay-start ov) (overlay-end ov)))
           (info (format " (%d)..." nlines)))
      ;; fringe indicator
      (overlay-put ov 'before-string (propertize " "
                                                 'display '(left-fringe hideshow-folded-fringe
                                                                        hideshow-border-face)))
      ;; folding indicator
      (overlay-put ov 'display (propertize info 'face hideshow-folded-face)))))

(setq hs-set-up-overlay #'hideshow-folded-overlay-fn)
#+end_src
*** Devdocs
#+begin_src elisp
(eat/pkg devdocs)
#+end_src

*** Imenu List
#+begin_src emacs-lisp
(eat/pkg imenu-list)

(setq imenu-list-auto-resize t
      imenu-list-mode-line-format nil)

(defun eat/imenu-list-setup ()
  (setq-local header-line-format nil)
  (face-remap-add-relative 'default :height 0.8))

(eat/hook 'imenu-list-major-mode-hook #'eat/imenu-list-setup)
#+end_src
*** Paredit
#+begin_src emacs-lisp
(eat/pkg paredit)

(eat/hook
 '(emacs-lisp-mode-hook
   lisp-interaction-mode-hook
   scheme-mode-hook
   lisp-mode-hook)
 #'paredit-mode)
#+end_src
*** Puni
#+begin_src emacs-lisp
(eat/pkg puni)
;; (:with-hook (emacs-lisp-mode-hook scheme-mode-hook clojure-mode-hook)
;;   (:hook puni-mode))
;; (:bind
;;  "M-r" 'puni-splice
;;  "C-(" 'puni-slurp-backward
;;  "C-)" 'puni-slurp-forward
;;  "C-{" 'puni-barf-backward
;;  "C-}" 'puni-barf-forward)
#+end_src
*** Dumb Jump
#+begin_src elisp
(eat/pkg dumb-jump)

(setq dumb-jump-quiet t
      dumb-jump-aggressive t
      dumb-jump-selector 'completing-read)

(when (executable-find "ugrep")
  (setq dumb-jump-grep-cmd "ugrep"
        dumb-jump-grep-args "-G -U -Y -. --sort -Dread -dread"))

;; NOTE use `dumb-jump' as default xref backend
;; you can run `eglot' or `eat/citre-enable' to reset this
(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
#+end_src
*** Apheleia
#+begin_src elisp
(eat/pkg apheleia)

(setq apheleia-remote-algorithm 'local)

(add-hook 'go-mode-hook #'apheleia-mode)

(with-eval-after-load 'apheleia
  (push '(go-ts-mode . gofmt) apheleia-mode-alist)
  (setf (alist-get 'gofmt apheleia-formatters)
        '("goimports")))
#+end_src
*** Clue
#+begin_src emacs-lisp
(eat/pkg clue "https://github.com/AmaiKinono/clue")
#+end_src
*** Flymake
#+begin_src elisp
(add-hook 'prog-mode-hook #'flymake-mode)
(add-hook 'emacs-lisp-mode-hook #'(lambda ()
                                    (flymake-mode -1)))

(setq flymake-diagnostic-functions nil
      ;; flymake-show-diagnostics-at-end-of-line t
      flymake-no-changes-timeout 0.2)

(defvar sekiro-flymake-mode-line-format `(:eval (sekiro-flymake-mode-line-format)))
(put 'sekiro-flymake-mode-line-format 'risky-local-variable t)
(defun sekiro-flymake-mode-line-format ()
  (let* ((counter (string-to-number
                   (nth 1
                        (cadr
                         (flymake--mode-line-counter :error t)))))
         (sekiro-flymake (when (> counter 0)
                           'compilation-error)))
    (propertize
     "危"
     'face
     sekiro-flymake)))

(with-eval-after-load 'flymake
  (add-to-list 'mode-line-misc-info
               `(flymake-mode (" [" sekiro-flymake-mode-line-format "] "))))
#+end_src
** Lsp
*** lsp-bridge                                                       :deps:
Need a lot...

~pypy3 -m ensurepip && pypy3 -m pip install epc sexpdata six paramiko~

#+begin_src elisp
(defun add-subdirs-to-load-path (search-dir)
  (interactive)
  (let* ((dir (file-name-as-directory search-dir)))
    (dolist (subdir
             ;; 过滤出不必要的目录，提升 Emacs 启动速度
             (cl-remove-if
              #'(lambda (subdir)
                  (or
                   ;; 不是目录的文件都移除
                   (not (file-directory-p (concat dir subdir)))
                   ;; 父目录、 语言相关和版本控制目录都移除
                   (member subdir '("." ".."
                                    "dist" "node_modules" "__pycache__"
                                    "RCS" "CVS" "rcs" "cvs" ".git" ".github"))))
              (directory-files dir)))
      (let ((subdir-path (concat dir (file-name-as-directory subdir))))
        ;; 目录下有 .el .so .dll 文件的路径才添加到 `load-path' 中，提升 Emacs 启动速度
        (when (cl-some #'(lambda (subdir-file)
                           (and (file-regular-p (concat subdir-path subdir-file))
                                ;; .so .dll 文件指非 Elisp 语言编写的 Emacs 动态库
                                (member (file-name-extension subdir-file) '("el" "so" "dll"))))
                       (directory-files subdir-path))

          ;; 注意：`add-to-list' 函数的第三个参数必须为 t ，表示加到列表末尾
          ;; 这样 Emacs 会从父目录到子目录的顺序搜索 Elisp 插件，顺序反过来会导致 Emacs 无法正常启动
          (add-to-list 'load-path subdir-path t))

        ;; 继续递归搜索子目录
        (add-subdirs-to-load-path subdir-path)))))

(eat/pkg lsp-bridge "https://github.com/manateelazycat/lsp-bridge")
(eat/pkg popon "https://codeberg.org/akib/emacs-popon.git")
(eat/pkg acm-terminal "https://github.com/twlz0ne/acm-terminal")


(defun eat/lsp-bridge-mode-setup ()
  (interactive)
  ;; Add sub dirs to load path.
  (if (file-directory-p (expand-file-name "elpa/lsp-bridge" user-emacs-directory))
      (add-subdirs-to-load-path (expand-file-name "elpa/lsp-bridge" user-emacs-directory)))
  ;; Disable corfu since lsp-bridge use acm.
  (ignore-errors
    (corfu-mode -1))
  ;; Use tab to jump to next field but do complete when there's acm complete.
  (with-eval-after-load 'yasnippet
    (define-key yas-keymap (kbd "<tab>") 'acm-complete-or-expand-yas-snippet)
    (define-key yas-keymap (kbd "TAB") 'acm-complete-or-expand-yas-snippet))
  ;; Use acm in terminal.
  (unless (display-graphic-p)
    (with-eval-after-load 'acm
      (require 'acm-terminal))))

(with-eval-after-load 'lsp-bridge
  (eat/hook 'lsp-bridge-mode-hook 'eat/lsp-bridge-mode-setup)

  (bind (lsp-bridge-mode-map
         "M-."     #'lsp-bridge-find-def
         "C-x 4 ." #'lsp-bridge-find-def-other-window
         "M-,"     #'lsp-bridge-find-def-return
         "M-?"     #'lsp-bridge-find-references
         "M-'"     #'lsp-bridge-find-impl
         "C-c r"   #'lsp-bridge-rename
         "C-c <"   #'lsp-bridge-diagnostic-jump-prev
         "C-c >"   #'lsp-bridge-diagnostic-jump-next
         "M-RET" #'lsp-bridge-code-action)
        (lsp-bridge-ref-mode-map
         "j" nil
         "k" nil
         "h" nil
         "l" nil
         "p" #'lsp-bridge-ref-jump-prev-file
         "h" #'lsp-bridge-ref-jump-prev-keyword
         "t" #'lsp-bridge-ref-jump-next-keyword
         "n" #'lsp-bridge-ref-jump-next-file)))
#+end_src

*** eglot
#+begin_src elisp
(eat/pkg eldoc-box)

(setq eglot-events-buffer-size 0
      eglot-sync-connect nil       ;; don't block of LSP connection attempts
      eglot-extend-to-xref t       ;; make eglot manage file out of project by `xref-find-definitions'
      eglot-ignored-server-capabilites '(:documentHighlightProvider :documentFormattingProvider :documentRangeFormattingProvider))

(setq-default eglot-workspace-configuration
              '((gopls
                 (usePlaceholders . t)
                 (staticcheck . t))
                ;; (pyright
                ;;  (autoImportCompletions . t)
                ;;  (useLibraryCodeForTypes . t)
                ;;  (diagnosticMode . "openFilesOnly")
                ;;  (typeCheckingMode . "basic")
                ;;  (logLevel . "verbose")
                ;;  (autoSearchPaths . t))
                ))

(when (executable-find "ltex-ls")
  (eat/hook 'message-mode-hook #'eglot-ensure))

(with-eval-after-load 'eglot
  (bind eglot-mode-map
        "M-RET"  #'eglot-code-actions
        "C-c r" #'eglot-rename
        "M-'" #'eglot-find-implementation)

  (add-to-list 'eglot-server-programs '(rust-mode "rust-analyzer"))
  (add-to-list 'eglot-server-programs '(sql-mode . ("sqls" "-config" "~/.config/sqls/config.yaml")))
  (add-to-list 'eglot-server-programs '(nix-mode . ("nixd")))
  (add-to-list 'eglot-server-programs '(message-mode . ("ltex-ls"))))

(add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-mode)


(eat/pkg eglot-hierarchy "https://github.com/dolmens/eglot-hierarchy")
#+end_src
** Citre
#+begin_src elisp
(eat/pkg citre)

(keymap-global-set "C-x c j" #'citre-jump)
(keymap-global-set "C-x c u" #'citre-update-this-tags-file)
(keymap-global-set "C-x c p" #'citre-peek)
(keymap-global-set "C-x c U" #'citre-global-update-database)
(keymap-global-set "C-x c r" #'citre-jump-to-reference)

(with-eval-after-load 'citre
  (keymap-global-set "C-x c J" #'citre-jump-back)
  ;; NOTE
  ;; Notice that GTAGSOBJDIRPREFIX must exist for gtags to use it. So you need to run:
  ;; $ mkdir -p ~/.cache/gtags/
  (keymap-global-set "C-x c P" #'citre-ace-peek-references)
  (setq citre-default-create-tags-file-location 'global-cache
        ;; citre-use-project-root-when-creating-tags t
        citre-prompt-language-for-ctags-command t
        citre-auto-enable-citre-mode-modes '(prog-mode))
  (with-eval-after-load 'cc-mode (require 'citre-lang-c))
  (with-eval-after-load 'dired (require 'citre-lang-fileref))
  (with-eval-after-load 'verilog-mode (require 'citre-lang-verilog)))

(with-eval-after-load 'citre-global
  (setenv "GTAGSOBJDIRPREFIX" (concat (getenv "HOME") "/.cache/gtags"))
  (setenv "GTAGSCONF" (concat (getenv "HOME") "/.globalrc"))
  (setenv "GTAGSLABEL" "native-pygments"))

(with-eval-after-load 'citre-peek
  (keymap-set citre-peek-keymap "M-l r" 'citre-peek-through-references))

(defun eat/citre-enable ()
  (interactive)
  (citre-mode 1)
  (add-hook 'find-file-hook #'citre-auto-enable-citre-mode))

(defun eat/citre-disable ()
  (interactive)
  (citre-mode 0)
  (remove-hook 'find-file-hook #'citre-auto-enable-citre-mode))
#+end_src
** Lang
*** Lisp
#+begin_src elisp
(eat/pkg aggressive-indent)

(eat/hook
 '(emacs-lisp-mode-hook
   lisp-interaction-mode-hook
   scheme-mode-hook
   lisp-mode-hook)
 #'aggressive-indent-mode)
#+end_src
*** Go
#+begin_src emacs-lisp
(eat/pkg go-mode)
(eat/pkg flymake-go-staticcheck)
(eat/pkg go-gen-test)
(eat/pkg go-tag)
(eat/pkg go-dlv)
(eat/pkg go-fill-struct)
(eat/pkg go-impl)
(eat/pkg gotest)

;; Install or update tools
(defvar go--tools '("golang.org/x/tools/gopls"
                    "golang.org/x/tools/cmd/goimports"
                    "honnef.co/go/tools/cmd/staticcheck"
                    "github.com/go-delve/delve/cmd/dlv"
                    "github.com/zmb3/gogetdoc"
                    "github.com/josharian/impl"
                    "github.com/cweill/gotests/..."
                    "github.com/fatih/gomodifytags"
                    "github.com/davidrjenni/reftools/cmd/fillstruct"
                    "github.com/rogpeppe/godef")
  "All necessary go tools.")

(defun go-update-tools ()
  "Install or update go tools."
  (interactive)
  (unless (executable-find "go")
    (user-error "Unable to find `go' in `exec-path'!"))

  (message "Installing go tools...")
  (dolist (pkg go--tools)
    (set-process-sentinel
     (start-process "go-tools" "*Go Tools*" "go" "install" "-v" "-x" (concat pkg "@latest"))
     (lambda (proc _)
       (let ((status (process-exit-status proc)))
         (if (= 0 status)
             (message "Installed %s" pkg)
           (message "Failed to install %s: %d" pkg status)))))))
(setq gofmt-command "goimports"
      gofmt-show-errors nil)
(add-hook 'go-test-mode-hook #'visual-line-mode)


;; Flymake-go-staticcheck
(defun eat/flymake-go-staticcheck-enable ()
  "Enable flymake-go-staticcheck for all go buffer.
Call `flymake-go-staticcheck-enable' interactive will only
enable this in current buffer, add to `go-mode-hook' to make
it enable on all go buffer."
  (interactive)
  (flymake-go-staticcheck-enable)
  (add-hook 'go-mode-hook #'flymake-go-staticcheck-enable))

;; Go-test
(setq go-test-verbose t
      ;; Do not cache test result.
      go-test-args "-count=1")
;; Go-tag
(setq go-tag-args (list "-transform" "camelcase"))
;; Bind
(with-eval-after-load 'go-mode
  (keymap-set go-mode-map "C-c t g" #'go-gen-test-dwim)
  (keymap-set go-mode-map "C-c t t" #'go-test-current-test)
  (keymap-set go-mode-map "C-c t a" #'go-tag-add)
  (keymap-set go-mode-map "C-c t r" #'go-tag-remove))
#+end_src
*** Nix
Install =rnix-lsp= and =nixfmt=.
#+begin_src emacs-lisp
(eat/pkg nix-mode)
#+end_src

*** Clojure
#+begin_src elisp
(eat/pkg clojure-mode)
(eat/pkg cider)
(eat/pkg clj-refactor)

(eat/hook 'clojure-mode-hook #'puni-mode)

(setq cider-repl-display-help-banner nil)

(with-eval-after-load 'clojure-mode
  ;; better indentation for compojure
  ;; https://github.com/weavejester/compojure/wiki/Emacs-indentation
  (define-clojure-indent
   (defroutes 'defun)
   (GET 2)
   (POST 2)
   (PUT 2)
   (DELETE 2)
   (HEAD 2)
   (ANY 2)
   (OPTIONS 2)
   (PATCH 2)
   (rfn 2)
   (let-routes 1)
   (context 2)))
#+end_src
*** C
#+begin_src elisp
(setq c-default-style "linux"
      c-basic-offset 4)
#+end_src
*** Python
#+begin_src elisp
(setq python-indent-offset 4
      python-shell-completion-native-enable nil
      python-indent-guess-indent-offset nil)


(eat/pkg pet)
;; Emacs 29+
;; This will turn on `pet-mode' on `python-mode' and `python-ts-mode'
(add-hook 'python-base-mode-hook 'pet-mode -10)
#+end_src
*** Sql
#+begin_src elisp
(setq sql-mysql-login-params '(user password server database port))
#+end_src
** Tree-sitter
1. Install =tree-sitter= on system.
2. Build emacs with tree sitter =--with-tree-sitter=.
3. Install language definitions to =/usr/local/lib= or =~/.config/emacs/tree-sitter= or =treesit-extra-load-path=.
4. On windows, copy dll files to Emacs’s bin directory.

Also check:
[[https://git.savannah.gnu.org/cgit/emacs.git/tree/admin/notes/tree-sitter/starter-guide?h=emacs-29][Emacs tree sitter start guide.]]
[[https://github.com/casouri/tree-sitter-module][Tree sitter language definitions build script.]]
~treesit-language-source-alist~
~treesit-install-language-grammar~

*** go
#+begin_src emacs-lisp
(with-eval-after-load 'go-ts-mode
  (require 'go-mode)

  (setq go-ts-mode-hook go-mode-hook
        go-ts-mode-indent-offset 4)

  (set-keymap-parent go-ts-mode-map go-mode-map))
#+end_src

*** Js etc...
#+begin_src emacs-lisp
(setq-default js-indent-level 2)
(add-hook 'tsx-ts-mode-hook #'setup-tsx)
(add-to-list 'auto-mode-alist '("\\.ts\\'" . tsx-ts-mode))
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))

(defun setup-tsx ()
  (fset 'js-find-symbol 'xref-find-definitions))
#+end_src

*** Rust
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
#+end_src
*** Remap major mode
#+begin_src emacs-lisp
(when (treesit-available-p)
  (push '(css-mode . css-ts-mode) major-mode-remap-alist)
  (push '(python-mode . python-ts-mode) major-mode-remap-alist)
  (push '(c-mode . c-ts-mode) major-mode-remap-alist)
  (push '(c++-mode . c++-ts-mode) major-mode-remap-alist)
  (push '(toml-mode . toml-ts-mode) major-mode-remap-alist)
  (push '(yaml-mode . yaml-ts-mode) major-mode-remap-alist)
  (push '(javascript-mode . tsx-ts-mode) major-mode-remap-alist)
  (push '(go-mode . go-ts-mode) major-mode-remap-alist))
#+end_src
*** olding
#+begin_src emacs-lisp
(defun treesit-fold-toggle (arg)
  "Toggle folding for the defun at point.

The first and last line of the defun are preserved, the rest are
folded.

If called interactively with argument (ARG), toggle the top-level
defun. Top-level folding and non-top-level folding are on
separate channels, meaning top-level toggle wouldn’t unfold
non-top-level folding, and vice versa.

What constitutes as a defun is determined by the major mode.
This command only works in a tree-sitter major mode."
  (interactive "p")
  (let* ((tactic (if (eq arg 4) 'top-level 'nested))
         (node (let ((treesit-defun-tactic tactic))
                 (treesit-defun-at-point))))
    (if (null node)
        (user-error "No defun at point")
      (let ((indent (save-excursion
                      (goto-char (treesit-node-start node))
                      (current-indentation)))
            ;; We leave the first and last line visible.
            (beg (save-excursion
                   (goto-char (treesit-node-start node))
                   (forward-line 1)
                   (point)))
            (end (save-excursion
                   (goto-char (treesit-node-end node))
                   (forward-line -1)
                   (line-end-position)))
            (has-fold nil))
        ;; If there are existing overlays, this defun must have been
        ;; folded, then unfold it. But if the folding overlay has
        ;; different tactic than the one we are using now, leave it.
        (dolist (ov (overlays-in beg end))
          (when (and (overlay-get ov 'treesit-fold)
                     (eq (overlay-get ov 'treesit-fold-tactic)
                         tactic))
            (setq has-fold t)
            (delete-overlay ov)))

        ;; If there aren’t existing overlay with the same tactic, add
        ;; new folding.
        (when (null has-fold)
          (let ((ov (make-overlay beg end nil t nil)))
            (overlay-put ov 'treesit-fold t)
            (overlay-put ov 'treesit-fold-tactic tactic)
            (overlay-put ov 'display (concat (make-string indent ?\s)
                                             "..."))))))))
#+end_src
* Tools
** Visual Fill Column
Center current window.
#+begin_src emacs-lisp
(eat/pkg visual-fill-column)

(add-hook 'visual-fill-column-mode-hook #'visual-line-mode)

(setq visual-fill-column-center-text t)
#+end_src
** Rg
#+begin_src elisp
(eat/pkg wgrep)
(eat/pkg urgrep)

(with-eval-after-load 'urgrep
  (require 'urgrep-wgrep))
#+end_src
** Translate
#+begin_src elisp
(eat/pkg go-translate)

(setq gts-translate-list '(("en" "zh")))

(eat/pkg fanyi)

(defvar gts-deepl-auth-key nil
  "Free auto key to access deepl api.")

(defun eat/translate ()
  (interactive)
  (if (use-region-p)
      (gts-do-translate)
    (fanyi-dwim2)))

(keymap-global-set "C-c y" #'eat/translate)

(with-eval-after-load 'go-translate
  (setq gts-default-translator
        (gts-translator
         :picker
         (gts-noprompt-picker)

         :engines
         (list
          (gts-google-rpc-engine)
          (gts-bing-engine)
          (when gts-deepl-auth-key
            (gts-deepl-engine :auth-key gts-deepl-auth-key :pro nil)))

         :render
         (gts-buffer-render))))

(defun eat/context-translate (menu click)
  "My context MENU to translate text."
  (define-key-after menu [dictionary-lookup]
    '(menu-item "Translate" eat/translate))
  menu)

;; hook into context menu
(add-hook 'context-menu-functions #'eat/context-translate)
#+end_src
** Ghelp
#+begin_src elisp
(eat/pkg ghelp "https://github.com/casouri/ghelp.git")

(autoload #'ghelp-describe          "ghelp")
(autoload #'ghelp-describe-function "ghelp")
(autoload #'ghelp-describe-variable "ghelp")
(autoload #'ghelp-describe-key      "ghelp")
(autoload #'ghelp-describe-elisp    "ghelp")

(bind global-map
      "C-h C-h" #'ghelp-describe
      "C-h f"   #'ghelp-describe-function
      "C-h v"   #'ghelp-describe-variable
      "C-h k"   #'ghelp-describe-key
      "C-h o"   #'ghelp-describe-elisp)
(with-eval-after-load 'ghelp
  (bind global-map "C-h r" #'ghelp-resume))
#+end_src

** Restclient
#+begin_src emacs-lisp
(eat/pkg restclient)
#+end_src

** leetcode
~pip3 install my_cookies~

Set cookie manually:
~(url-cookie-store "LEETCODE_SESSION" leetcode-session nil "leetcode.com" "/" t)~
~(url-cookie-store "csrftoken" leetcode-csrftoken nil "leetcode.com" "/" t)~

#+begin_src emacs-lisp
(eat/pkg leetcode)

(setq leetcode-prefer-language "golang")
(setq leetcode-save-solutions t)
(setq leetcode-directory "~/Dropbox/leetcode")
#+end_src
** Draw

- plantuml
- graphviz
- d2, written in go
- tikz
- exclidraw

*** d2

#+begin_src emacs-lisp
(eat/pkg d2-mode)
(eat/pkg ob-d2)
#+end_src
** AI
*** copilot

#+begin_src emacs-lisp
(eat/pkg copilot "https://github.com/zerolfx/copilot.el")

(add-hook 'prog-mode-hook 'copilot-mode)

(with-eval-after-load 'copilot
  (add-to-list 'copilot-major-mode-alist '("go" . "go"))
  (add-to-list 'copilot-major-mode-alist '("go-ts" . "go"))
  (define-key copilot-completion-map (kbd "C-TAB") 'copilot-accept-completion)
  (define-key copilot-completion-map (kbd "C-<tab>") 'copilot-accept-completion)
  (define-key copilot-completion-map (kbd "M-L") 'copilot-clear-overlay)
  (define-key copilot-completion-map (kbd "M-N") 'copilot-next-completion)
  (define-key copilot-completion-map (kbd "M-P") 'copilot-previous-completion)
  (with-eval-after-load 'meow
    (add-to-list 'copilot-enable-predicates 'meow-insert-mode-p)))
#+end_src
*** Bing Chat
- Install the cookie editor extension for [[https://microsoftedge.microsoft.com/addons/detail/cookieeditor/neaplmfkghagebokkhpjpoebhdledlfi][Egde]]
- Go to bing.com
- Open the extension
- Click “Export” on the bottom right (This saves your cookies to clipboard)
- Paste your cookies into a file cookies.json
- Set =aichat-bingai-cookies-file= to your cookies.json path

For openai, set api key in auth file:
=machine platform.openai.com login aichat-openai password your-app-key=

#+begin_src elisp
(eat/pkg websocket)
(eat/pkg async-await)
(eat/pkg markdown-mode)
(eat/pkg emacs-aichat "https://github.com/xhcoding/emacs-aichat")
(setq aichat-bingai-cookies-file "~/Dropbox/.bingcookies.json"
      aichat-bingai-chat-file "~/Sync/aichat.md")
(autoload #'aichat-bingai-chat "aichat-bingai.el" nil t)
(autoload #'aichat-bingai-assistant "aichat-bingai.el" nil t)
(autoload #'aichat-openai-assistant "aichat-openai.el" nil t)
#+end_src
*** gptel
Set ~gptel-api-key~.

#+begin_src emacs-lisp
(eat/pkg gptel)

(setq gptel-default-mode 'org-mode)

(setq gptel-api-key (auth-source-pick-first-password :host "api.openai.com"))
#+end_src

*** gpt-commit
#+begin_src emacs-lisp
(eat/pkg gpt-commit)

(autoload 'gpt-commit-message "gpt-commit" nil t)

(setq gpt-commit-openai-key
      (auth-source-pick-first-password :host "api.openai.com"))
#+end_src

*** tabnine
#+begin_src emacs-lisp
(eat/pkg tabnine)
#+end_src
** direnv
#+begin_src emacs-lisp
(eat/pkg envrc)

(add-hook 'after-init-hook #'envrc-global-mode)
#+end_src

* Org
** config
#+begin_src elisp
(defun eat/org-hook ()
  "Configuration for Org Mode."
  (org-indent-mode)
  (electric-pair-local-mode -1)
  (electric-quote-local-mode)
  (electric-indent-local-mode -1))

(defun eat/insert-zero-width-space ()
  (interactive)
  (insert-char ?\u200B)) ;; code for ZERO WIDTH SPACE
(keymap-global-set "C-x 8 0" #'eat/insert-zero-width-space)

(add-hook 'org-mode-hook #'eat/org-hook)

;; https://nixos.wiki/wiki/TexLive
(setq org-latex-compiler "lualatex")
(setq org-preview-latex-default-process 'dvisvgm)

(setq org-directory (expand-file-name "~/Dropbox/org"))
(defvar load-language-list '((emacs-lisp . t)
                             (python . t)
                             (js . t)
                             (C . t)
                             (shell . t)
                             (plantuml . t)))
(setq org-plantuml-exec-mode 'plantuml)

(with-eval-after-load 'org
  (setq org-edit-src-content-indentation 0
        org-special-ctrl-a/e t
        org-special-ctrl-k t
        ;; comment after emacs merge noverly branch
        ;; org-src-fontify-natively nil ;; see it in `org-edit-special'
        org-src-window-setup 'current-window
        org-return-follows-link t
        org-confirm-babel-evaluate nil
        org-image-actual-width '(300)
        org-ellipsis " ▾ "
        ;; Faster loading
        org-modules nil
        org-log-done t)
  (require 'org-tempo) ;; see `org-structure-template-alist'
  (require 'ob)
  (require 'ob-dot)
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (org-babel-do-load-languages 'org-babel-load-languages load-language-list))
#+end_src
** ox
*** gfm
#+begin_src elisp
(eat/pkg ox-gfm)
(with-eval-after-load 'ox-gfm
  (add-to-list 'org-export-backends 'md))
#+end_src

** ob
*** restclient
#+begin_src elisp
(eat/pkg ob-restclient)
(cl-pushnew '(restclient . t) load-language-list)
(with-eval-after-load 'ob-restclient
  (add-to-list 'org-structure-template-alist '("rc" . "src restclient")))
#+end_src

*** go
#+begin_src elisp
(eat/pkg ob-go)

(cl-pushnew '(go .t) load-language-list)

(with-eval-after-load 'ob-go
  (add-to-list 'org-structure-template-alist '("go" . "src go")))
#+end_src

** copture
#+begin_src elisp
(keymap-global-set "C-c c" 'org-capture)

(defun eat/org-capture-inbox ()
  (interactive)
  (org-capture nil "i"))
(keymap-global-set "C-c I" #'eat/org-capture-inbox)

(setq org-default-notes-file (concat org-directory "/default-notes.org")
      org-capture-templates
      `(("i" "Inbox" entry (file "~/Dropbox/org/inbox.org")
         "* TODO %?\n:PROPERITIES:\n:Created: %T\n:END:")
        ("w" "Work" entry (file+olp+datetree "~/Dropbox/org/Work.org")
         "* %^{Title}\n:PROPERITIES:\n:Created: %T\n:END:" :tree-type week)
        ("n" "Note" entry (file "~/Dropbox/org/Notes.org")
         "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)))
#+end_src

** agenda
#+begin_src elisp
(setq org-agenda-files (list org-directory)
      org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t% s")
                                 (todo   . " ")
                                 (tags   . " %i %-12:c")
                                 (search . " %i %-12:c"))
      ;; hide any tag
      org-agenda-hide-tags-regexp "."
      org-agenda-current-time-string
      "⭠ now ─────────────────────────────────────────────────")

(keymap-global-set "C-c a" 'org-agenda)
#+end_src

** org-appear
#+begin_src elisp
(eat/pkg org-appear)
(setq org-hide-emphasis-markers t)
(add-hook 'org-mode-hook #'org-appear-mode)
#+end_src

** valign
#+begin_src elisp
(eat/pkg valign)
(setq valign-fancy-bar t)
(when (display-graphic-p)
  (add-hook 'org-mode-hook #'valign-mode))
#+end_src
** toc
#+begin_src elisp
(eat/pkg toc-org)
#+end_src
** Export to html
*** TODO Inline image
For now use ~pandoc --embed-resources --standalone~.

#+begin_src emacs-lisp
(defun eat/org-export-to-html ()
  "Convert current org buffer to html with image embed.
Need pandoc installed."
  (interactive)
  (let* ((from (buffer-file-name))
         (to (concat (file-name-sans-extension from) ".html")))
    (shell-command (format "pandoc --embed-resources --standalone %s -o %s" from to))
    (find-file to)))
#+end_src
*** Syntax highlighting
#+begin_src emacs-lisp
(eat/pkg htmlize)
#+end_src

** org-variable-pitch
#+begin_src emacs-lisp
(eat/pkg org-variable-pitch)
#+end_src
** prose-mode for writting
#+begin_src elisp
(defvar eat/prose-mode-map
  (let ((map (make-sparse-keymap)))
    (keymap-set map "C-a" #'beginning-of-visual-line)
    (keymap-set map "C-e" #'end-of-visual-line)
    map)
  "Mode map for ‘eat/prose-mode’.")

(define-minor-mode eat/prose-mode
  "A mode that optimizes for prose editing."
  :lighter " PROSE"
  :keymap eat/prose-mode-map
  (if eat/prose-mode
      (progn
        (org-variable-pitch-minor-mode 1)
        (visual-fill-column-mode 1)
        (setq-local cursor-type 'bar)
        (setq-local line-spacing 0.15)
        (setq-local whitespace-style '(tab-mark))
        (turn-off-auto-fill)
        (whitespace-mode))
    (org-variable-pitch-minor-mode -1)
    (visual-fill-column-mode -1)
    (whitespace-mode -1)
    (variable-pitch-mode -1)
    (kill-local-variable 'line-spacing)
    (kill-local-variable 'cursor-type)))
#+end_src
** org-download                                                       :deps:
#+begin_src emacs-lisp
(eat/pkg org-download)

;; NOTE from doomemacs
(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))

;; HACK We add these manually so that org-download is truly lazy-loaded
(pushnew! dnd-protocol-alist
          '("^\\(?:https?\\|ftp\\|file\\|nfs\\):" . org-download-dnd)
          '("^data:" . org-download-dnd-base64))
(advice-add #'org-download-enable :override #'ignore)

(setq org-download-image-dir "img"
      org-download-image-org-width 800)
#+end_src
** org-present
#+begin_src emacs-lisp
(eat/pkg org-present)

(add-hook 'org-present-mode-hook
          #'(lambda ()
              (eat/prose-mode -1)
              ;; full frame
              (toggle-frame-fullscreen)
              ;; display header line so that we can use face-remapping
              ;; to create big enought blank space at the top
              (setq-local header-line-format " ")
              ;; incraease font size
              (setq-local
               face-remapping-alist
               '((default (:height 1.5) variable-pitch)
                 (header-line (:height 4.0) variable-pitch)
                 (org-document-title (:height 1.75) org-document-title)
                 (org-code (:height 1.55) org-code)
                 (org-verbatim (:height 0.7) org-verbatim)
                 (org-block (:height 1.25) org-block)
                 (org-block-begin-line (:height 0.7) org-block)))
              ;; from org-present, after font rescale
              (org-present-read-only)
              (org-present-hide-cursor)
              (org-display-inline-images)
              ;; center the screen
              (visual-fill-column-mode 1)
              (setq-local visual-fill-column-center-text t)
              (setq-local visual-fill-column-width 90)
              ;; hide mode line
              (hide-mode-line-mode 1)
              ;;
              (org-variable-pitch-minor-mode 1)))

(add-hook 'org-present-mode-quit-hook
          #'(lambda ()
              (toggle-frame-fullscreen)
              (hide-mode-line-mode -1)
              (kill-local-variable 'face-remapping-alist)
              (kill-local-variable 'header-line-format)
              (eat/prose-mode 1)
              ;; from org-present
              (org-present-show-cursor)
              (org-remove-inline-images)
              (org-present-read-write)))

(defun my/org-present-prepare-slide (buffer-name heading)
  ;; Show only top-level hedlines.
  (org-overview)
  ;; Unfold the current entry.
  (org-fold-show-entry)
  ;; Show only direct subheadings of the slide but don't expand them.
  (org-fold-show-children))

(add-hook 'org-present-after-navigate-functions #'my/org-present-prepare-slide)
#+end_src
** cite
M-x ~org-cite-insert~

#+begin_src elisp
(eat/pkg citar)

(setq org-cite-global-bibliography '("~/Dropbox/bib/references.bib")
      org-cite-insert-processor 'citar
      org-cite-follow-processor 'citar
      org-cite-activate-processor 'citar
      citar-bibliography org-cite-global-bibliography)

#+end_src
* Application
** Magit
*** config
#+begin_src emacs-lisp
(eat/pkg magit)

(add-hook 'git-commit-setup-hook #'git-commit-turn-on-flyspell)
(add-hook 'magit-diff-visit-file #'my-recenter-and-pulse-line)

(with-eval-after-load 'magit
  (fullframe magit-status magit-mode-quit-window)
  (setq-default magit-diff-refine-hunk t))
#+end_src

*** magit-delta
#+begin_src emacs-lisp
(eat/pkg magit-delta)
(add-hook 'magit-mode-hook #'magit-delta-mode)
#+end_src

*** diff-hl
#+begin_src emacs-lisp
(eat/pkg diff-hl)

(eat/hook '(prog-mode-hook conf-mode-hook ) #'diff-hl-mode)
(add-hook 'dired-mode-hook #'diff-hl-dired-mode)

(setq diff-hl-draw-borders nil)

(with-eval-after-load 'diff-hl
  (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)
  ;; Highlight on-the-fly
  (diff-hl-flydiff-mode 1)
  (unless (display-graphic-p)
    ;; Fall back to the display margin since the fringe is unavailable in tty
    (diff-hl-margin-mode 1)
    ;; Avoid restoring `diff-hl-margin-mode'
    (with-eval-after-load 'desktop
      (add-to-list 'desktop-minor-mode-table
                   '(diff-hl-margin-mode nil)))))
#+end_src

*** magit-todo
#+begin_src emacs-lisp
(eat/pkg magit-todos)

(with-eval-after-load 'magit
  (require 'magit-todos)
  (magit-todos-mode))
#+end_src
** File Manager
*** dired
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook #'dired-hide-details-mode)

(setq dired-dwim-target t
      dired-kill-when-opening-new-dired-buffer t
      dired-auto-revert-buffer t)

(with-eval-after-load 'dired
  (setq dired-listing-switches
        "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group")
  (keymap-set dired-mode-map "C-c C-p" #'wdired-change-to-wdired-mode)
  (define-key dired-mode-map (kbd "h") #'dired-up-directory)
  (define-key dired-mode-map [mouse-2] #'dired-find-file))

#+end_src

*** dirvish
#+begin_src elisp
(eat/pkg dirvish)

(add-hook 'after-init-hook #'dirvish-override-dired-mode)

(setq dirvish-attributes '(vc-state subtree-state))

(when (eat/modulep '+icon)
  (add-to-list 'dirvish-attributes 'nerd-icons))

(keymap-global-set "C-c f" #'dirvish-fd)
(keymap-global-set "<f1>" #'dirvish-side)

(with-eval-after-load 'dirvish
  ;; (dirvish-side-follow-mode) ;; FIXME
  (bind dirvish-mode-map
        "TAB" #'dirvish-subtree-toggle
        "<tab>" #'dirvish-subtree-toggle
        "a" #'dirvish-quick-access
        "f" #'dirvish-file-info-menu
        "y" #'dirvish-yank-menu
        "N" #'dirvish-narrow
        "H" #'dirvish-history-jump
        "s" #'dirvish-quicksort
        "v" #'dirvish-vc-menu
        "M-f" #'dirvish-history-go-forward
        "M-b" #'dirvish-history-go-backward
        "M-l" #'dirvish-ls-switches
        "M-m" #'dirvish-mark-menu
        "M-t" #'dirvish-layout-toggle
        "M-s" #'dirvish-setup-menu
        "M-e" #'dirvish-emerge-menu
        "M-j" #'dirvish-fd-jump
        "<mouse-1>" #'dirvish-subtree-toggle-or-open
        "<mouse-2>" #'dired-mouse-find-file-other-window
        "<mouse-3>" #'dired-mouse-find-file))
#+end_src

** TODO Terminal
Use eat under linux and macos, use eshell under windows.
#+begin_src elisp
(eat/pkg eat)

(keymap-global-set "C-`" #'eat)

(with-eval-after-load 'eat
  (bind eat-mode-map "C-`" #'eat/quit))

(setq eat-kill-buffer-on-exit t)

(eat/hook 'eshell-load-hook '(eat-eshell-mode eat-eshell-visual-command-mode))

;; Quick editing in `describe-variable'
(with-eval-after-load 'help-fns
  (put 'help-fns-edit-variable 'disabled nil))
#+end_src

** Mail, News
#+begin_src elisp
;;; gnus
(setq
 gnus-use-cache t
 gnus-use-scoring nil
 gnus-suppress-duplicates t
 gnus-novice-user nil
 gnus-expert-user t
 gnus-interactive-exit 'quiet
 gnus-inhibit-startup-message t
 gnus-select-method '(nnnil "")
 gnus-secondary-select-methods
 `((nntp "gmane" (nntp-address "news.gmane.io"))
   (nntp "nntp.lore.kernel.org")
   (nnimap "Gmail"
           (nnimap-user ,eat/user-mail-address)
           (nnimap-inbox "INBOX")
           (nnimap-address "imap.gmail.com")
           (nnimap-stream ssl)
           (nnimap-expunge 'never)
           ;; @see http://www.gnu.org/software/emacs/manual/html_node/gnus/Expiring-Mail.html
           ;; press 'E' to expire email
           (nnmail-expiry-target "nnimap+Gmail:[Gmail]/Trash")
           (nnmail-expiry-wait 90)))
 ;; Startup functions
 gnus-save-killed-list nil
 gnus-check-new-newsgroups nil
 ;; No other newsreader is used.
 gnus-save-newsrc-file nil
 gnus-read-newsrc-file nil
 gnus-subscribe-newsgroup-method 'gnus-subscribe-interactively
 ;; Emacs 28 introduces a unified query lang
 gnus-search-use-parsed-queries t
 ;; Article mode for Gnus
 gnus-visible-headers (rx line-start (or "From"
                                         "Subject"
                                         "Mail-Followup-To"
                                         "Date"
                                         "To"
                                         "Cc"
                                         "Newsgroups"
                                         "User-Agent"
                                         "X-Mailer"
                                         "X-Newsreader")
                          ":")
 gnus-article-sort-functions '((not gnus-article-sort-by-number)
                               (not gnus-article-sort-by-date))
 gnus-article-browse-delete-temp t
 ;; Display more MINE stuff
 gnus-mime-display-multipart-related-as-mixed t
 ;; Asynchronous support for Gnus
 gnus-asynchronous t
 gnus-use-header-prefetch t
 ;; Cache interface for Gnus
 gnus-cache-enter-articles '(ticked dormant unread)
 gnus-cache-remove-articles '(read)
 gnus-cacheable-groups "^\\(nntp\\|nnimap\\)")

;; Group
(setq
 ;;          indentation ------------.
 ;;  #      process mark ----------. |
 ;;                level --------. | |
 ;;           subscribed ------. | | |
 ;;  %          new mail ----. | | | |
 ;;  *   marked articles --. | | | | |
 ;;                        | | | | | |  Ticked    New     Unread  open-status Group
 gnus-group-line-format "%M%m%S%L%p%P %1(%7i%) %3(%7U%) %3(%7y%) %4(%B%-45G%) %d\n"
 gnus-group-sort-function '(gnus-group-sort-by-level gnus-group-sort-by-alphabet))

(add-hook 'gnus-group-mode-hook #'gnus-topic-mode)

;; Summary
(setq
 ;; Pretty marks
 gnus-sum-thread-tree-root            "┌ "
 gnus-sum-thread-tree-false-root      "◌ "
 gnus-sum-thread-tree-single-indent   "◎ "
 gnus-sum-thread-tree-vertical        "│"
 gnus-sum-thread-tree-indent          "  "
 gnus-sum-thread-tree-leaf-with-other "├─►"
 gnus-sum-thread-tree-single-leaf     "╰─►"
 gnus-summary-line-format "%U%R %3d %[%-23,23f%] %B %s\n"
 ;; Threads!  I hate reading un-threaded email -- especially mailing
 ;; lists.  This helps a ton!
 gnus-summary-make-false-root 'adopt
 gnus-simplify-subject-functions '(gnus-simplify-subject-re gnus-simplify-whitespace)
 gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject
 gnus-thread-indent-level 2
 ;; Filling in threads
 ;; 2 old articles are enough for memory
 gnus-fetch-old-headers 2
 gnus-fetch-old-ephemeral-headers 2
 gnus-build-sparse-threads 'some
 ;; Sorting
 gnus-thread-sort-functions '(gnus-thread-sort-by-most-recent-date)
 gnus-subthread-sort-functions '(gnus-thread-sort-by-date)
 ;; Viewing
 gnus-view-pseudos 'automatic
 gnus-view-pseudo-asynchronously t
 ;; No auto select
 gnus-auto-select-first nil
 gnus-auto-select-next nil
 gnus-paging-select-next nil)

(add-hook 'gnus-select-group-hook #'gnus-group-set-timestamp)
(add-hook 'gnus-summary-mode-hook #'hl-line-mode)

(with-eval-after-load 'gnus-topic
  (setq gnus-topic-alist '(("Gmail"
                            "nnimap+Gmail:INBOX"
                            "nnimap+Gmail:[Gmail]/Spam"
                            "nnimap+Gmail:[Gmail]/Starred"
                            "nnimap+Gmail:[Gmail]/All Mail"
                            "nnimap+Gmail:[Gmail]/Important"
                            "nnimap+Gmail:[Gmail]/Trash"
                            "nnimap+Gmail:[Gmail]/Sent Mail"
                            "nnimap+Gmail:[Gmail]/Drafts"
                            "nnimap+Gmail:emacs"
                            "nnimap+Gmail:golang")
                           ("misc"
                            "nndraft:drafts")
                           ("Gnus"))))

;;; message
(add-hook 'message-mode-hook #'auto-fill-mode)
(setq message-kill-buffer-on-exit t
      message-mail-alias-type 'ecomplete
      ;; Personal Information
      user-full-name eat/user-full-name
      user-mail-address eat/user-mail-address
      message-signature user-full-name
      smtpmail-smtp-user user-mail-address
      ;; Send email through SMTP
      send-mail-function #'smtpmail-send-it
      message-send-mail-function #'message-use-send-mail-function
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587)


;; read html mail
(eat/pkg w3m)
(setq mm-text-html-renderer 'w3m)
#+end_src

*** fontify patch
#+begin_src emacs-lisp
(eat/pkg fontify-patch "https://github.com/whame/fontify-patch")

(add-hook 'gnus-part-display-hook 'fontify-patch-buffer)
#+end_src

** TODO Rss
Use builtin newsticker with freshrss.

* Module
** Icon
#+begin_src elisp
(when (eat/modulep '+icon)
  ;; run `nerd-icons-install-fonts'
  (eat/pkg nerd-icons)

  ;; ttf-nerd-fonts-symbols-1000-em-mono
  (eat/pkg nerd-icons-ibuffer)
  (add-hook 'ibuffer-mode-hook #'nerd-icons-ibuffer-mode)

  (eat/pkg nerd-icons-completion)
  (add-hook 'minibuffer-setup-hook #'nerd-icons-completion-mode)
  )
#+end_src
** Telega
Need =telegram-tdlib=.
Run =docker pull zevlg/telega-server:latest=

#+begin_src elisp
(when (eat/modulep '+telega)
  (eat/pkg telega)
  (setq telega-use-docker t
        telega-chat-fill-column 75
        telega-server-libs-prefix "/usr"
        telega-translate-to-language-by-default "zh")

  (defun eat/telega-root-setup ()
    ;; (eat/fixed-pitch-setup) ;; FIXME
    (hl-line-mode 1))
  (add-hook 'telega-root-mode-hook 'eat/telega-root-setup)

  (defun eat/telega-chat-setup ()
    ;; (make-variable-buffer-local 'face-font-rescale-alist)
    ;; (add-to-list 'face-font-rescale-alist `(,eat/font-chinese . 0.9))
    ;; (add-to-list 'face-font-rescale-alist `(,eat/font-emoji . 0.8))
    (require 'yasnippet)
    (yas-minor-mode-on)
    (visual-line-mode)
    (hl-line-mode))
  (add-hook 'telega-chat-mode-hook #'eat/telega-chat-setup)

  (defun lg-telega-chat-update (chat)
    (with-telega-root-buffer
      (hl-line-highlight)))
  (add-hook 'telega-chat-update-hook 'lg-telega-chat-update)

  (with-eval-after-load 'telega
    (add-hook 'telega-load-hook #'telega-notifications-mode)
    (add-hook 'telega-load-hook #'telega-appindicator-mode)

    (setq telega-chat-input-format "›"
          telega-animation-play-inline nil
          telega-video-play-inline nil
          ;; make sticker larger to read
          telega-sticker-size '(10 . 24)
          ;; change reply symbol
          telega-symbol-reply "↫"
          ;; set date format for old messages
          telega-old-date-format "%Y/%M/%D")

    ;; syntax highlighting in telega code
    (require 'telega-mnz)
    (global-telega-mnz-mode 1)))
#+end_src

** Blog (org-static-blog)
#+begin_src elisp
(when (eat/modulep '+blog)
  (eat/pkg org-static-blog)
  (setq org-static-blog-publish-title "404cn's blog"
        org-static-blog-publish-url "https://404cn.github.io/"
        org-static-blog-publish-directory "~/p/blog/"
        org-static-blog-posts-directory "~/p/blog/posts/"
        org-static-blog-drafts-directory "~/p/blog/drafts/"
        org-static-blog-enable-tags t
        org-static-blog-use-preview t
        org-static-blog-preview-ellipsis ""
        org-export-with-toc nil
        org-export-with-section-numbers nil)
  (with-eval-after-load 'org-static-blog
    (setq org-static-blog-page-header (get-string-from-file "~/p/blog/static/header.html")
          org-static-blog-page-preamble (get-string-from-file "~/p/blog/static/preamble.html")
          org-static-blog-page-postamble (get-string-from-file "~/p/blog/static/postamble.html"))))
#+end_src

** Note Taking (xeft)
Need =xapian-core=.

#+begin_src elisp
(when (eat/modulep '+note-taking)
  (eat/pkg xeft)
  (setq xeft-directory "~/Dropbox/org/roam"
        xeft-default-extension "org"
        xeft-database "~/.xeft/db")
  (with-eval-after-load 'xeft
    (require 'flique)
    (add-hook 'xeft-find-file-hook #'bklink-minor-mode)
    (add-hook 'bklink-minor-mode-hook #'auto-fill-mode)))
#+end_src
* Modes
#+begin_src elisp
(eat/pkg toml-mode)
(eat/pkg yaml-mode)
(eat/pkg docker-compose-mode)
(eat/pkg dockerfile-mode)
(eat/pkg k8s-mode)
(eat/pkg git-modes)
(eat/pkg terraform-mode)
(eat/pkg markdown-mode)
(eat/pkg markdown-toc)
(eat/pkg protobuf-mode)
(eat/pkg csv-mode)

(add-hook 'csv-mode-hook
          #'(lambda ()
              (setq-local auto-hscroll-mode t)))

(add-hook 'toml-mode-hook #'goto-address-prog-mode)
(add-hook 'yaml-mode-hook #'goto-address-prog-mode)

(add-to-list 'auto-mode-alist
             (cons "/.dockerignore\\'" 'gitignore-mode))

(setq markdown-enable-wiki-links t
      markdown-italic-underscore t
      markdown-asymmetric-header t
      markdown-make-gfm-checkboxes-buttons t
      markdown-gfm-uppercase-checkbox t
      markdown-fontify-code-blocks-natively t)

(with-eval-after-load "protobuf-mode"
  (add-hook 'protobuf-mode-hook
            (lambda ()
              (setq imenu-generic-expression
                    '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2))))))
#+end_src

* Site Lisp
** Load Path
#+begin_src elisp
(add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
(add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))
#+end_src
** Form Feed
#+begin_src elisp
(autoload #'form-feed-mode "form-feed")
(eat/hook '(emacs-lisp-mode-hook text-mode-hook special-mode-hook) #'form-feed-mode)
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/form-feed.el
;;; form-feed.el --- Display ^L glyphs as horizontal lines

;; Copyright (C) 2014 Vasilij Schneidermann <mail@vasilij.de>

;; Author: Vasilij Schneidermann <mail@vasilij.de>
;; Maintainer: Yuan Fu <casouri@gmail.com>
;; URL: https://depp.brause.cc/form-feed
;; Keywords: faces
;; Version: 0.2.3

;; This file is NOT part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING. If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:

;; This minor mode displays page delimiters which usually appear as ^L
;; glyphs on a single line as horizontal lines spanning the entire
;; window.  It is suitable for inclusion into mode hooks and is
;; intended to be used that way.  The following snippet would enable
;; it for Emacs Lisp files for instance:
;;
;;     (add-hook 'emacs-lisp-mode-hook 'form-feed-mode)

;;; Note:
;;
;; Yuan: I removed a bunch of functions and variables and changed
;; font-lock to jit-lock.


;;; Code:


;;; variables

(defgroup form-feed nil
  "Turn ^L glyphs into horizontal lines."
  :prefix "form-feed-"
  :group 'faces)

(defface form-feed-line
  '((((type graphic)
      (background light)) :strike-through "black")
    (((type graphic)
      (background dark)) :strike-through "white")
    (((type tty)) :inherit font-lock-comment-face :underline t))
  "Face for form-feed-mode lines."
  :group 'form-feed)

(defcustom form-feed-line-width t
  "Width of the form feed line.
It may be one of the following values:

t: Full width.

floating point number: Ratio of full width.  A value of 0.5 would
use half the width.

positive integer number: Width as measured in columns.  A value
of 80 would use a 80 characters wide line.

negative integer number: Full width minus specified number of
columns.  A value of -1 would leave the last column empty."
  :type '(choice (const :tag "Full width" t)
                 (float :tag "Ratio")
                 (integer :tag "Columns"))
  :group 'form-feed)

(defvar form-feed--line-width
  (cond
   ((integerp form-feed-line-width)
    (if (>= form-feed-line-width 0)
        form-feed-line-width
      `(- text ,(abs form-feed-line-width))))
   ((floatp form-feed-line-width)
    `(,form-feed-line-width . text))
   (t 'text)))

(defvar form-feed--font-lock-keywords
  ;; NOTE see (info "(elisp) Search-based fontification") and the
  ;; `(MATCHER . SUBEXP-HIGHLIGHTER)' section
  `((,page-delimiter 0 form-feed--font-lock-face t)))

(defcustom form-feed-lighter " ^L"
  "Lighter for `form-feed-mode'."
  :type 'string
  :group 'form-feed
  :risky t)


;;; Functions

(defun form-feed-fontify (beg end)
  "Fonfity page breaks at beginning of line between BEG and END."
  (goto-char beg)
  (while (re-search-forward "^" end t)
    (put-text-property (match-beginning 0) (match-end 0)
                       'font-lock-face 'form-feed-line)
    (put-text-property (match-beginning 0) (match-end 0)
                       'display `(space :width ,form-feed--line-width))))

;;;###autoload
(define-minor-mode form-feed-mode
  "Toggle form-feed-mode.

This minor mode displays page delimiters which usually appear as ^L
glyphs on a single line as horizontal lines spanning the entire
window."
  :lighter form-feed-lighter
  (if form-feed-mode
      (jit-lock-register #'form-feed-fontify)
    (jit-lock-unregister #'form-feed-fontify))
  (jit-lock-refontify))

(provide 'form-feed)
;;; form-feed.el ends here
#+end_src

** Dired Toggle Sudo
#+begin_src elisp
(eat/pkg dired-toggle-sudo)
#+end_src

** Color Outline
#+begin_src elisp
(autoload #'color-outline-mode "color-outline")
(add-hook 'prog-mode-hook #'color-outline-mode)
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/color-outline.el
;;; color-outline.el --- Outline w/ color      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; This package is a basic version of outshine.el, it provides a quick
;; and easy way of setting up headline patterns and integration with
;; outline commands, highlighting of headlines and imenu support.
;;
;; Usage:
;;
;; M-x color-outline-mode RET
;;
;; Header level is determined by the number of comment characters.
;; The first level header starts from 3 comment characters.
;; For example, in ‘emacs-lisp-mode’:
;;
;;     ;;; Header 1
;;     ;;;; Header 2
;;     ;;;;; Header 3
;;
;; In ‘python-mode’:
;;
;;     ### Header 1
;;     #### Header 2
;;     ##### Header 3
;;
;; To toggle each header, use outline commands.
;;
;; Ideally, ‘comment-start’ defined by major modes are enough for
;; setting up color-outline, however, sometimes ‘comment-char’ is not
;; sufficient. Then you can add support for new major modes by
;;
;;     (color-outline-define-header MODE COMMENT-CHAR COMMENT-BEGIN)
;;
;; For example, COMMENT-CHAR for ‘python-mode’ is “#”. It can be more
;; than one character. COMMENT-BEGIN is the (possibly empty) beginning
;; of the header. For example, in OCaml, comments are (* ... *). Then
;; COMMENT-BEGIN is “(” and COMMENT-CHAR is “*”.
;;
;; Instead of using ‘color-outline-define-header’, you can also modify
;; ‘color-outline-comment-char-alist’ directly.
;;
;; If you want buffer-local setting for color-outline, you can add a
;; file-local variable ‘color-outline-local-comment-char’.
;;
;; Color-outline looks for comment char settings in the following order:
;; 1. Buffer-local ‘color-outline-local-comment-char’
;; 2. ‘color-outline-comment-char-alist’
;; 3. ‘comment-start’ defined by the major mode.

;;; Code:
;;

(require 'cl-lib)
(require 'subr-x)
(require 'rx)

(defgroup color-outline
  '((color-outline-comment-char-alist custom-variable)
    (color-outline-disable-list custom-variable)
    (color-outline-face-list custom-variable))
  "Easy programming mode outline with visual highlight."
  :group 'outline)

(defcustom color-outline-comment-char-alist
  '((c-mode "*" "/")
    (c++-mode "*" "/")
    (python-mode "#")
    (javascript-mode "/")
    (css-mode "*" "/")
    (tuareg-mode "*" "(")
    (shell-script-mode "#")
    (web-mode "-" "<!")
    (sh-mode "#"))
  "Stores custom comment character for each major mode.
An alist of (MAJOR-MODE . (COMMENT-CHAR COMMENT-BEGIN))
or (MAJOR-MODE . (COMMENT-CHAR)). For other major modes,
‘comment-start’ is enough."
  :type '(alist :key-type symbol
                :value-type sexp)
  :group 'color-outline)

(defcustom color-outline-disable-list '(org-mode outline-mode)
  "Color-outline mode is not enabled in these modes."
  :type '(repeat symbol)
  :group 'color-outline)

(defcustom color-outline-face-list
  '(outline-1 outline-2 outline-3 outline-4)
  "Face for each level."
  :type '(repeat symbol)
  :group 'color-outline)

(defvar-local color-outline-local-comment-char nil
  "Overriding buffer local setting for color-outline comment char.
This value takes the same form as the values in alist
‘color-outline-comment-char-alist’. I.e., a list (COMMENT-CHAR
COMMENT-BEGIN).")

(defvar-local color-outline--keywords nil
  "We store font-lock keywords in this variable.
This is used to remove font-lock rules when ‘color-outline-mode’
is turned off.")

(defvar-local color-outline--imenu-expression nil
  "We store imenu expressions in this variable.
This is used to remove imenu expressions when ‘color-outline-mode’
is turned off.")

(defun color-outline--create-pattern (comment-char comment-begin)
  "Return the header pattern for major mode MODE.
COMMENT-CHAR (string) is the comment character of this mode.
COMMENT-BEGIN is string pattern starting a comment.
The result pattern is

<COMMENT-START><COMMENT-CHAR>{3}<COMMENT-CHAR>*<SPACE><ANYCHAR>*

The first group is the second group of COMMENT-CHARS, the second
group is <ANYCHAR>*.

Return a plist

    (:outline PATTERN :font-lock PATTERN-LIST)

where PATTERN is suitable for `outline-regepx', PATTERN-LIST is suitable
for `font-lock-add-keywords' (a list of specs)."
  (let* ((header-level (length color-outline-face-list))
         (outline-re (rx-to-string `(seq ,comment-begin
                                         (= 3 ,comment-char)
                                         (group (* ,comment-char))
                                         " "
                                         (group (* (not (any ?\t ?\n)))))))
         (re-list (cl-loop
                   for level from 0 to (1- header-level)
                   collect
                   (rx-to-string `(seq bol
                                       ,comment-begin
                                       (= 3 ,comment-char)
                                       (= ,level ,comment-char)
                                       " "
                                       (* (not (any ?\t ?\n)))))))
         (font-lock-list (cl-loop for re in re-list
                                  for face in color-outline-face-list
                                  collect `(,re (0 ',face t t)))))
    (list :outline outline-re :font-lock font-lock-list)))

(defun color-outline-define-header (mode comment-char comment-begin)
  "Define the header pattern for major mode MODE.
COMMENT-CHAR (char) is the comment character of this mode.
COMMENT-BEGIN is string pattern starting a comment."
  (setf (alist-get mode color-outline-comment-char-alist)
        (color-outline--create-pattern comment-char comment-begin)))

(define-minor-mode color-outline-mode
  "Color outline."
  :lighter "Co"
  (if (and color-outline-mode
           (not (apply #'derived-mode-p color-outline-disable-list)))
      (if-let* ((rule (or color-outline-local-comment-char
                          (alist-get major-mode
                                     color-outline-comment-char-alist)
                          (list comment-start "")))
                (comment-char (or (car rule) comment-start))
                (comment-begin (or (cadr rule) ""))
                (config (color-outline--create-pattern
                         comment-char comment-begin))
                (outline-re (plist-get config :outline))
                (imenu-expression `("Section" ,outline-re 2))
                (font-lock-keyword-list (plist-get config :font-lock)))
          (progn (setq-local outline-regexp outline-re)
                 (setq-local outline-level
                             (lambda () (1+ (/ (length (match-string 1))
                                               (length comment-char)))))
                 (setq-local imenu-generic-expression
                             (cons imenu-expression
                                   imenu-generic-expression))
                 (when (not (bound-and-true-p
                             outline-minor-mode-highlight))
                   (font-lock-add-keywords nil font-lock-keyword-list))
                 (setq color-outline--keywords font-lock-keyword-list)
                 (setq color-outline--imenu-expression imenu-expression)
                 (outline-minor-mode))
        ;; Don’t error in major mode hooks.
        (message "No color-outline pattern configured for %s"
                 major-mode))
    (kill-local-variable 'outline-regexp)
    (kill-local-variable 'outline-level)
    (font-lock-remove-keywords nil color-outline--keywords)
    (setq-local imenu-generic-expression
                (remove color-outline--imenu-expression
                        imenu-generic-expression))
    (outline-minor-mode -1))
  (jit-lock-refontify))

(provide 'color-outline)

;;; color-outline.el ends here
#+end_src

** iimg
*** config
#+begin_src elisp
(autoload #'iimg-enable "iimg")
(add-hook 'text-mode-hook #'iimg-enable)
(setq iimg-prune-slices-p nil)
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/iimg.el
;;; iimg.el --- Inline image      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; This package provides three functionalities:
;;  1. Embedding images into text files by encoding them to base64
;;     strings.
;;  2. Rendering embedded images.
;;  3. Controlling the size of the displayed image.
;;
;; Why embed the image? This way everything is in a single file and I
;; feel safe.
;;
;; Update: embedding the image in the text brings problems in indexing
;; the text, the best alternative is to embed the image data in a
;; separate supplement file “current-file-name.iimg”. If you want to
;; insert a image and store the data in the supplement file, answer yes
;; when asked when inserting the image.
;;
;;;; To enable:
;;
;;     M-x iimg-enable RET
;;
;;;; To insert an image:
;;
;; Drag and drop the image or use `iimg-insert'. Iimg will prompt for
;; a caption/name for the image. If you don’t enter anything, iimg
;; generates a unique string as the fallback.
;;
;; When you insert an image, the image appears at point is just a
;; link, the actual base64 data is appended at the end of the file (or
;; in the supplement file). I separate link and data because that way
;; readers incapable of rendering inline images can still view the
;; rest of the document without problems.
;;
;;;; To resize an image:
;;
;; Type s on an image or use `iimg-resize'. In the minibuffer, type in
;; the specification in the format of “SIDE UNIT AMOUNT”.
;;
;; SIDE can be width or height.
;; UNIT can be char or pixel.
;; AMOUNT can be a float or a integer.
;;
;; For example, “width char 40” means 40 characters wide. If AMOUNT is
;; a floating point number like 0.5, it is interpreted as a percentage
;; to the width/height of the window and UNIT is ignored.
;;
;; The default size is (width char 70).
;;
;;;; To toggle thumbnail display:
;;
;; Type t on an image or use `iimg-toggle-thumbnail'.
;;
;;;; To delete an image or image data
;;
;; To protect the image data, iimg marks them read-only, to delete
;; the data, press D on the data.
;;
;;;; To render an image across multiple lines:
;;
;; Type m on an image or use `iimg-toggle-multi-line'.
;;
;; When an image is displayed across multiple lines, scrolling is much
;; smoother. However, this doesn't work well when image size is set to
;; n percent of the window width/height: if you change the window
;; width/height, the number of lines needed for the image changes, but
;; iimg doesn't update its "image lines" automatically.
;;
;; Another way to get smooth scrolling over images is to use
;; iscroll.el. In that case you don't need to make the image
;; multi-line.

;;; Developer
;;
;; IIMG-DATA := ({iimg-data (:name STRING :data STRING)})
;; IIMG-LINK := ({iimg-link (:name STRING :thumbnail BOOL :size SIZE)})
;; SIZE  := (SIDE UNIT NUMBER)
;; SIDE  := width | height
;; UNIT  := char | pixel
;;
;; How does iimg work:
;;  1. Scan through the file for iimg data, load images into
;;     `iimg--data-alist'.
;;  2. In jit-lock, render iimg links to images.
;;  3. When inserting a new image, update `iimg--data-alist',
;;     insert the data at the end of the file, and insert the link
;;     at point.
;;
;; `iimg--data-alist' is always up to date: any image in the file are
;; in the alist.
;;
;; Why text property instead of overlay: text property seems to be
;; faster (when scrolling, etc).

;;; Code:
;;
;; For `with-buffer-modified-unmodified'.
(require 'bookmark)

;;; Variables

(defvar-local iimg--data-alist nil
  "An alist of (NAME . IMAGE-DATA).
NAME (string) is the name of the image.
IMAGE-DATA is the image binary data.")

(defvar iimg-multi-line t
  "Render image in multiple lines.")

(defvar iimg-prune-slices-p t
  "If non-nil, iims prunes image slices when save.")

(defvar iimg--data-regexp (rx (seq "({iimg-data "
                                   (group (+? anything))
                                   "})"))
  "Regular expression for inline image data.
The first group is the plist containing data.")

(defvar iimg--link-regexp
  (rx (seq "({iimg-link " (group (+? anything)) "})"
           (group (* "\n---"))))
  "Regular expression for inline image link.
The first group is the plist containing data. The second group
contains the slices.")

(defsubst iimg--format-data (plist)
  "Return formatted iimg data.
PLIST is the plist part of the link, should be a plist."
  (format "({iimg-data %s})" (prin1-to-string plist)))

(defun iimg--format-link (plist)
  "Return formatted iimg link.
PLIST is the plist part of the link, should be a plist.
The image must already be in `iimg--data-alist'."
  (let* ((img (iimg--image-from-props plist))
         (multi-line (plist-get plist :multi-line))
         (row-count (ceiling (/ (cdr (image-size img t))
                                (frame-char-height)))))
    (format "({iimg-link %s})%s"
            (prin1-to-string plist)
            (if multi-line
                (with-temp-buffer
                  (dotimes (_ (1- row-count))
                    (insert "\n---"))
                  (buffer-string))
              ""))))

(defvar iimg--link-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map "t" #'iimg-toggle-thumbnail)
    (define-key map "s" #'iimg-resize)
    (define-key map "d" #'iimg-delete-image-at-point)
    (define-key map "m" #'iimg-toggle-multi-line)
    map)
  "Keymap used on images.")

(defvar iimg--data-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map "D" #'iimg-delete-data-at-point)
    map)
  "Keymap used on image data.")

;;; Loading and rendering


(defun iimg--image-from-props (props)
  "Given plist PROPS, return an image spec."
  (let* ((name (plist-get props :name))
         (thumbnail (plist-get props :thumbnail))
         (size (plist-get props :size))
         (size-spec (if thumbnail
                        ;; TODO This thumbnail size should work in most
                        ;; cases, but can be improved.
                        (iimg--calculate-size '(width char 30))
                      (iimg--calculate-size (or size '(width char 1.0))))))
    ;; Below `iimg--data-of' calls `iimg--load-image' which does
    ;; regexp search. I added `save-match-data' in `iimg--load-image'.
    (or (apply #'create-image (iimg--data-of name) nil t size-spec)
        (error "failed to create image"))))

(defun iimg--fontify-1 (beg end display)
  "Add overlay to text between BEG and END with DISPLAY property."
  (put-text-property beg end 'display display)
  (put-text-property beg end 'keymap iimg--link-keymap)
  (put-text-property beg end 'iimg t)
  (put-text-property beg end 'rear-nonstick '(display keymap iimg)))

(defun iimg--fontify (beg end)
  "Fontify embedded image links between BEG and END."
  (dolist (ov (overlays-in beg end))
    (if (overlay-get ov 'iimg)
        (delete-overlay ov)))
  ;; Fontify link.
  (goto-char beg)
  (while (and (re-search-forward iimg--link-regexp nil t)
              (< (match-beginning 0) end))
    ;; PROPS includes :name, :thumbnail, :size
    (let* ((props (read (match-string-no-properties 1)))
           (image (iimg--image-from-props props))
           (multi-line (plist-get props :multi-line))
           (name (plist-get props :name))
           (inhibit-read-only t))
      (cond
       ((not (display-graphic-p))
        ;; In terminal.
        (put-text-property
         (match-beginning 0) (match-end 0)
         'display (format "[iimg link of %s]" name)))
       ((not multi-line)
        ;; Render the image on a single line.
        (iimg--fontify-1 (match-beginning 0) (match-end 0) image))
       (t
        ;; Render the image across multiple lines. We assume the
        ;; number of placeholder lines in the buffer is correct.
        (save-excursion
          (let* ((slice-height (frame-char-height))
                 (image-width (car (image-size image t)))
                 (x 0) (y 0))
            (goto-char (match-beginning 0))
            (while (< (point) (match-end 0))
              (let ((beg (line-beginning-position))
                    (end (line-end-position)))
                (iimg--fontify-1
                 beg end (list (list 'slice x y image-width slice-height)
                               image))
                (put-text-property end (1+ end) 'line-height t)
                (setq y (+ y slice-height)))
              (forward-line))))))
      (put-text-property (match-beginning 0) (match-end 0)
                         'read-only t)
      ;; This allows inserting after the image.
      (put-text-property (match-beginning 0) (match-end 0)
                         'rear-nonsticky
                         '(read-only display iimg keymap))))
  (cons 'jit-lock-response (cons beg end)))

(defun iimg--calculate-size (size)
  "Translate SIZE to an size that `create-image' recognizes.
IOW, (:width NUMBER) or (:height NUMBER), where NUMBER is in
pixels.
Calculation is done based on the current window."
  (pcase-let*
      ((`(,side ,unit ,amount) size)
       ;; Pixel width/height of a character.
       (char-pixel-len (pcase side
                         ('width (frame-char-width))
                         ('height (frame-char-height))
                         (_ (signal 'iimg-invalid-size size))))
       ;; Pixel wdith/height of the window
       (window-len (pcase side
                     ('width (window-width nil t))
                     ('height (window-height nil t))
                     (_ (signal 'iimg-invalid-size size))))
       ;; Pixel width/height of a character or pixel.
       (unit-len (pcase unit
                   ('char char-pixel-len)
                   ('pixel 1)
                   (_ (signal 'iimg-invalid-size size))))
       (len (pcase amount
              ;; This much char or pixels.
              ((pred integerp) (floor (* amount unit-len)))
              ;; This percent of the window width/height.
              ((pred floatp) (floor (* amount window-len)))
              (_ (signal 'iimg-invalid-size size)))))

    (pcase side
      ('width (list :width len))
      ('height (list :height len)))))

(defun iimg--load-image-data (beg end)
  "Load iimg data from BEG to END.
Look for iimg-data’s and store them into an alist, then return it."
  ;; This could be called from within `iimg--fontify', and we
  ;; don’t want to mess up its match data.
  (save-match-data
    (save-excursion
      (goto-char beg)
      (let (alist)
        (while (re-search-forward iimg--data-regexp end t)
          (let* ((beg (match-beginning 1))
                 (end (match-end 1))
                 (props (read (buffer-substring-no-properties beg end)))
                 (name (plist-get props :name))
                 (base64-string (plist-get props :data))
                 (image-data (base64-decode-string base64-string)))
            (push (cons name image-data) alist)
            ;; We fontify data here because data are usually to long
            ;; to be handled correctly by jit-lock.
            (with-silent-modifications
              (let ((beg (match-beginning 0))
                    (end (match-end 0)))
                (put-text-property
                 beg end 'display (format "[iimg data of %s]" name))
                (put-text-property beg end 'read-only t)
                ;; This allows inserting after the data.
                (put-text-property beg end 'rear-nonsticky
                                   '(read-only display))
                (put-text-property beg end 'keymap iimg--data-keymap)
                (put-text-property beg end 'iimg t)))))
        alist))))

(defun iimg--supplement-file (&optional create)
  "Return the supplement-file if it exists, nil if not.
If CREATE non-nil, create the file when it doesn’t exist."
  (let ((supplement-file (concat (file-name-nondirectory
                                  (buffer-file-name))
                                 ".iimg")))
    (if (and create (not (file-exists-p supplement-file)))
        (with-temp-buffer
          (write-file supplement-file)))
    (if (file-exists-p supplement-file)
        supplement-file
      nil)))

(defun iimg--data-of (name)
  "Get the image data of NAME (string)."
  (when (not iimg--data-alist)
    (setq iimg--data-alist
          (append (iimg--load-image-data (point-min) (point-max))
                  (if-let ((file (iimg--supplement-file)))
                      (with-temp-buffer
                        (insert-file-contents file nil nil nil t)
                        (iimg--load-image-data
                         (point-min) (point-max)))))))
  (alist-get name iimg--data-alist nil nil #'equal))

(defun iimg--replenish-slices ()
  "Re-slice images.
We don't save the slices under a link, so we need to add them back."
  (save-excursion
    (with-buffer-modified-unmodified
     (goto-char (point-min))
     (while (re-search-forward iimg--link-regexp nil t)
       (when-let* ((props (read (buffer-substring-no-properties
                                 (match-beginning 1) (match-end 1))))
                   (multi-line (plist-get props :multi-line))
                   (inhibit-read-only t))
         (replace-match (iimg--format-link props)))))))

(defun iimg--prune-slices ()
  "Remove slices under a link before saving to a file."
  (save-excursion
    (let ((this-buffer (current-buffer))
          (this-file (buffer-file-name))
          (inhibit-read-only t))
      (with-temp-buffer
        (insert-buffer-substring this-buffer)
        (goto-char (point-min))
        (while (re-search-forward iimg--link-regexp nil t)
          (when-let ((beg (match-beginning 2))
                     (end (match-end 2)))
            (delete-region beg end)))
        (write-region (point-min) (point-max) this-file))
      (clear-visited-file-modtime)
      (set-buffer-modified-p nil)
      t)))

;;; Inserting and modifying

(defun iimg-insert (file name separate-file)
  "Insert FILE at point as an inline image.
NAME is the name of the image, THUMBNAIL determines whether to
display the image as a thumbnail, SIZE determines the size of the
image. See Commentary for the format of NAME, THUMBNAIL, and SIZE.

If SEPARATE-FILE non-nil, insert image data in a separate file
that appends .iimg extension to the current buffer’s filename."
  (interactive
   (list (expand-file-name (read-file-name "Image: "))
         (let ((name (read-string "Caption/name for the image: ")))
           (if (equal name "")
               (format-time-string "%s")
             name))
         (y-or-n-p "Insert in separate file? ")))
  (let* ((data (with-temp-buffer
                 (insert-file-contents-literally file nil nil nil t)
                 (base64-encode-region (point-min) (point-max))
                 ;; TODO Check for max image file size?
                 (buffer-string)))
         (data-string (iimg--format-data (list :name name :data data)))
         iimg-alist
         (insert-fn
          (lambda ()
            ;; Insert data.
            (save-excursion
              (goto-char (point-max))
              (when (text-property-any
                     (max (point-min) (1- (point))) (point) 'read-only t)
                (goto-char
                 (previous-single-char-property-change
                  (point) 'read-only)))
              (let ((beg (point)))
                (insert "\n" data-string "\n")
                (setq iimg-alist (iimg--load-image-data beg (point))))))))
    (if separate-file
        (let ((supp-file (iimg--supplement-file t)))
          (with-temp-buffer
            (insert-file-contents supp-file nil nil nil t)
            (funcall insert-fn)
            (write-file supp-file)))
      (funcall insert-fn))
    (setq iimg--data-alist (append iimg-alist iimg--data-alist))
    ;; Insert link. We insert link after loading image data.
    (insert (iimg--format-link
             (list :name name :size '(width pixel 0.6)
                   :ext (file-name-extension file))))))

(defun iimg--search-link-at-point (&optional datap)
  "Search for iimg link at point.
If found, set match data accordingly and return t, if not, return nil.

If DATAP non-nil, search for image data instead."
  (catch 'found
    (save-excursion
      (let ((pos (point)))
        (beginning-of-line)
        ;; First search in current line.
        (while (and (<= (point) pos)
                    (re-search-forward
                     (if datap iimg--data-regexp iimg--link-regexp)
                     nil t))
          (if (<= (match-beginning 0) pos (match-end 0))
              (throw 'found t)))
        ;; Next search by search backward.
        (goto-char pos)
        (if (and (search-backward
                  (if datap "({iimg-data" "({iimg-link")
                  nil t)
                 (re-search-forward
                  (if datap iimg--data-regexp iimg--link-regexp)
                  nil t)
                 (<= (match-beginning 0) pos (match-end 0)))
            (throw 'found t))))))

(defun iimg--link-at-point ()
  "Return the data (plist) of the iimg link at point.
Return nil if not found."
  (if (iimg--search-link-at-point)
      (read (match-string 1))
    nil))

(defun iimg--set-link-at-point-refresh (props)
  "Set iimg link at point to PROPS, if there is any link.
Also refresh the image at point."
  (when (iimg--search-link-at-point)
    (save-excursion
      (let ((beg (match-beginning 0))
            (inhibit-read-only t))
        (goto-char beg)
        (delete-region beg (match-end 0))
        (insert (iimg--format-link props))
        (iimg--fontify beg (point))))))

(defun iimg-resize ()
  "Resize the inline image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (let ((size (read
                   (format "(%s)"
                           (read-string
                            "width/height char/pixel amount: ")))))
        (setq img-props (plist-put img-props :size size))
        (iimg--set-link-at-point-refresh img-props))
    (user-error "There is no image at point")))

(defun iimg-toggle-thumbnail ()
  "Toggle thumbnail display for the image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (progn (setq img-props
                   (plist-put img-props :thumbnail
                              (not (plist-get img-props :thumbnail))))
             (iimg--set-link-at-point-refresh img-props))
    (user-error "There is no image at point")))

(defun iimg-toggle-multi-line ()
  "Toggle multi-line display for the image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (progn (setq img-props
                   (plist-put img-props :multi-line
                              (not (plist-get img-props :multi-line))))
             (iimg--set-link-at-point-refresh img-props))
    (user-error "There is no image at point")))

(defun iimg-delete-image-at-point ()
  "Delete the image at point."
  (interactive)
  (if (iimg--search-link-at-point)
      (let ((inhibit-read-only t))
        (delete-region (match-beginning 0) (match-end 0)))
    (user-error "There is no image at point")))

(defun iimg-delete-data-at-point ()
  "Delete the image data at point."
  (interactive)
  (if (iimg--search-link-at-point t)
      (let ((inhibit-read-only t))
        (delete-region (match-beginning 0) (match-end 0)))
    (user-error "There is no image data at point")))

(defun iimg-export ()
  "Export image at point."
  (interactive)
  (if-let ((img-props (iimg--link-at-point)))
      (let ((path (concat (read-file-name "Export to (w/o extension): ")
                          (or (plist-get img-props :ext) ".png")))
            (data (iimg--data-of (plist-get img-props :name))))
        (when (file-exists-p path)
          (user-error "File exists, can’t export to it"))
        (when (not (file-writable-p path))
          (user-error "File not wraiteble, can’t export to it"))
        (with-temp-file path
          (insert data))
        (message "Exported to %s" path))
    (user-error "There is no image at point")))

;;; Entry

(defun iimg-enable ()
  "Enable iimg."
  (jit-lock-register #'iimg--fontify)
  (setq-local dnd-protocol-alist
              (cons '("^file:" . iimg-dnd-open-file)
                    dnd-protocol-alist))
  (when iimg-prune-slices-p
    (add-hook 'write-file-functions #'iimg--prune-slices 90 t))
  (iimg--replenish-slices))

;;; Drag and drop

(defun iimg-dnd-open-file (uri _action)
  "Drag-and-drop handler for iimg. URI is the file path."
  (let ((file (dnd-get-local-file-name uri t)))
    (if (and file (file-readable-p file))
        (iimg-insert
         file (let ((name (read-string "Caption/name for the image: ")))
                (if (equal name "")
                    (format-time-string "%s")
                  name))
         (y-or-n-p "Insert in separate file? ")))))

(provide 'iimg)

;;; iimg.el ends here
#+end_src
** bklink
#+begin_src elisp
(autoload #'bklink-minor-mode "bklink")
(with-eval-after-load 'bklink
  (keymap-set bklink-minor-mode-map "C-c l" #'bklink-show-back-link)
  (keymap-set bklink-minor-mode-map "C-c i" #'bklink-insert))
(setq bklink-summary-read-only-p nil
      bklink-prune-summary-p nil)
#+end_src

*** Source
#+begin_src elisp :tangle site-lisp/bklink.el
;;; bklink.el --- Poor man's back-link      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; In org-roam, you can show back links -- a list of files that
;; contains a link to the current file. The idea is nice but I have
;; different idea on how to implement it. Hence this package.
;;
;; Some assumptions about the files that contains bklink:
;;
;;  1. All the files are in the same directory. So we can use filename
;;     to uniquely identify files.
;;  2. There is no sub-directories.
;;  3. There aren’t a ton of files. We use grep to search for links,
;;     no caching.
;;
;; Advantages:
;;
;;  1. Filename as link, no id, no database.
;;  2. Works for multiple directories without configuration, it’s just
;;     that files can only link to files in the same directory.
;;  3. Works for any file format.
;;
;; To use with Deft:
;;
;;     (add-hook 'deft-open-file-hook #'bklink-minor-mode)
;;     (setq deft-use-filter-string-for-filename t)
;;
;; To use with Xeft:
;;
;;     (add-hook 'xeft-find-file-hook #'bklink-minor-mode)
;;
;; Or use dir-local variable.
;;
;; Usage:
;;
;; Link format is [[bklink:filename.ext]]. Extension is optional.
;; Links are displayed as [filename] with ‘link’ face.
;;
;; Insert a link to another file or edit a link:
;;
;;     M-x bklink-insert RET
;;
;; Show back-links:
;;
;;     M-x bklink-summary-mode RET
;;
;; Rename all links to the current file:
;;
;;     M-x bklink-rename new-name RET
;;
;; And then manually rename the current file.
;;
;; Notes:
;;
;; - If a link doesn’t have extension, bklink appends “.txt” to it
;;   when searching for the corresponding file.
;; - If a link points to non-exist file, bklink doesn’t create
;;   that file. Instead, bklink creates a buffer, and you can show
;;   back-links to it without creating that file.
;; - When ‘bklink-show-back-link-on-start’ is non-nil, back-link
;;   summary is shown on startup.
;; - When ‘bklink-use-form-feed’ is non-nil, bklink uses form-feed
;;   character to delineate back-link summary.
;; - Using id instead of title as filenames is a dumb idea. Tried it,
;;   didn’t work well.

;;; Code:

(require 'cl-lib)
;; For `with-buffer-modified-unmodified'.
(require 'bookmark)
(require 'browse-url)

;;; Customize

(defvar bklink-use-form-feed t
  "If non-nil, use form-feed instead of dashes.")

(defvar bklink-show-back-link-on-start t
  "If non-nil, show back-links when `bklink-minor-mode' starts.")

(defvar bklink-more-match nil
  "If non-nil, bklink includes more matches in the back-link summary.

Besides explicitly links, we also include text that matches the
title but isn't a link.

For example, for Emacs.txt, we match not only [[bklink:Emacs.txt]],
but also Emacs.")

(defvar bklink-summary-read-only-p t
  "If non-nil, bklink marks the summary read-only.")

(defvar bklink-prune-summary-p t
  "If non-nil, summary is not saved to disk.")

;;; Backstage

(defvar bklink-regexp (rx (seq (group "[[bklink:")
                               (group (+? (not (any "/"))))
                               (group (? (or ".txt" ".org" ".md")))
                               (group "]]")))
  "Regular expression that matches a bklink.

Group 1 is opening delimiter.
Group 2 is base filename.
Group 3 is filename extension (if exists).
Group 4 is ending delimiter.

Change this variable and
`bklink--format-link' to change link format.")

(defsubst bklink--format-link (file)
  "Format FILE into a bklink. Basically [[bklink:FILE]]."
  (format "[[bklink:%s]]" file))

(defun bklink--get-file-list (file)
  "Return a list of files that’s in the same project with FILE.
Ignore dotfiles and directories."
  (cl-remove-if (lambda (f) (or (string-prefix-p "." f)
                                (file-directory-p f)))
                ;; FILE could be a file-less buffer.
                (directory-files (or (file-name-directory file)
                                     default-directory))))

(defun bklink--search-at-point ()
  "Search for links at point and set match data accordingly.
Return t if found, nil otherwise. See `bklink--regepx' for
groups."
  (save-excursion
    (catch 'found
      (let ((p (point)))
        (beginning-of-line)
        (while (re-search-forward bklink-regexp (line-end-position) t)
          (if (<= (match-beginning 0) p (match-end 0))
              (throw 'found t)))))))

(defun bklink--file-at-point ()
  "Return the filename of the link at point.
Return nil if not found."
  (bklink--search-at-point)
  (buffer-substring-no-properties (match-beginning 2) (match-end 3)))

(defun bklink--set-file-at-point (name)
  "Set the file name of the link at point to NAME.
Do nothing if there is no link at point."
  (bklink--search-at-point)
  (save-excursion
    (goto-char (match-beginning 2))
    (delete-region (match-beginning 2) (match-end 3))
    (insert name)))

;;;; Link button

(define-button-type 'bklink
  'action #'bklink-follow-link
  'filename nil
  'follow-link t
  'use-window nil
  'help-echo "Jump to file")

;; Please the byte compiler.
(defvar bklink-minor-mode)
(defun bklink-follow-link (button)
  "Jump to the file that BUTTON represents.
If the file doesn't exist, create a buffer."
  (with-demoted-errors "Error when following the link: %s"
    (let* ((file (button-get button 'filename))
           (fullname (if (file-name-extension file)
                         file
                       (concat file ".txt"))))
      (if (file-exists-p fullname)
          (find-file fullname)
        (switch-to-buffer (get-buffer-create fullname))
        (when (eq (point) 1)
          (insert (file-name-base file) "\n\n"))))
    (when (eq major-mode 'fundamental-mode)
      (text-mode))
    (unless bklink-minor-mode
      (bklink-minor-mode))))

(define-button-type 'bklink-url
  'action #'bklink-browse-url
  'url nil
  'follow-link t
  'help-echo "Open URL")

(defun bklink-browse-url (button)
  "Open URL in BUTTON."
  (browse-url (button-get button 'url)))

;;;; Highlight links

(defvar bklink-summary-mode)

;;;###autoload
(define-minor-mode bklink-minor-mode
  "Recognizes bklinks."
  :lighter ""
  :keymap (make-sparse-keymap)
  (if bklink-minor-mode
      (progn
        (jit-lock-register #'bklink-fontify)
        (jit-lock-register #'bklink-fontify-url)
        (when bklink-prune-summary-p
          (add-hook 'write-file-functions
                    #'bklink--write-file-function 90 t))
        ;; (add-hook 'fill-nobreak-predicate #'bklink--nobreak-p 90 t)
        (if (and bklink-show-back-link-on-start
                 (not bklink-summary-mode))
            (bklink-summary-mode)))
    (jit-lock-unregister #'bklink-fontify)
    (jit-lock-unregister #'bklink-fontify-url)
    ;; (remove-hook 'fill-nobreak-predicate #'bklink--nobreak-p t)
    (with-silent-modifications
      (put-text-property (point-min) (point-max) 'display nil)))
  (jit-lock-refontify))

(defun bklink-fontify (beg end)
  "Highlight bklinks between BEG and END."
  (goto-char beg)
  (while (and (not (derived-mode-p 'org-mode))
              (re-search-forward bklink-regexp nil t)
              (< (point) end))
    (let* ((inhibit-read-only t)
           (filename (concat
                      (match-string-no-properties 2)
                      (or (match-string-no-properties 3)
                          ""))))
      ;; Hide opening and closing delimiters and file extension.
      (with-silent-modifications
        ;; (put-text-property (match-beginning 0) (match-end 0)
        ;;                    'bklink-no-break t)
        (add-text-properties
         (match-beginning 1) (match-end 1)
         '(display "[" font-lock-face shadow face shadow))
        (add-text-properties
         (match-beginning 4) (match-end 4)
         '(display "]" font-lock-face shadow face shadow))
        (when (match-beginning 3)
          (put-text-property (match-beginning 3)
                             (match-end 3) 'invisible t))
        (put-text-property (match-beginning 0) (match-end 0)
                           'rear-nonsticky t)
        ;; Highlight link.
        (make-text-button (match-end 1)
                          (match-beginning 4)
                          :type 'bklink
                          'filename filename)))))

(defun bklink-fontify-url (beg end)
  "Add clickable buttons to URLs between BEG and END.
Everything that matches `browse-url-button-regexp' will be made
clickable and will use `browse-url' to open the URLs in question."
  ;; Change face to font-lock-face.
  (goto-char beg)
  (while (and (not (derived-mode-p 'org-mode 'markdown-mode))
              (re-search-forward browse-url-button-regexp end t))
    (make-text-button (match-beginning 0)
                      (match-end 0)
                      :type 'bklink-url
                      'url (match-string-no-properties 0))))

;; (defun bklink--nobreak-p ()
;;   "Return non-nil if shouldn't break at point."
;;   (text-property-any
;;    (max (1- (point)) (point-min)) (point) 'bklink-no-break t))

;;;; Back-link summary

(defvar bklink--back-link-regexp
  (rx (seq "\n" (or "\x0C" (= 70 "-")) "\n"
           ;; Non-greedy is important: otherwise we risk of
           ;; regexp stack overflow. That happened for buffers
           ;; when iimg data.
           (+? digit) " linked reference" (? "s") (+? anything)
           (or "\x0C" (= 70 "-")) "\n"))
  "Regular expression that matches the beginning of a summary.")

(defun bklink--prune-back-link-summary ()
  "Remove back-links before save."
  (goto-char (point-min))
  (let ((inhibit-read-only t))
    ;; Remove summary.
    (when (re-search-forward bklink--back-link-regexp nil t)
      (delete-region (match-beginning 0) (match-end 0)))))

(defun bklink--insert-back-link-summary (files buffer this-file)
  "Append back-link summary to BUFFER.
FILES is a list of filenames that contains the link.
THIS-FILE is the filename we are inserting summary into."
  (with-current-buffer buffer
    (save-excursion
      (with-buffer-modified-unmodified
       (bklink--prune-back-link-summary)
       (goto-char (point-max))
       (let* ((summary-start (point))
              (this-link (bklink--format-link this-file))
              (this-link-re
               (replace-regexp-in-string
                " " "[ \n]*" (regexp-quote this-link)))
              ;; A list of (FILE . SUMMARY). The grep search didn't
              ;; match against the complete link and we need to filter
              ;; out the false-positives here.
              (summary-list
               (mapcar
                (lambda (file)
                  (if (not (equal file this-file))
                      (with-temp-buffer
                        (insert-file-contents file nil nil nil t)
                        (goto-char (point-min))
                        (if (re-search-forward this-link-re nil t)
                            (let ((summary
                                   (or (string-trim
                                        (thing-at-point 'line))
                                       "(No summary)")))
                              (cons file summary))))))
                files))
              (summary-list (remove nil summary-list))
              (inhibit-read-only t))
         ;; Insert separator.
         (insert "\n"
                 (if bklink-use-form-feed "\x0C" (make-string 70 ?-))
                 "\n"
                 (format "%d linked reference%s:\n"
                         (length summary-list)
                         ;; Plural when more than one.
                         (if (eq (length summary-list) 1) "" "s")))
         (dolist (summary summary-list)
           (insert "\n")
           ;; Insert file link.
           (insert (bklink--format-link (car summary)) ":\n")
           ;; Insert surrounding sentence. We only get the first
           ;; sentence. Don’t fill the paragraph, filling might break
           ;; the layout of the original text.
           (let ((beg (point)))
             (insert (cdr summary))
             (indent-rigidly beg (point) 2))
           (insert "\n"))
         (insert (if bklink-use-form-feed "\x0C" (make-string 70 ?-)))
         (put-text-property summary-start (point)
                            'read-only bklink-summary-read-only-p)
         ;; Add an non-read-only newline so the user and other
         ;; commands can append text at the end of the file.
         (insert "\n")
         (bklink-fontify summary-start (point)))))))

(defun bklink--write-file-function ()
  "Write to file without the back-links."
  (save-excursion
    (let ((this-buffer (current-buffer))
          (this-file (buffer-file-name)))
      (with-temp-buffer
        (insert-buffer-substring this-buffer)
        (bklink--prune-back-link-summary)
        (write-region (point-min) (point-max) this-file))
      (clear-visited-file-modtime)
      (set-buffer-modified-p nil)
      t)))

;;;; Retrieve back-links

(defun bklink--get-linked-files (file callback)
  "Call CALLBACK with a list of filenames that has a link to FILE."
  (let* ((name (generate-new-buffer-name " *bklink grep*"))
         (process (apply
                   #'start-process
                   name name "grep" "-ilF"
                   ;; The link could span multiple lines (because of
                   ;; filling), so we only search for the part before
                   ;; first space as a preliminary filter. We later do
                   ;; an accurate search in
                   ;; `bklink--insert-back-link-summary'.
                   (car (split-string
                         (if bklink-more-match
                             (file-name-base file)
                           (bklink--format-link
                            (file-name-nondirectory file)))))
                   (bklink--get-file-list file)))
         ;; When the grep process finishes, we parse the result files
         ;; and call CALLBACK with them.
         (sentinal
          (lambda (process event)
            (if (string-match-p (rx (or "finished" "exited"))
                                event)
                (if-let ((buf (process-buffer process)))
                    (unwind-protect
                        (with-current-buffer buf
                          (let ((files (split-string
                                        (buffer-string) "\n")))
                            (funcall callback
                                     (mapcar #'file-name-nondirectory
                                             (remove "" files)))))
                      (kill-buffer buf))
                  (error "Bklink’s grep process’ buffer is killed"))
              (error "Bklink’s grep process failed with signal: %s"
                     event)))))
    (set-process-sentinel process sentinal)))

;;; Orglink

;;;###autoload
(with-eval-after-load 'org
  (org-link-set-parameters
   "bklink"
   :follow #'org-link-open-as-file
   :export (lambda (path _desc _backend _info)
             path)
   :store #'ignore))

;;; Userland

;;;###autoload
(defun bklink-insert ()
  "Insert a link to a file.
If point not on a link, insert a new link, if already on a link,
edit the link."
  (interactive)
  (if (bklink--search-at-point)
      (let ((file (completing-read
                   "New file: "
                   (mapcar #'file-name-base
                           (bklink--get-file-list (buffer-file-name)))
                   nil nil (bklink--file-at-point))))
        (bklink--set-file-at-point file))
    (let* ((file (completing-read
                  "File: "
                  (mapcar #'file-name-nondirectory
                          (bklink--get-file-list (buffer-file-name))))))
      (insert (bklink--format-link file))))
  (bklink-minor-mode))

;;;###autoload
(define-minor-mode bklink-summary-mode
  "Toggle display of back-links summary at the end of a buffer.
The back-links are links to the files that has a link to this file."
  :lighter ""
  (unless (executable-find "grep")
    (user-error "Displaying back-link needs grep but we cannot find it"))
  (unless bklink-minor-mode
    (user-error "Bklink-minor-mode is not on"))
  (if bklink-summary-mode
      ;; The buffer could be not having a file.
      (if-let ((file (or (buffer-file-name) (buffer-name)))
               (buffer (current-buffer)))
          ;; Fire a sub-process to retrieve back-links.
          (bklink--get-linked-files
           file (lambda (file-list)
                  (bklink--insert-back-link-summary
                   file-list buffer (file-name-nondirectory file))))
        (user-error "This buffer is not associated with any file"))
    (with-buffer-modified-unmodified
     (save-excursion
       (bklink--prune-back-link-summary)))))

;;;###autoload
(defun bklink-rename (new-name)
  "Rename current file to NEW-NAME.
Rename bklinks that points to the current file point to NEW-NAME.
This command only rename links, you need to manually rename the
current file."
  ;; We run grep to find files that contain the old link, save them to
  ;; /tmp/bklink-rename, and use emacs to replace old links with new
  ;; links in each file. I can’t believe there is no painless way to
  ;; replace literal strings in sed.
  (interactive
   (let ((name (file-name-nondirectory (buffer-file-name))))
     (list (completing-read
            (format "Rename %s to: " name) nil nil name))))
  (unless (executable-find "grep")
    (user-error "Rename needs grep but we cannot find it"))
  (unless (executable-find "emacs")
    (user-error "Rename needs Emacs in PATH but we cannot find it"))
  (when (file-exists-p new-name)
    (user-error "Cannot rename to %s, this file already exists" new-name))
  (when (yes-or-no-p (format "Replace %s to %s?"
                             (file-name-nondirectory
                              (buffer-file-name))
                             new-name))
    (let* ((old-link (bklink--format-link (file-name-nondirectory
                                           (buffer-file-name))))
           (new-link (bklink--format-link new-name))
           (tmp-file (concat "/tmp/bklink-rename-"
                             (format-time-string "%s")))
           (command
            (concat
             (format "grep -ilF '%s' %s > %s"
                     (car (split-string old-link))
                     default-directory tmp-file)
             (format "; emacs --batch -l '%s'"
                     (find-library-name "bklink"))
             (format
              " --eval '(bklink--process-rename \"%s\" \"%s\" \"%s\")'"
              old-link new-link tmp-file))))
      (start-process-shell-command
       "bklink rename" " *bklink rename*" command)
      (message "Replacing %s with %s in the background"
               old-link new-link))))

(defun bklink--process-rename (old-link new-link path-file)
  "Replace OLD-LINK with NEW-LINK.
The files to replace are in PATH-FILE"
  (with-temp-buffer
    (insert-file-contents path-file)
    (dolist (file (split-string (buffer-string) "\n"))
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (let ((link-re (string-join
                        (mapcar #'regexp-quote
                                (split-string old-link))
                        "[ \n]*")))
          (while (re-search-forward link-re nil t)
            (replace-match new-link)))
        (write-file file)))))

(defun bklink--upgrade ()
  (goto-char (point-min))
  (while (re-search-forward (rx (group "[[bklink:")
                                (group (+ anychar))
                                (group "]]"))
                            nil t)
    (replace-match "]]" nil nil nil 3)
    (replace-match "[[bklink:" nil nil nil 1)))

(defun bklink--upgrade-all ()
  (with-temp-buffer
    (dolist (file (directory-files default-directory))
      (ignore-errors
        (when (and (file-regular-p file)
                   (not (equal (file-name-extension file) "iimg")))
          (erase-buffer)
          (insert-file-contents-literally file)
          (bklink--upgrade)
          (write-region (point-min) (point-max) file))))))

(provide 'bklink)

;;; bklink.el ends here
#+end_src

** flique
*** Source
#+begin_src elisp :tangle site-lisp/flique.el
;;; flique.el --- File cliques  -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; This package complements bklink.el. With this package, you can
;; easily group related note files into cliques and go back and
;; forth within the clique.
;;
;; To start, create a file "index.flique" under the directory where
;; all the notes are. Each line is a filename. Consecutive lines define
;; a clique. Separate cliques by empty lines. For example,
;;
;; file1.txt
;; file2.txt
;;
;; file3.txt
;; file4.txt
;;
;; defines two cliques, file1 and 2, and file3 and 4.
;;
;; Then, you can go back and forth by
;;
;;  - ‘flique-forward’
;;  - ‘flique-backward’
;;
;; If a line in the index file contains a file that doesn’t exist,
;; flique just ignores that.

;;; Code:

(defun flique--index ()
  "Return the index buffer."
  (with-current-buffer (get-buffer-create " *flique index*")
    (when (file-exists-p "index.flique")
      (insert-file-contents "index.flique" nil nil nil t))
    (current-buffer)))

(defun flique-append-to-index (file)
  "Add FILE to the end of the index file.
Only add if FILE is not already in the index file."
  (with-current-buffer (flique--index)
    (goto-char (point-min))
    ;; Unless already exists...
    (unless (re-search-forward
             (concat "^" (regexp-quote
                          (file-name-nondirectory file))
                     "$")
             nil t)
      ;; ...append to the end.
      (goto-char (point-max))
      (unless (looking-back "\n" 1)
        (insert "\n"))
      (insert (file-name-nondirectory file))
      ;; If we use ‘write-file’, this buffer is associated with
      ;; index.flique. (Changes from *flique index* to index.flique.)
      (write-region (point-min) (point-max) "index.flique"))))

(defun flique--next-file (filename step)
  "Return the next file of FILENAME. FILENAME cannot be a path.
STEP can be either 1 or -1, 1 for going forward, -1 for going
backward."
  (with-current-buffer (flique--index)
    (goto-char (point-min))
    (when (and (re-search-forward
                (concat "^" (regexp-quote filename) "$") nil t)
               (eq 0 (forward-line step)))
      (let ((next (buffer-substring
                   (line-beginning-position)
                   (line-end-position))))
        (unless (equal next "")
          next)))))

(defun flique-forward ()
  "Go forward in the clique."
  (interactive)
  (let ((next (flique--next-file
               (file-name-nondirectory (buffer-file-name))
               1)))
    (when (and next (file-exists-p next))
      (find-file next)
      (flique-show-navigation))))

(defun flique-backward ()
  "Go backward in the clique."
  (interactive)
  (let ((next (flique--next-file
               (file-name-nondirectory (buffer-file-name))
               -1)))
    (when (and next (file-exists-p next))
      (find-file next)
      (flique-show-navigation))))

(defun flique-show-navigation ()
  "Display a navigation bar in header-line."
  (let* ((filename (file-name-nondirectory (buffer-file-name)))
         (prev (flique--next-file filename -1))
         (next (flique--next-file filename 1)))
    (when (or prev next)
      (setq header-line-format
            (propertize
             (concat
              (if (and prev (file-exists-p prev))
                  (concat "← " (file-name-base prev))
                ":-O")
              (propertize "\t" 'display `(space :width ,tab-width))
              (if (and next (file-exists-p next))
                  (concat (file-name-base next) " →")
                ":-D")
              (propertize " " 'display '(raise 0.3))
              (propertize " " 'display '(raise -0.2)))
             'face '(:height 130))))))

(defun flique-list ()
  "Show the current file in the flique index file."
  (interactive)
  (let ((filename (file-name-nondirectory (buffer-file-name))))
    (find-file "index.flique")
    (goto-char (point-min))
    (re-search-forward (concat "^" (regexp-quote filename) "$") nil t)
    (beginning-of-line)))

(define-derived-mode flique-mode fundamental-mode
  "Flique"
  "Editing flique index files."
  (setq outline-regexp (rx "*"))
  (outline-minor-mode))

(add-to-list 'auto-mode-alist '("\\.flique\\'" . flique-mode))

(provide 'flique)

;;; flique.el ends here
#+end_src

** Themes
*** util
#+begin_src emacs-lisp :tangle site-lisp/theme-util.el
;;; theme-util.el --- Theme tools      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.cam>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;

;;; Code:
;;

(require 'seq)
(require 'cl-lib)

;;; Define theme

(defun theme-util-deffaces (&rest face-list)
  "FACE-LIST is a list of (FACE DOC)."
  (dolist (face face-list)
    (face-spec-set face '((t . (:inherit default)))
                   'face-defface-spec)))

(defun theme-util-set-faces (name spec)
  "Define theme of NAME with SPEC on DISPLAY.
SPEC is as in ‘theme-util-make-face-spec’."
  (declare (indent 1))
  (apply #'custom-theme-set-faces
         name
         (mapcar #'theme-util-make-face-spec
                 spec)))

(defun theme-util-make-face-spec (spec)
  "Convert SPEC into actual spec used in ‘custom-theme-set-faces’.

SPEC is a list

    \(FACE (INHERIT FOREGROUND BACKGROUND UNDERLINE WEIGHT SLANT)
          REST-ATTR DISPLAY)

REST-ATTR is a plist (:key :value ...). DISPLAY is the same as in
`defface'.

For example,
\(default nil \"white\" \"black\" nil 'bold nil (:height 10))."
  (let* ((face (nth 0 spec))
         (attr (nth 1 spec))
         (rest-attr (nth 2 spec))
         (display (nth 3 spec))
         (inherit (nth 0 attr))
         (fg (nth 1 attr))
         (bg (nth 2 attr))
         (underline (nth 3 attr))
         (weight (nth 4 attr))
         (slant (nth 5 attr)))
    `(,face ((,(or display t)
              . ,(remove
                  nil
                  (append (if inherit (list :inherit inherit))
                          (if fg (list :foreground fg))
                          (if bg (list :background bg))
                          (if underline (list :underline underline))
                          (if weight (list :weight weight))
                          (if slant (list :slant slant))
                          rest-attr)))))))

;;; Inspect theme

(when (featurep 'hierarchy)
  (defun theme-util-top-level-face-to-kill-ring (regexp)
    (interactive "sRegexp: ")
    (kill-new
     (string-join
      (mapcar
       (lambda (face)
         (format "(%s :inherit 'default)\n" face))
       (sort (seq-filter (lambda (face)
                           (and (string-match regexp (face-name face))
                                (not (face-attribute face :inherit nil 'default))))
                         (face-list))
             (lambda (f1 f2)
               (string-lessp (face-name f1) (face-name f2))))))))

  (defun theme-util-show-face-tree (&optional regexp)
    (interactive)
    (switch-to-buffer
     (let ((tree (hierarchy-new))
           (parent-fn
            (lambda (face)
              (let ((parent-face (if (eq face 'root-face)
                                     nil ;; the root has no parent
                                   (or (face-attribute face :inherit nil 'default)
                                       'root-face ))))
                (cond ((facep parent-face) parent-face)
                      ((null parent-face) nil)
                      (t 'root-face)))))
           (face-list (seq-filter (lambda (face)
                                    (if (not regexp)
                                        t
                                      (string-match regexp (face-name face))))
                                  (face-list))))
       (hierarchy-add-trees tree face-list parent-fn)
       (hierarchy-tree-display tree (lambda (face _) (insert (format "%s" face)))))))
  )
;;; Color util

(defvar theme-util-color-distance-fn
  (lambda (c1 c2)
    (let ((r1 (nth 0 c1))
          (g1 (nth 1 c1))
          (b1 (nth 2 c1))
          (r2 (nth 0 c2))
          (g2 (nth 1 c2))
          (b2 (nth 2 c2)))
      (+ (expt (- r1 r2) 2)
         (expt (- g1 g2) 2)
         (expt (- b1 b2) 2))))
  "Function that returns the distance between color1 and color2.
Should take two colors and return a number. There is no
specification on the range of the returned number as long as
greater number implies greater distance. Each color is like (R G
B) where R, G, B are number.

More on https://en.wikipedia.org/wiki/Color_difference")

(defun theme-util-color-distance (color1 color2)
  "Return the distance between COLOR1 and COLOR2.
COLOR’s are in the form of ”#RRGGBB”."
  (funcall theme-util-color-distance-fn
           (theme-util-color-str-to-list color1)
           (theme-util-color-str-to-list color2)))

(defun theme-util-color-str-to-list (color)
  "Convert COLOR in ”#RRGGBB” format to (R G B)."
  (list (string-to-number (substring color 1 3) 16)
        (string-to-number (substring color 3 5) 16)
        (string-to-number (substring color 5 7) 16)))

(defun theme-util-color-list-to-str (color)
  "Convert COLOR in (R G B) format to ”#RRGGBB”."
  (format "#%.2x%.2x%.2x" (nth 0 color) (nth 1 color) (nth 2 color)))

(defun theme-util--closest-color-in-list (color color-list)
  "Return the color closest to COLOR from COLOR-LIST."
  (let (closest-color
        (min-distance 1.0e+INF))
    (dolist (a-color color-list)
      (let ((new-dist (theme-util-color-distance color a-color)))
        (when (< new-dist min-distance)
          (setq min-distance new-dist
                closest-color a-color))))
    closest-color))

(defun theme-util-closest-8-bit-color (color)
  "Return the closest 8 bit color to COLOR."
  (theme-util-closest-color-in-list color theme-util--8-bit-color-list))

(defun theme-util-closest-4-bit-color (color)
  "Return the closest 4 bit color to COLOR."
  (theme-util-closest-color-in-list color theme-util--4-bit-color-list))

(defun theme-util-color-overlay (color-base color-above alpha)
  "Return a color made of COLOR-ABOVE with alpha ALPHA placed above COLOR-BASE.
Both COLOR’S are like ”#RRGGBB”, ALPHA is a float between 0 and 1."
  (theme-util-color-list-to-str
   (cl-labels ((comp (base above alpha)
                 (+ (* base (- 1 alpha)) (* above alpha)))
               (bound (color) (cond ((> color 255) 255)
                                    ((< color 0) 0)
                                    (t color))))
     (let* ((color-base (theme-util-color-str-to-list color-base))
            (color-above (theme-util-color-str-to-list color-above)))
       (cl-loop for base in color-base
                for above in color-above
                collect (bound (comp base above alpha)))))))

(defun theme-util-adjust-brightness (color brightness)
  "Adjust the BRIGHTNESS of COLOR.
Basically minmax(0, R/G/B * brightness, 255).
COLOR is like ”#RRGGBB”."
  (theme-util-color-list-to-str
   (mapcar (lambda (channel) (min 255 (* brightness channel)))
           (theme-util-color-str-to-list color))))

(defun theme-util-darken (color degree)
  "Darken COLOR by DEGREE (float between 0 and 1)."
  (theme-util-color-overlay color "#000000" degree))

(defun theme-util-brighten (color degree)
  "Brighten COLOR by DEGREE (float between 0 and 1)."
  (theme-util-color-overlay color "#ffffff" degree))

(defvar theme-util--8-bit-color-list
  '("#000000"
    "#800000"
    "#008000"
    "#808000"
    "#000080"
    "#800080"
    "#008080"
    "#c0c0c0"
    "#808080"
    "#ff0000"
    "#00ff00"
    "#ffff00"
    "#0000ff"
    "#ff00ff"
    "#00ffff"
    "#ffffff"
    "#000000"
    "#00005f"
    "#000087"
    "#0000af"
    "#0000d7"
    "#0000ff"
    "#005f00"
    "#005f5f"
    "#005f87"
    "#005faf"
    "#005fd7"
    "#005fff"
    "#008700"
    "#00875f"
    "#008787"
    "#0087af"
    "#0087d7"
    "#0087ff"
    "#00af00"
    "#00af5f"
    "#00af87"
    "#00afaf"
    "#00afd7"
    "#00afff"
    "#00d700"
    "#00d75f"
    "#00d787"
    "#00d7af"
    "#00d7d7"
    "#00d7ff"
    "#00ff00"
    "#00ff5f"
    "#00ff87"
    "#00ffaf"
    "#00ffd7"
    "#00ffff"
    "#5f0000"
    "#5f005f"
    "#5f0087"
    "#5f00af"
    "#5f00d7"
    "#5f00ff"
    "#5f5f00"
    "#5f5f5f"
    "#5f5f87"
    "#5f5faf"
    "#5f5fd7"
    "#5f5fff"
    "#5f8700"
    "#5f875f"
    "#5f8787"
    "#5f87af"
    "#5f87d7"
    "#5f87ff"
    "#5faf00"
    "#5faf5f"
    "#5faf87"
    "#5fafaf"
    "#5fafd7"
    "#5fafff"
    "#5fd700"
    "#5fd75f"
    "#5fd787"
    "#5fd7af"
    "#5fd7d7"
    "#5fd7ff"
    "#5fff00"
    "#5fff5f"
    "#5fff87"
    "#5fffaf"
    "#5fffd7"
    "#5fffff"
    "#870000"
    "#87005f"
    "#870087"
    "#8700af"
    "#8700d7"
    "#8700ff"
    "#875f00"
    "#875f5f"
    "#875f87"
    "#875faf"
    "#875fd7"
    "#875fff"
    "#878700"
    "#87875f"
    "#878787"
    "#8787af"
    "#8787d7"
    "#8787ff"
    "#87af00"
    "#87af5f"
    "#87af87"
    "#87afaf"
    "#87afd7"
    "#87afff"
    "#87d700"
    "#87d75f"
    "#87d787"
    "#87d7af"
    "#87d7d7"
    "#87d7ff"
    "#87ff00"
    "#87ff5f"
    "#87ff87"
    "#87ffaf"
    "#87ffd7"
    "#87ffff"
    "#af0000"
    "#af005f"
    "#af0087"
    "#af00af"
    "#af00d7"
    "#af00ff"
    "#af5f00"
    "#af5f5f"
    "#af5f87"
    "#af5faf"
    "#af5fd7"
    "#af5fff"
    "#af8700"
    "#af875f"
    "#af8787"
    "#af87af"
    "#af87d7"
    "#af87ff"
    "#afaf00"
    "#afaf5f"
    "#afaf87"
    "#afafaf"
    "#afafd7"
    "#afafff"
    "#afd700"
    "#afd75f"
    "#afd787"
    "#afd7af"
    "#afd7d7"
    "#afd7ff"
    "#afff00"
    "#afff5f"
    "#afff87"
    "#afffaf"
    "#afffd7"
    "#afffff"
    "#d70000"
    "#d7005f"
    "#d70087"
    "#d700af"
    "#d700d7"
    "#d700ff"
    "#d75f00"
    "#d75f5f"
    "#d75f87"
    "#d75faf"
    "#d75fd7"
    "#d75fff"
    "#d78700"
    "#d7875f"
    "#d78787"
    "#d787af"
    "#d787d7"
    "#d787ff"
    "#d7af00"
    "#d7af5f"
    "#d7af87"
    "#d7afaf"
    "#d7afd7"
    "#d7afff"
    "#d7d700"
    "#d7d75f"
    "#d7d787"
    "#d7d7af"
    "#d7d7d7"
    "#d7d7ff"
    "#d7ff00"
    "#d7ff5f"
    "#d7ff87"
    "#d7ffaf"
    "#d7ffd7"
    "#d7ffff"
    "#ff0000"
    "#ff005f"
    "#ff0087"
    "#ff00af"
    "#ff00d7"
    "#ff00ff"
    "#ff5f00"
    "#ff5f5f"
    "#ff5f87"
    "#ff5faf"
    "#ff5fd7"
    "#ff5fff"
    "#ff8700"
    "#ff875f"
    "#ff8787"
    "#ff87af"
    "#ff87d7"
    "#ff87ff"
    "#ffaf00"
    "#ffaf5f"
    "#ffaf87"
    "#ffafaf"
    "#ffafd7"
    "#ffafff"
    "#ffd700"
    "#ffd75f"
    "#ffd787"
    "#ffd7af"
    "#ffd7d7"
    "#ffd7ff"
    "#ffff00"
    "#ffff5f"
    "#ffff87"
    "#ffffaf"
    "#ffffd7"
    "#ffffff"
    "#080808"
    "#121212"
    "#1c1c1c"
    "#262626"
    "#303030"
    "#3a3a3a"
    "#444444"
    "#4e4e4e"
    "#585858"
    "#606060"
    "#666666"
    "#767676"
    "#808080"
    "#8a8a8a"
    "#949494"
    "#9e9e9e"
    "#a8a8a8"
    "#b2b2b2"
    "#bcbcbc"
    "#c6c6c6"
    "#d0d0d0"
    "#dadada"
    "#e4e4e4"
    "#eeeeee"))

(defvar theme-util--4-bit-color-list
  '("#000000"
    "#0000FF"
    "#00FF00"
    "#00FFFF"
    "#000080"
    "#008000"
    "#008080"
    "#800000"
    "#800080"
    "#808000"
    "#808080"
    "#C0C0C0"
    "#FF0000"
    "#FF00FF"
    "#FFFF00"
    "#FFFFFF"))

(provide 'theme-util)

;;; theme-util.el ends here
#+end_src
*** pale
#+begin_src emacs-lisp :tangle themes/pale-theme.el
;;; pale-theme.el --- Light theme      -*- lexical-binding: t; -*-

;; Author: Yuan Fu <casouri@gmail.com>

;;; This file is NOT part of GNU Emacs

;;; Commentary:
;;
;; A quieter theme with ink-on-paper feel. It uses more bold, italic,
;; and gray for contrast in place of different colors.

;;; Code:

(require 'theme-util)

(deftheme pale
  "Pale theme.")

(theme-util-deffaces
 'magit-heading-selection
 'magit-heading-highlight)

;; (FACE INHERIT FOREGROUND BACKGROUND UNDERLINE WEIGHT SLANT REST-ATTR)
(theme-util-set-faces 'pale
  (cl-flet ((darken #'theme-util-darken)
            (brighten #'theme-util-brighten)
            (overlay #'theme-util-color-overlay))
    (let* ((bg "#ffffff")
           (bg-tooltip "gray92")
           (bg-block "gray90")
           (bg-region "gray85")

           (fg  "#000000")
           (fg-weak "#9a9ea2")

           (hl-weak bg-tooltip)
           (hl-normal "#F5F573")
           (hl-strong "#e8e800")

           ;; Colors indented for foreground are less pronounced.
           (hl-fg "#8C6E14")
           (red-fg "DarkRed")
           (blue-fg "#122DC2")
           (green-fg "#007345")

           ;; Warning and error are brighter to catch attention.x
           (warning "#DA7A48")
           (err     "#E04E49")
           (ok      "#489446")

           ;; Note that this is not a cons cell.
           (tty       '((type nil)))
           ;; Pre-defined templates.
           (bold '(nil nil nil nil semi-bold))
           (underline '(nil nil nil t))
           (italic '(nil nil nil nil nil italic))
           (light '(nil nil nil nil semi-light)))
;;; Builtin faces
      `((default     (nil ,fg ,bg))
        (region      (nil nil ,bg-region))
        (highlight   (nil nil ,hl-strong))
        (cursor      (nil "white" "black"))
        (match       (nil ,ok nil nil bold))
        (error       (nil ,err))
        (warning     (nil ,warning))
        (success     (nil ,ok))
        (tooltip     (nil nil ,bg-tooltip))
        (fringe      ())
        (shadow      (nil ,fg-weak))
        (vertical-border (nil ,bg-tooltip ,bg-tooltip) nil ,tty)
        (link        (nil nil ,hl-weak))
        (link-visited (link))
        (bold ,bold)
        (underline ,underline)
        (italic ,italic)

        (vertical-border     (nil nil "black"))
        (minibuffer-prompt   ,bold)
        (isearch             (nil nil ,hl-strong))
        (lazy-highlight      (nil nil ,hl-strong))
        (isearch-fail        (error))
        (show-paren-match    ,bold)
        (trailing-whitespace (nil nil ,err))

        (widget-field        (nil nil ,bg-block))
        (widget-inactive     (nil ,fg-weak))

        ;; See also builtin-config.el (Customize) where I increase line
        ;; spacing and change font.
        (custom-button
         (nil nil ,bg-tooltip)
         (:box (:line-width 3 :color ,bg-tooltip)))
        (custom-button-mouse
         (custom-button nil ,hl-strong)
         (:box (:line-width 3 :color ,hl-strong)))
        (custom-button-pressed
         (custom-button nil ,bg-region)
         (:box (:line-width 3 :color ,bg-region)))

        (custom-changed        ,bold)
        (custom-comment-tag    (font-lock-comment-face))
        (custom-documentation  ())
        (custom-variable-tag   ,italic)
        (custom-face-tag       (custom-variable-tag))
        (custom-group-subtitle (custom-variable-tag))
        (custom-group-tag      (nil))
        (custom-invalid        (nil ,err))
        (custom-modified       (nil ,warning))
        (custom-rogue          (nil ,warning))
        (custom-set            (nil ,ok))
        (custom-state          ())
        (custom-themed         (nil ,ok))

        (font-lock-builtin-face              ,italic)
        (font-lock-comment-face              (nil ,fg-weak))
        (font-lock-comment-delimiter-face    (font-lock-comment-face))
        (font-lock-doc-face                  (shadow))
        (font-lock-constant-face             ,italic)
        (font-lock-keyword-face              (nil ,red-fg))
        (font-lock-string-face               ())
        ;; (font-lock-type-face                 (nil ,hl-fg))
        ;; (font-lock-type-face                 (nil ,blue-fg))
        (font-lock-type-face                 (nil ,green-fg))
        (font-lock-variable-name-face        ,bold)
        (font-lock-function-name-face        ,bold)
        (font-lock-warning-face              (error))
        (font-lock-negation-char-face        (warning))
        (font-lock-preprocessor-face         ())
        (font-lock-preprocessor-char-face    ())
        (font-lock-regexp-grouping-backslash ,bold)
        (font-lock-regexp-grouping-construct ,bold)

        (sh-quoted-exec (nil ,red-fg))

        (mode-line (nil nil ,bg-tooltip))
        (mode-line-inactive (mode-line nil ,bg-block))
        (header-line (mode-line) (:height 150))

        (tab-bar (mode-line nil ,bg) (:height 160))
        (tab-bar-tab (tab-bar nil ,bg))
        (tab-bar-tab-inactive (tab-bar nil ,bg-block))
        (tab-bar-tab-group-current (tab-bar-tab nil nil nil bold))
        (tab-bar-tab-group-inactive (tab-bar-tab-inactive))
        (tab-bar-tab-ungrouped (tab-bar-tab-inactive))

        (completions-common-part (shadow))
        (completions-first-difference (bold))

;;; Packages

        (flyspell-duplicate () (:underline
                                (:style wave :color ,hl-fg)))
        (flyspell-incorrect () (:underline
                                (:style wave :color ,hl-fg)))

        (company-tooltip                     (tooltip))
        (company-tooltip-annotation          (company-tooltip))
        (company-tooltip-annotation-selection (company-tooltip-selection))
        (company-tooltip-common ((company-tooltip bold)))
        (company-tooltip-common-selection ((company-selection bold)))
        (company-tooltip-mouse ((company-tooltip underline)))
        (company-tooltip-selection (company-tooltip nil ,hl-strong))
        (company-scrollbar-bg                (company-tooltip))
        (company-scrollbar-fg                (company-tooltip nil ,bg-region))
        (company-preview                     (shadow))
        (company-preview-common              (company-preview))
        (company-preview-search              (company-preview))

        (corfu-default (tooltip))
        (corfu-current (completions-highlight))
        (corfu-border  (nil nil ,fg-weak))

        (orderless-match-face-0 (shadow))
        (orderless-match-face-1 (orderless-match-face-0))
        (orderless-match-face-2 (orderless-match-face-0))
        (orderless-match-face-3 (orderless-match-face-0))

        (magit-heading-highlight (nil nil ,bg-tooltip) (:extend t))
        (magit-heading-selection (nil nil ,bg-block) (:extend t))

        (magit-section-heading           ,bold)
        (magit-section-highlight         (magit-heading-highlight))
        (magit-section-heading-selection (magit-heading-selection))
        (magit-section-secondary-heading
         (magit-section-heading nil nil nil light))

        (magit-diff-file-heading           ,bold)
        (magit-diff-file-heading-highlight (magit-heading-highlight))
        (magit-diff-file-heading-selection (magit-heading-selection))

        (magit-diff-hunk-heading           ,italic)
        (magit-diff-hunk-heading-highlight (magit-heading-highlight))
        (magit-diff-hunk-heading-selection (magit-heading-selection))
        ;; selected hunk region
        (magit-diff-hunk-region            (region))
        ;; this also determines the hunk region boundary
        (magit-diff-lines-heading          (nil ,bg ,err))
        (magit-diff-revision-summary       ,bold)

        (magit-bisect-bad        (error))
        (magit-bisect-good       (success))
        (magit-bisect-skip       (warning))
        (magit-blame-date        (nil ,hl-fg))
        (magit-blame-heading     (magit-heading-highlight))
        (magit-branch-current    (nil ,red-fg))
        (magit-branch-local      ,bold)
        (magit-branch-remote     ,bold)
        (magit-cherry-equivalent (success))
        (magit-cherry-unmatched  (error))
        (magit-tag               (nil ,hl-fg))
        (magit-filename          ())

        (magit-diff-added            (nil ,ok ,(overlay bg ok 0.1)))
        (magit-diff-added-highlight  (nil ,ok ,(overlay bg ok 0.2)))
        (diff-refine-added           (nil ,ok "#99ff99"))

        (magit-diff-removed          (nil ,err ,(overlay bg err 0.1)))
        (magit-diff-removed-highlight (nil ,err ,(overlay bg err 0.2)))
        (diff-refine-removed         (nil ,err "#ffaaaa"))

        (magit-diff-base           (nil ,warning ,(overlay bg warning 0.1)))
        (magit-diff-base-highlight (nil ,warning ,(overlay bg warning 0.2)))

        (magit-diff-context           (default))
        (magit-diff-context-highlight (nil ,fg ,bg-block))

        (magit-diffstat-added            (nil ,ok))
        (magit-diffstat-removed          (nil ,err))
        (magit-dimmed                    (shadow))
        (magit-hash                      (nil ,hl-fg))
        (magit-header-line               ,bold)
        (magit-log-author                (default))
        (magit-log-date                  (default))
        (magit-log-graph                 (default))
        (magit-process-ng                (error))
        (magit-process-ok                (success))
        ;; (magit-reflog-amend              (nil ,violet2))
        ;; (magit-reflog-checkout           (nil ,blue1))
        ;; (magit-reflog-cherry-pick        (nil ,green))
        ;; (magit-reflog-commit             (nil ,green))
        ;; (magit-reflog-merge              (nil ,green))
        ;; (magit-reflog-other              (nil ,blue1))
        ;; (magit-reflog-rebase             (nil ,violet2))
        ;; (magit-reflog-remote             (nil ,blue1))
        ;; (magit-reflog-reset              (error))
        ;; (magit-refname                   (nil ,fg-weak))
        ;; (magit-sequence-drop             (nil ,red))
        ;; (magit-sequence-head             (nil ,blue1))
        ;; (magit-sequence-part             (nil ,orange))
        ;; (magit-sequence-stop             (nil ,green))
        ;; (magit-signature-bad             (error))
        ;; (magit-signature-error           (error))
        ;; (magit-signature-expired         (nil ,orange))
        ;; (magit-signature-good            (success))
        ;; (magit-signature-revoked         (nil ,orange))
        ;; (magit-signature-untrusted       (nil ,orange))

        (rainbow-delimiters-unmatched-face (nil ,err))
        (rainbow-delimiters-mismatched-face
         (rainbow-delimiters-unmatched-face))

        (smerge-lower   (magit-diff-added))
        (smerge-upper   (magit-diff-removed))
        (smerge-base    (magit-diff-base))
        (smerge-markers (nil nil nil nil bold))

        (which-key-key-face                   (nil nil ,hl-strong))
        (which-key-group-description-face     ())
        (which-key-command-description-face   ())
        (which-key-local-map-description-face ())

        (hl-paren-face (nil "red" nil nil bold))

        (info-title-1 (info-title-2) (:height 1.3))
        (info-title-2 (info-title-4) (:height 1.2))
        (info-title-3 (info-title-4))
        (info-title-4 (variable-pitch))
        (outline-1 (info-title-1))
        (outline-2 (info-title-2))
        (outline-3 (info-title-3))
        (outline-4 (info-title-4))
        (outline-5 (outline-4))
        (outline-6 (outline-4))
        (outline-7 (outline-4))
        (outline-8 (outlint-4))

        (org-level-1 (info-title-1))
        (org-level-2 (info-title-2))
        (org-level-3 (info-title-3))
        (org-level-4 (info-title-4))
        (org-document-title (info-title-1))
        (org-meta-line (shadow nil nil nil nil italic))
        (org-document-info (org-meta-line))
        (org-document-info-keyword (org-meta-line))

        (org-verbatim         (fixed-pitch))
        (org-code             (org-verbatim))
        (org-block            (org-verbatim nil ,bg-block) (:extend t))
        (org-block-begin-line ((org-block org-meta-line)))
        (org-block-end-line   ((org-block org-meta-line)))
        (org-formula          (fixed-pitch))
        (org-quote            (org-block))

        (org-table             (nil))
        (org-todo              (highlight))
        (org-time-grid         (nil ,hl-fg))
        (org-upcoming-deadline (nil ,err))

        (helpful-heading (info-title-3))

        (ghelp-entry-title (info-title-2))

        (diff-hl-change (nil ,warning ,(overlay bg warning 0.1)))

        (line-number              ((fixed-pitch)))
        (line-number-current-line (nil nil ,bg-block))
        (line-number-major-tick   (line-number))
        (line-number-minor-tick   (line-number))

        (rime-default-face (tooltip) (:height 150))
        (rime-highlight-candidate-face ((bold rime-default-face)))
        (rime-code-face (rime-default-face))

        (selectrum-prescient-primary-highlight (nil nil ,hl-normal))
        (selectrum-prescient-secondary-highlight (nil nil ,hl-normal))

        (consult-bookmark (consult-buffer))
        (consult-file (consult-file))

        (erc-notice-face (nil ,red-fg)) ; Get rid of bold.
        (erc-timestamp-face (nil ,ok)) ; Use darker green.
        (erc-current-nic-face (nil ,red-fg)) ; Use darker blue.

        (dictionary-word-definition-face (variable-pitch))
        (dictionary-word-entry-face (variable-pitch nil nil nil bold))
        (dictionary-reference-face ((variable-pitch link)))

        (gnus-summary-normal-unread (variable-pitch))
        (gnus-summary-normal-read
         (gnus-summary-normal-unread ,ok))
        (gnus-summary-normal-undownloaded
         (gnus-summary-normal-unread ,red-fg))
        (gnus-summary-normal-ticked
         (gnus-summary-normal-unread ,hl-fg))
        (gnus-summary-normal-ancient
         (gnus-summary-normal-unread ,blue-fg))

        (debbugs-gnu-new (nil ,err))
        (debbugs-gnu-handled (nil ,ok))
        (debbugs-gnu-tagged (nil ,err))
        ))))

(provide-theme 'pale)

;;; pale-theme.el ends here
#+end_src

*** nano
#+begin_src emacs-lisp
(eat/pkg nano-theme "https://github.com/404cn/nano-theme.el")
(add-to-list 'custom-theme-load-path (expand-file-name "elpa/nano-theme" user-emacs-directory))
#+end_src
*** carbon
#+begin_src emacs-lisp
(eat/pkg carbon-theme "https://github.com/DogLooksGood/carbon-theme")
(add-to-list 'custom-theme-load-path (expand-file-name "elpa/carbon-theme" user-emacs-directory))
#+end_src
